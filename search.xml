<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[虚拟机字节码执行引擎]]></title>
      <url>http://yoursite.com/2018/01/15/JVM/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
      <content type="html"><![CDATA[<h1 id="一、栈帧"><a href="#一、栈帧" class="headerlink" title="一、栈帧"></a>一、栈帧</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>栈帧<strong>:的用于支持虚拟机</strong>方法调用<strong>和</strong>方法执行<strong>的数据结构，它的虚拟机运行时数据区中</strong>虚拟机栈**的栈元素。每个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>每一个栈帧都包含了：</p>
<ul>
<li>局部变量表</li>
<li>操作数栈</li>
<li>动态连接</li>
<li>方法返回地址</li>
<li>一些额外的附加信息。</li>
</ul>
<p>一个线程中的方法调用连可能会很长，很多方法都同时处于执行状态。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧对应的方法叫做当前方法。结构如下图</p>
<p>  <img src="https://github.com/paine1690/HelloWorld/blob/master/pic/jvm/1.png?raw=true" alt="1"></p>
<h2 id="1、局部变量表"><a href="#1、局部变量表" class="headerlink" title="1、局部变量表"></a>1、局部变量表</h2><p>局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。</p>
<ul>
<li>在编译期间，就在class文件的Code属性中确定了需要分配的局部变量表的最大容量</li>
<li>变脸表以槽为单位（Slot）。一般以32位位一个Slot，<ul>
<li>32位以内的数据类型：boolean、byte、char、short、int、float、reference和returnAdress占一个Slot</li>
<li>64位的数据类型double和long占两个Slot，局部变量表为线程私有，即使占有两个Slot，不是原子操作也不会引起数据安全问题。</li>
</ul>
</li>
<li>Slot是可以重用的</li>
<li>定义局部变量必须初始化，不然不会编译通过</li>
</ul>
<h2 id="2、动态连接"><a href="#2、动态连接" class="headerlink" title="2、动态连接"></a>2、动态连接</h2><p>在class文件的常量池中存在大量的符号引用，这些符号引用转换为直接引用有两种：</p>
<ul>
<li>静态解析：类加载或者第一次使用阶段完成，</li>
<li>动态连接：在第一次运行期间完成</li>
</ul>
<p>下面详细来介绍这两种方式。</p>
<h1 id="二、方法调用"><a href="#二、方法调用" class="headerlink" title="二、方法调用"></a>二、方法调用</h1><p>方法调用不等于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本，即调用哪一个方法。</p>
<p>个人理解就是确定将符号引用转换为哪个直接引用。</p>
<h2 id="1、解析"><a href="#1、解析" class="headerlink" title="1、解析"></a>1、解析</h2><p>前面提到过符号引用会有一部分在<strong>类加载</strong>的解析阶段转化为直接引用，这种解析能成立的条件就是：</p>
<ol>
<li>方法在程序真正运行之前就有一个可确定的调用版本</li>
<li>这个方法的调用版本在运行期是不可改变的</li>
</ol>
<p>那么有哪些方法能符合这两个条件呢，首先先来看一下Java虚拟机中方法调用的5个字节码：</p>
<ul>
<li>invokestatic：调用静态方法</li>
<li>invokespecial：调用实例构造器init方法、私有方法和父类方法</li>
<li>invokevirtual：调用所有的虚方法</li>
<li>invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象</li>
<li>invokedynamic</li>
</ul>
<p>以上5个指令中，调用虚方法和接口方法显然会在运行时期才能确定，而invokedynamic的逻辑是由用户所设定的引导方法决定的，所以，只要是被invokestatic和invokespecial指令调用的方法，都可以在解析阶段就确定唯一的调用版本，因为前者与类型直接关联，后者在外部不可以被访问，它们的特点决定了不可能通过继承或者别的方式重写其他版本。</p>
<p>当然还有一种，就是final关键字修饰的方法，虽然它的通过invokevirtual来调用的，但是由于它无法被覆盖，所以也没有其他版本。</p>
<p>综上所述，这些在类加载的时候就会把符号引用解析为直接引用的方法被称为<strong>非虚方法</strong>。他们包括：</p>
<ul>
<li>静态方法</li>
<li>私有方法</li>
<li>实例构造器</li>
<li>父类方法</li>
<li>final修饰的方法</li>
</ul>
<p>而其他的方法则称为<strong>虚方法</strong>。</p>
<p>解析是一个静态的过程，在编译期就可以完全确定，在类加载阶段就会完成符号引用到直接引用。</p>
<p>而分派则是一个动态则有可能是静态的也有可能是动态的。根据宗量数又可分为单分派和多分派，下面来详细研究。</p>
<h2 id="2、分派"><a href="#2、分派" class="headerlink" title="2、分派"></a>2、分派</h2><h3 id="2-1、静态分派"><a href="#2-1、静态分派" class="headerlink" title="2.1、静态分派"></a>2.1、静态分派</h3><p>首先来看一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"hello, guy"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man guy)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"hello, gentleman"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman guy)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"hello, lady"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Human man = <span class="keyword">new</span> Man();</div><div class="line">        Human woman = <span class="keyword">new</span> Woman();</div><div class="line">        HelloWorld hw = <span class="keyword">new</span> HelloWorld();</div><div class="line">        hw.sayHello(man);</div><div class="line">        hw.sayHello(woman);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是关于重载的代码，两个输出都是hello，guy。接下来从原理上分析一下原因，也就是为什么会选择对应的方法。</p>
<p>####2.1.1 静态类型与实际类型</p>
<p>首先要明确两个概念，变量的静态类型和实际类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Human man = <span class="keyword">new</span> Man();</div></pre></td></tr></table></figure>
<p>在这段代码中，Human成为变量的静态类型，后面的Man成为变量的实际类型，静态类型和实际类型在程序中都可以发生一些变化，区别在于：</p>
<ul>
<li>静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型在编译器是可知的。</li>
<li>实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//实际类型变化</span></div><div class="line">Human man = <span class="keyword">new</span> Man();</div><div class="line">man = <span class="keyword">new</span> Woman();</div><div class="line"><span class="comment">//静态类型变化</span></div><div class="line">hw.sayHello((Man)man);</div><div class="line">hw.sayHello((Woman)man);</div></pre></td></tr></table></figure>
<p>####2.1.2 方法的接受者</p>
<p>另一个需要明确的概念就是方法的接收者，比如在上面的代码中，两个方法的接受者就是对象hw。</p>
<h4 id="2-1-3-静态分派"><a href="#2-1-3-静态分派" class="headerlink" title="2.1.3 静态分派"></a>2.1.3 静态分派</h4><p>明确了上面几个概念后再来看一下这个代码，在main方法中，在两个sayHello的接收者已经是对象hw的前提下，使用哪个重载版本，就完全取决于传入参数的数量和数据类型。而虚拟机在重载时是通过参数的<strong>静态类型</strong>而不是实际类型作为判断依据的。</p>
<p>而静态类型是<strong>编译期</strong>可知的，因此，编译期在编译阶段会根据参数的静态类型决定使用哪个重载版本，所以选择了sayHello(Human)作为调用目标，并把这个方法的<strong>符号引用</strong>写到main方法里的两条invokevirtual指令的参数中。</p>
<p>所有依赖<strong>静态类型</strong>来定位方法执行版本的分派过程称作<strong>静态分派</strong>。静态分派的典型应用就是方法重载。</p>
<h4 id="2-1-4-更多关于重载"><a href="#2-1-4-更多关于重载" class="headerlink" title="2.1.4 更多关于重载"></a>2.1.4 更多关于重载</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Object arg)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"hello Object"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"hello int"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"hello long"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Character arg)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"hello Character"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span> arg)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"hello char"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span>... arg)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"hello char..."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Serializable arg)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"hello Serializable"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        sayHello(<span class="string">'a'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码的输出为hello char，因为找到了参数为cha的重载方法，那么接下来：</p>
<ul>
<li>如果注释掉char参数的方法，那么输出就会为int，因为’a’除了字符串，还可以表示数字97，索引int也可以适合</li>
<li>如果注释掉int，那么输出就会为long，因为int匹配不到后自动向上转型为long。按照char-int-long-float-double这个顺序会一直转型上去，但是不会向下转型为byte或short</li>
<li>如果注释掉long，会输出Character，因为char可以自动装箱</li>
<li>如果注释掉Character，会输出Serializable，因为Character类实现了Serializable接口。</li>
<li>如果注释掉Serializable，会输出Object，因为是上面的父类，如果有多个父类，就会从继承关系中从下向上搜索，越接近上层优先级越低。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Object arg)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"hello Object"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"hello String"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        sayHello(<span class="keyword">null</span>);<span class="comment">//hello String</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一道笔试题，输出的是hello String。</p>
<p>因为<strong>null可以转换为任意类型</strong>。所以按照上面说的继承关系中越上级优先级，会优先匹配String。如果注释掉String，就会输出Object。</p>
<h3 id="2-2、动态分派"><a href="#2-2、动态分派" class="headerlink" title="2.2、动态分派"></a>2.2、动态分派</h3><p>再来看一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"man say hello"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"woman say hello"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Human man = <span class="keyword">new</span> Man();</div><div class="line">        Human woman = <span class="keyword">new</span> Woman();</div><div class="line">        man.sayHello();<span class="comment">//man say hello</span></div><div class="line">        woman.sayHello();<span class="comment">//woman say hello</span></div><div class="line">        man = <span class="keyword">new</span> Woman();</div><div class="line">        man.sayHello();<span class="comment">//woman say hello</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一段关于重写的代码，通过它来看一下动态分派的过程。</p>
<p>首先，按照上面静态分派的思路，前面两个方法的接收者都是Human，参数也一样(都没有参数)，所以从二者在编译时期的符号引用应该是相同的，但是在运行期间却执行了不同的方法，原因就要从invokevirtual指令的多态查找过程说起，invokevirtual指令的运行时解析过程大致分为以下几个步骤：</p>
<ol>
<li>找到操作数栈顶的第一个元素(即为方法的接收者)所指向的对象的<strong>实际类型</strong>，记作C</li>
<li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常</li>
<li>否则按照继承关系<strong>从下往上</strong>依次对C的各个父类进行第二步的搜索和验证过程</li>
<li>如果始终没有找到，则抛出java.lang.AbstractMethodError异常</li>
</ol>
<p>由于invokevirtual指令在第一步就是在运行期间确定接收者的实际类型，所以两次调用中的invokevirtual指令把常量池中的类方法<strong>符号引用</strong>解析到了不同的<strong>直接引用</strong>上，这个过程就是Java中重写的本质。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</p>
<h3 id="2-3、单分派与多分派"><a href="#2-3、单分派与多分派" class="headerlink" title="2.3、单分派与多分派"></a>2.3、单分派与多分派</h3><p>再来看一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QQ</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">_360</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"father choose qq"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"father choode 360"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"son choose qq"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"son choode 360"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Father father = <span class="keyword">new</span> Father();</div><div class="line">        Father son = <span class="keyword">new</span> Son();</div><div class="line">        father.hardChoice(<span class="keyword">new</span> _360());<span class="comment">//father choode 360</span></div><div class="line">        son.hardChoice(<span class="keyword">new</span> QQ());<span class="comment">//son choose qq</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里即有重写又有重载，所以从两个阶段来看</p>
<h4 id="2-3-1-编译期"><a href="#2-3-1-编译期" class="headerlink" title="2.3.1 编译期"></a>2.3.1 编译期</h4><p>首先在编译阶段编译器的选择过程，即静态分派的过程。选择的依据有两点：</p>
<ul>
<li>静态类型是Father还是Son</li>
<li>方法参数是QQ还是360</li>
</ul>
<p>这次选择结果的最终产物是产生了两条invokevirtual指令，两条指令的参数分别指向常量池中Father.hardChoice(360)和Father.hardChoice(QQ)方法的<strong>符号引用</strong>。因为根据两个宗量进行选择，所以静态分派属于<strong>多分派</strong>类型。</p>
<h4 id="2-3-2-运行期"><a href="#2-3-2-运行期" class="headerlink" title="2.3.2 运行期"></a>2.3.2 运行期</h4><p>再来看一下运行阶段虚拟机的选择，即动态分派的过程。再执行son.hardChoice的代码，准确来说是invokevirtual指令时，虚拟机不会关心参数到底是QQ还是360，唯一影响虚拟机选择的因素只有此方法的<strong>接收者的实际类型</strong>是Father还是Son。所以动态分派属于<strong>单分派</strong>类型。</p>
<h4 id="2-3-3-静态多分派-动态单分派"><a href="#2-3-3-静态多分派-动态单分派" class="headerlink" title="2.3.3 静态多分派 动态单分派"></a>2.3.3 静态多分派 动态单分派</h4><p>从上面可以看出，Java是属于静态多分派，动态单分派的语言。</p>
<table>
<thead>
<tr>
<th>分派类型</th>
<th>参考宗量</th>
<th>执行者</th>
<th>确定时期</th>
<th>引用类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>静态多分派</td>
<td>接收者的静态类型、参数的静态类型</td>
<td>编译器</td>
<td>编译期</td>
<td>符号引用</td>
</tr>
<tr>
<td>动态多分派</td>
<td>接收者的实际类型</td>
<td>虚拟机</td>
<td>运行期</td>
<td>实际引用</td>
</tr>
</tbody>
</table>
<p>最后还有一点就是静态分派和解析，这两者并不是二选一的关系，它们是不同层次上的筛选、确定目标方法的过程。比如静态方法也可以重载，重载选择过程就是通过静态分派完成的，而同时它又是在运行期不可更改的，所以解析过程就直接把符号引用转换成直接引用了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中的Lambda表达式]]></title>
      <url>http://yoursite.com/2017/07/13/Java/Java%E4%B8%AD%E7%9A%84Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>Lambda表达式是Java8推出的新特性，虽然早有耳闻，但是平时从来没有用过，所以一直没有学习。来实习后才发现已经被大量使用，而且用起来确实非常方便，尤其是在大数据爆发的背景下，数据处理越来越频繁，而Lambda表达式恰好可以结合Stream类更简洁方便的处理数据流，因此在Java9出来之前，正好学习一下Lambda表达式。</p>
<h1 id="一、Lambda表达式"><a href="#一、Lambda表达式" class="headerlink" title="一、Lambda表达式"></a>一、Lambda表达式</h1><h2 id="1、特点"><a href="#1、特点" class="headerlink" title="1、特点"></a>1、特点</h2><p>Lambda表达式可以看错是可以传递的匿名函数的一种方式：</p>
<ol>
<li>匿名 - 没有名称</li>
<li>函数 - 有函数的一切组成部分<ul>
<li>参数列表</li>
<li>函数主体</li>
<li>返回类型</li>
<li>可能有一个异常列表</li>
</ul>
</li>
<li>传递 - 可以作为参数传递给方法或存储在变量中</li>
<li>简洁 - 无需像匿名类那样写很多模版代码</li>
</ol>
<h2 id="2、组成语法"><a href="#2、组成语法" class="headerlink" title="2、组成语法"></a>2、组成语法</h2><p>Lambda表达式经常和匿名类一起提起，下面来一下他们两个的写法与区别。匿名类最常用的就是Comparator接口了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">//匿名类</span></div><div class="line">   Comparator&lt;Apple&gt; byWeight = <span class="keyword">new</span> Comparator&lt;Apple&gt;()&#123;</div><div class="line">     <span class="meta">@Override</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Apple a1, Apple a2)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> a1.getWeight().compareTo(a2.getWeight());<span class="comment">//注意返回weight要为Integer才能调用compareTo</span></div><div class="line">     &#125;      </div><div class="line">   &#125;;</div><div class="line"></div><div class="line"><span class="comment">//Lambda表达式</span></div><div class="line">byWeight = (Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight());</div></pre></td></tr></table></figure>
<p>明显后者更加简洁。可以看出Lambda表达式有三个部分：</p>
<ul>
<li>参数列表：采用了Comparator中compare方法的参数，两个Apple。</li>
<li>箭头：把参数列表与Lamda主体分隔开。</li>
<li>Lambda主体：比较两个Apple的重量。表达式就是Lambda的返回值。</li>
</ul>
<p>Lambda的基本语法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(paramaters) -&gt; expression</div><div class="line">或者</div><div class="line">(paramaters) -&gt; &#123;expression; &#125;</div></pre></td></tr></table></figure>
<h1 id="二、Lambda表达式的使用方法"><a href="#二、Lambda表达式的使用方法" class="headerlink" title="二、Lambda表达式的使用方法"></a>二、Lambda表达式的使用方法</h1><p>Lambda表达式的使用主要是在函数式接口上。</p>
<h2 id="1、函数式接口"><a href="#1、函数式接口" class="headerlink" title="1、函数式接口"></a>1、函数式接口</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>函数式接口就是<strong>只定义一个抽象方法的接口</strong>。</p>
<p>Java的API中也有一些函数式接口，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;<span class="comment">//java.util.Comparator</span></div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span></span>&#123;<span class="comment">//java.lang.Runnable</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;<span class="comment">//java.util.concurrent.Callable</span></div><div class="line">  <span class="function">V <span class="title">call</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Java中接口现在可以有默认的实现了。哪怕有很多默认方法，只要是定义了一个抽象方法，就是函数式接口。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>Lambda表达式可以以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例。也就是以更简单的方式实现匿名类的功能。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Runnable r1 = () -&gt; System.out.println(<span class="string">"hello"</span>);</div></pre></td></tr></table></figure>
<h2 id="2、函数描述符"><a href="#2、函数描述符" class="headerlink" title="2、函数描述符"></a>2、函数描述符</h2><p>函数式接口的抽象方法的签名基本上就是Lambda表达式的签名。我们将这种抽象方法叫做<strong>函数描述符</strong>。主要看它的接收参数与返回类型。</p>
<h2 id="3、FunctionalInterface声明"><a href="#3、FunctionalInterface声明" class="headerlink" title="3、FunctionalInterface声明"></a>3、FunctionalInterface声明</h2><p>在Java的API中，函数式接口都带有@FunctionalInterface的标注。</p>
<p>这个标注的意义就是说明这个接口是一个函数式接口。</p>
<p>Java8中在java.util.function包中，自带了很多带有@FunctionalInterface标注的函数式接口。</p>
<h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</div><div class="line">  	<span class="comment">//下面还有很多default方法，省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接收泛型T对象，返回一个Boolean。</p>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接收泛型T对象，没有返回(void)。可以用于对某个对象执行某些操作。</p>
<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</div><div class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接收一个泛型T对象，返回一个泛型R的对象。可以用于将输入对象的信息映射到输出中。</p>
<h3 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>没有接受值，返回一个泛型T的对象。</p>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>上面的都是泛型，如果输入基本类型，Java会自动进行装箱和拆箱操作，这样会浪费很多资源，因为装箱后会需要更多的内存。</p>
<p>因此针对专门的输入参数类型的函数式及饿哦库的名称都可加上对应的原始类型前缀。比如：</p>
<p>IntPredicate, DoublePredicate, IntFunction等等。</p>
<h1 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h1><h2 id="1、类型检查"><a href="#1、类型检查" class="headerlink" title="1、类型检查"></a>1、类型检查</h2><p>Lambda的类型是从使用Lambda的上下文推断出来的。上下文（比如接受它传递的方法的参数，或者接受它的值的局部变量）中Lambda表达式需要的类型称为目标类型。</p>
<h2 id="2、类型推断"><a href="#2、类型推断" class="headerlink" title="2、类型推断"></a>2、类型推断</h2><p>Java编译器会从上下文（目标类型）推断出用上面函数式接口来配合Lambda表达式，这意味着它也可以推断出适合的Lambda签名，因为函数描述符可以通过目标类型来得到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Apple&gt; c1 = (Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight());</div><div class="line">Comparator&lt;Apple&gt; c1 = (a1, a2) -&gt; a1.getWeight().compareTo(a2.getWeight());</div></pre></td></tr></table></figure>
<p>这样代码可以进一步简化。</p>
<h2 id="3、方法引用"><a href="#3、方法引用" class="headerlink" title="3、方法引用"></a>3、方法引用</h2><p>方法引用可以重复使用现有的方法定义，并像Lambda一样传递它们。在一些情况下，比起使用Lambda表达式，它们更易读。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>目标引用放在分隔符<code>::</code> 前，方法的名称放在后面。例如：</p>
<table>
<thead>
<tr>
<th>Lambda</th>
<th>等效的方法引用</th>
</tr>
</thead>
<tbody>
<tr>
<td>(Apple a) -&gt; a.getWeight()</td>
<td>Apple::getWeight</td>
</tr>
<tr>
<td>() -&gt; Thread.currentThread().dumpStack()</td>
<td>Thread.currentThread::dumpStack</td>
</tr>
<tr>
<td>(str, i) -&gt; str.substring(i)</td>
<td>String::substring</td>
</tr>
<tr>
<td>(String s) -&gt; System.out.println(s)</td>
<td>System.out::println</td>
</tr>
</tbody>
</table>
<p>可以把方法引用看做针对仅仅涉及单一方法的Lambda语法糖。</p>
<h3 id="方法引用的构建"><a href="#方法引用的构建" class="headerlink" title="方法引用的构建"></a>方法引用的构建</h3><p>方法引用主要有三类：</p>
<ol>
<li><p>指向<strong>静态方法</strong>的方法引用。</p>
<p>例如Integer的parseInt方法，可以写作：Integer::parseInt。</p>
</li>
<li><p>指向<strong>任意类型实例方法</strong>的方法引用。</p>
<p>例如String的length方法，写作String::length</p>
</li>
<li><p>指向<strong>现有对象的实例方法</strong>的方法引用。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>Lambda</th>
<th>方法引用</th>
</tr>
</thead>
<tbody>
<tr>
<td>(args) -&gt; ClassName.staticmethod(args)</td>
<td>ClassName::staticMethod</td>
</tr>
<tr>
<td>(arg0, rest) -&gt; arg0.instanceMethod(rest)</td>
<td>ClassName::instancemethod               (arg0是ClassName类型的)</td>
</tr>
<tr>
<td>(args) -&gt; expr.instancemethod(args)</td>
<td>expr::instanceMethod</td>
</tr>
</tbody>
</table>
<p>仔细总结就可以发现，能转换的基础就是二者的签名必须相同。</p>
<h2 id="3、构造函数引用"><a href="#3、构造函数引用" class="headerlink" title="3、构造函数引用"></a>3、构造函数引用</h2><p>以上面的Supplier和Function为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    Supplier&lt;Apple&gt; c1 = Apple::<span class="keyword">new</span>;</div><div class="line">    Apple a1 = c1.get();</div><div class="line">等价于：</div><div class="line">    Supplier&lt;Apple&gt; c1 = () -&gt; <span class="keyword">new</span> Apple();</div><div class="line">    Apple a1 = c1.get();</div><div class="line"></div><div class="line">    Function&lt;Integer, Apple&gt; f1 = Apple::<span class="keyword">new</span>;</div><div class="line">    Apple a2 = f1.apply(<span class="number">110</span>);</div><div class="line">等价于：</div><div class="line">  	Function&lt;Integer, Apple&gt; f1 = (weight) -&gt; <span class="keyword">new</span> Apple(weight);</div><div class="line">    Apple a2 = f1.apply(<span class="number">110</span>);</div></pre></td></tr></table></figure>
<h1 id="四、Lambda实战"><a href="#四、Lambda实战" class="headerlink" title="四、Lambda实战"></a>四、Lambda实战</h1><h2 id="1、匿名类"><a href="#1、匿名类" class="headerlink" title="1、匿名类"></a>1、匿名类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; list = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</div><div class="line"></div><div class="line">list.sort(<span class="keyword">new</span> Comparator&lt;Apple&gt;()&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Apple o1, Apple o2)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> o1.getWeight().compareTo(o2.getWeight());</div><div class="line">  &#125;      </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="2、Lambda表达式"><a href="#2、Lambda表达式" class="headerlink" title="2、Lambda表达式"></a>2、Lambda表达式</h2><p>因为Comparator是函数式接口，所以可以直接传入Lambda表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; list = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</div><div class="line"></div><div class="line">list.sort((Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()));</div></pre></td></tr></table></figure>
<p>前面还介绍了类型推断，所以还可以再简化一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; list = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</div><div class="line">  </div><div class="line">  list.sort((a1, a2) -&gt; a1.getWeight().compareTo(a2.getWeight()));</div></pre></td></tr></table></figure>
<p>在Comparator中有一个静态辅助方法，它接收一个Function来提取Comparable键值，并生成一个Comparator对象。</p>
<p>所以代码可以变成这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; list = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</div><div class="line"></div><div class="line">list.sort(Comparator.comparing((a) -&gt; a.getWeight()));</div></pre></td></tr></table></figure>
<p>注意，这个Lambda表达式是作为一个Function类型的参数。</p>
<h2 id="3、使用方法引用"><a href="#3、使用方法引用" class="headerlink" title="3、使用方法引用"></a>3、使用方法引用</h2><p>方法引用就是替代那些转发参数的Lambda表达式的语法糖。所以代码最后就变成了这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; list = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</div><div class="line"></div><div class="line">list.sort(Comparator.comparing(Apple::getWeight));</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中的反射技术获取方法参数信息]]></title>
      <url>http://yoursite.com/2017/07/06/Java/Java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E6%8A%80%E6%9C%AF%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%BF%A1%E6%81%AF/</url>
      <content type="html"><![CDATA[<p>Java的反射技术并不陌生，它的一个应用就是获取方法的参数信息。</p>
<h1 id="1、传统方法获取参数类型"><a href="#1、传统方法获取参数类型" class="headerlink" title="1、传统方法获取参数类型"></a>1、传统方法获取参数类型</h1><p>比较常用的方法就是通过Method的getParameterTypes()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> hello.reflect;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Parameter;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMethodInfo</span><span class="params">(String className)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      Class clazz = Class.forName(className);</div><div class="line">      Method[] methods = clazz.getMethods();</div><div class="line">      <span class="keyword">for</span> (Method method : methods) &#123;</div><div class="line">        getMethodInfo(method);</div><div class="line">      &#125;      </div><div class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</div><div class="line">      e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">  &#125; </div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMethodInfo</span><span class="params">(Method method)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"method name: "</span> + method.getName());</div><div class="line">    Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</div><div class="line">    <span class="keyword">for</span> (Class&lt;?&gt; clas : parameterTypes) &#123;</div><div class="line">      System.out.println(<span class="string">"arg type: "</span> + clas.getName());</div><div class="line">    &#125;</div><div class="line">    System.out.println(<span class="string">"---------------------------------"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    getMethodInfo(<span class="string">"java.lang.Object"</span>);    </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>来看一下Java中所有类的祖先Object。输出信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">method name: wait</div><div class="line">---------------------------------</div><div class="line">method name: wait</div><div class="line">arg type: long</div><div class="line">arg type: int</div><div class="line">---------------------------------</div><div class="line">method name: wait</div><div class="line">arg type: long</div><div class="line">---------------------------------</div><div class="line">method name: equals</div><div class="line">arg type: java.lang.Object</div><div class="line">---------------------------------</div><div class="line">method name: toString</div><div class="line">---------------------------------</div><div class="line">method name: hashCode</div><div class="line">---------------------------------</div><div class="line">method name: getClass</div><div class="line">---------------------------------</div><div class="line">method name: notify</div><div class="line">---------------------------------</div><div class="line">method name: notifyAll</div><div class="line">---------------------------------</div></pre></td></tr></table></figure>
<p>可以看出，通过getParameterTypes()方法只能获取方法的参数类型，而无法获取参数名。</p>
<h1 id="2、Java8新功能"><a href="#2、Java8新功能" class="headerlink" title="2、Java8新功能"></a>2、Java8新功能</h1><p>在jdk8中一个新特性就是它可以将方法参数的院信息存储到编译玩的class文件中（JEP 118）。利用这个特性就可以用反射技术来获取更多方法的参数信息。</p>
<p>于是将程序改成下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> hello.reflect;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Parameter;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMethodInfo</span><span class="params">(String className)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      Class clazz = Class.forName(className);</div><div class="line">      Method[] methods = clazz.getMethods();</div><div class="line">      <span class="keyword">for</span> (Method method : methods) &#123;</div><div class="line">        getMethodParametersinfo(method);</div><div class="line">      &#125;      </div><div class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</div><div class="line">      e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">  &#125; </div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMethodParametersinfo</span><span class="params">(Method method)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"method name: "</span> + method.getName());</div><div class="line">    Parameter [] paramaters = method.getParameters();</div><div class="line">    <span class="keyword">for</span> (Parameter paramater : paramaters) &#123;</div><div class="line">      System.out.print(<span class="string">"arg name: "</span> + paramater.isNamePresent() + <span class="string">" "</span> + paramater.getName());</div><div class="line">      System.out.println(<span class="string">", arg type: "</span> + paramater.getParameterizedType());</div><div class="line">    &#125;</div><div class="line">    System.out.println(<span class="string">"---------------------------------"</span>);    </div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    getMethodInfo(<span class="string">"java.lang.Object"</span>);    </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">method name: wait</div><div class="line">---------------------------------</div><div class="line">method name: wait</div><div class="line">arg name: false arg0, arg type: long</div><div class="line">arg name: false arg1, arg type: int</div><div class="line">---------------------------------</div><div class="line">method name: wait</div><div class="line">arg name: false arg0, arg type: long</div><div class="line">---------------------------------</div><div class="line">method name: equals</div><div class="line">arg name: false arg0, arg type: class java.lang.Object</div><div class="line">---------------------------------</div><div class="line">method name: toString</div><div class="line">---------------------------------</div><div class="line">method name: hashCode</div><div class="line">---------------------------------</div><div class="line">method name: getClass</div><div class="line">---------------------------------</div><div class="line">method name: notify</div><div class="line">---------------------------------</div><div class="line">method name: notifyAll</div><div class="line">---------------------------------</div></pre></td></tr></table></figure>
<p>可以看出，输出的参数名是从arg0开始一直增加，这显然不是我们想要的结果，比如Object类中的wait方法源码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public final void wait(long timeout, int nanos) throws InterruptedException &#123;</div><div class="line">    //省略</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们想要的是timeout，nanos这两个参数名，显然输出的并不是。</p>
<p>原因就在于输出中的那个false，它是paramater.isNamePresent()方法的返回值，false说明了改class文件中并没有提供方法的参数名。也就是说，想要让class文件中存储方法的参数名称信息，需要在编译的时候显示的声明。</p>
<h1 id="3、javac的parameters选项"><a href="#3、javac的parameters选项" class="headerlink" title="3、javac的parameters选项"></a>3、javac的parameters选项</h1><p>显示声明的方式可以在编译命令的说明中找到，打开命令行，输入 javac -help：</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/java/11.png?raw=true" alt="1"></p>
<p>上面说的明明白白，需要加入parameters参数才可以。</p>
<p>但是显然Object的类是无法重新编译的，于是是自己新建了一个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> hello.reflect;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ClassA</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addArrayOfStrings</span><span class="params">(String[] strings)</span> </span>&#123;&#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInt</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;&#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addString</span><span class="params">(String url, String argName)</span> </span>&#123;&#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"ClassA"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我用javac命令编译试了一下，加上parameters参数之后，class文件明显变大了几十k。</p>
<h1 id="4、eclipse中加入parameters编译参数"><a href="#4、eclipse中加入parameters编译参数" class="headerlink" title="4、eclipse中加入parameters编译参数"></a>4、eclipse中加入parameters编译参数</h1><p>在eclipse中开发的时候编译默认是不带这个参数的，也就是说用上面的方法输出我新建的ClassA，参数名肯定还是arg0这些，需要额外设置一下才可以。</p>
<p>具体方法就是右键工程，选择properties</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/java/12.png?raw=true" alt="2"></p>
<p>把最下面那个选项选上，再重新编译一下，就可以了。</p>
<p>关于重新编译，这个问题也经常遇到，有时候如果少了某个class文件经常会输出找不到或无法加载主类的错误，这时候就需要重新编译了。选择最上面的project-clean，然后再选择要重新编译的工程。之后再次运行，就会重新编译。</p>
<p>这是再运行，将ClassA作为参数就可以得到下面的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">method name: toString</div><div class="line">---------------------------------</div><div class="line">method name: addArrayOfStrings</div><div class="line">arg name: true strings, arg type: class [Ljava.lang.String;</div><div class="line">---------------------------------</div><div class="line">method name: addString</div><div class="line">arg name: true url, arg type: class java.lang.String</div><div class="line">arg name: true argName, arg type: class java.lang.String</div><div class="line">---------------------------------</div><div class="line">method name: addInt</div><div class="line">arg name: true count, arg type: int</div><div class="line">---------------------------------</div><div class="line">method name: wait</div><div class="line">---------------------------------</div><div class="line">method name: wait</div><div class="line">arg name: false arg0, arg type: long</div><div class="line">arg name: false arg1, arg type: int</div><div class="line">---------------------------------</div><div class="line">method name: wait</div><div class="line">arg name: false arg0, arg type: long</div><div class="line">---------------------------------</div><div class="line">method name: equals</div><div class="line">arg name: false arg0, arg type: class java.lang.Object</div><div class="line">---------------------------------</div><div class="line">method name: hashCode</div><div class="line">---------------------------------</div><div class="line">method name: getClass</div><div class="line">---------------------------------</div><div class="line">method name: notify</div><div class="line">---------------------------------</div><div class="line">method name: notifyAll</div><div class="line">---------------------------------</div></pre></td></tr></table></figure>
<p>现在就可以获取方法的参数名称了。</p>
<h1 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h1><p>这个功能看似很无聊，但是在实际开发中应用还是很广的 ，之所以记录下来就是因为最近在使用github上面一个cdp4j的库，下载到本地以后一直运行错误，最后排查原因才知道是这个原因。</p>
<p>这个功能在使用动态代理时用于获取参数信息还是很有用的。</p>
<h1 id="6、参考地址"><a href="#6、参考地址" class="headerlink" title="6、参考地址"></a>6、参考地址</h1><p><a href="http://deepinmind.iteye.com/blog/2046050" target="_blank" rel="external">http://deepinmind.iteye.com/blog/2046050</a></p>
<p><a href="http://www.cnblogs.com/zhangshiwen/p/6022794.html" target="_blank" rel="external">http://www.cnblogs.com/zhangshiwen/p/6022794.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[树莓派安装homekit]]></title>
      <url>http://yoursite.com/2017/05/25/raspi/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85homekit/</url>
      <content type="html"><![CDATA[<p>找完实习做毕设，这学期真是累成狗，趁着闲下来几天鼓捣了一下落灰已久的树莓派。研究了利用树莓派作为家里面智能硬件的网关，利用IOS自带的homekit进行控制。简单记录下过程。</p>
<h1 id="一、前期准备"><a href="#一、前期准备" class="headerlink" title="一、前期准备"></a>一、前期准备</h1><h2 id="1、镜像选择"><a href="#1、镜像选择" class="headerlink" title="1、镜像选择"></a>1、镜像选择</h2><p>这次没有选择官方的镜像，而是另一个镜像2016-09-26-Hassbian-Bluetooth。</p>
<p>下载地址 链接：<a href="http://pan.baidu.com/s/1miJTjuS" target="_blank" rel="external">http://pan.baidu.com/s/1miJTjuS</a> 密码：oxvw</p>
<p>烧写过程都是一样的，上电以后，树莓派会自动安装最新版本的HomeAssitant软件。该软件会在树莓派的8123端口开一个http服务器，在我这里树莓派的IP地址是192.168.1.102，所以在浏览器输出192.168.1.102:8123，最开始的时候会无法访问，等几分钟后会显示出一个网站，说明更新已经完成。</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/raspi/1.jpg?raw=true" alt="1"></p>
<h2 id="2、配置树莓派环境"><a href="#2、配置树莓派环境" class="headerlink" title="2、配置树莓派环境"></a>2、配置树莓派环境</h2><ol>
<li><p>修改密码：系统默认的用户名和密码为：pi和raspberry，输入命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo raspi-config</div></pre></td></tr></table></figure>
</li>
<li><p>修改时间：这一步很重要，如果时间不正确，在下面的git或者npm命令之后会出现很多奇怪的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo date  --s=&quot;2017-04-27 10:34:00&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>更新软件源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo nano /etc/apt/sources.list</div></pre></td></tr></table></figure>
<p>将第一行注释掉，并将下面的代码复制到最后，换成阿里云的源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">deb http://mirrors.aliyun.com/raspbian/raspbian/ jessie main non-free contrib</div><div class="line">deb-src http://mirrors.aliyun.com/raspbian/raspbian/ jessie main non-free contrib</div></pre></td></tr></table></figure>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/raspi/2.png?raw=true" alt="2"></p>
<p>最后在更新软件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div></pre></td></tr></table></figure>
</li>
<li><p>安装基础软件：xrdp，用于远程桌面连接</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install xrdp</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="二、homebridge安装"><a href="#二、homebridge安装" class="headerlink" title="二、homebridge安装"></a>二、homebridge安装</h1><p>接下来就是homebridge的安装了。</p>
<h2 id="1、安装基础组件"><a href="#1、安装基础组件" class="headerlink" title="1、安装基础组件"></a>1、安装基础组件</h2><p>安装“Samba，Screen和Git”这三个系统组件，接下来的安装过程中我们会用到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install -y samba screen git</div></pre></td></tr></table></figure>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/raspi/3.png?raw=true" alt="3"></p>
<h2 id="2、安装nodejs"><a href="#2、安装nodejs" class="headerlink" title="2、安装nodejs"></a>2、安装nodejs</h2><p>如上图所示输入命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -sL https://deb.nodesource.com/setup_4.x | sudo -E bash -</div></pre></td></tr></table></figure>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/raspi/4.png?raw=true" alt="4"></p>
<p>安装nodejs，如上图所示输入命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install -y nodejs</div></pre></td></tr></table></figure>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/raspi/5.png?raw=true" alt="5"></p>
<p>然后再安装依赖包libavahi，如上图所示输入命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get -y install libavahi-compat-libdnssd-dev</div></pre></td></tr></table></figure>
<p>至此就可以使用node npm等命令了。</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/raspi/6.png?raw=true" alt="6"></p>
<h2 id="3、安装homebridge"><a href="#3、安装homebridge" class="headerlink" title="3、安装homebridge"></a>3、安装homebridge</h2><p>输入命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo npm install -g --unsafe-perm homebridge hap-nodejs node-gyp</div></pre></td></tr></table></figure>
<p>与上面不同的是使用npm进行安装，在最开始会有一个光标在那一直转，时间比较长耐心等待就可以了。</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/raspi/7.png?raw=true" alt="7"></p>
<p>如上图所示输入下面四行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cd /usr/lib/node_modules/homebridge/</div><div class="line">sudo npm install --unsafe-perm bignum#这个很快就可以安装完</div><div class="line">cd /usr/lib/node_modules/hap-nodejs/node_modules/mdns</div><div class="line">sudo node-gyp BUILDTYPE=Release rebuild#这个时间会长一点</div><div class="line">cd /#最后返回根目录</div></pre></td></tr></table></figure>
<p>完成之后如下图：</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/raspi/8.png?raw=true" alt="8"></p>
<h2 id="4、安装HomeBridge-HomeAssitant"><a href="#4、安装HomeBridge-HomeAssitant" class="headerlink" title="4、安装HomeBridge-HomeAssitant"></a>4、安装HomeBridge-HomeAssitant</h2><p>输入命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo npm install -g homebridge-homeassistant</div></pre></td></tr></table></figure>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/raspi/9.png?raw=true" alt="9"></p>
<p>现在就可以运行homebridge啦：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">homebridge</div></pre></td></tr></table></figure>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/raspi/10.png?raw=true" alt="10"></p>
<p>如图可以看见黄色字体提示缺少config.json文件，也就是homebridge的配置文件。</p>
<h1 id="三、homebridge插件的安装"><a href="#三、homebridge插件的安装" class="headerlink" title="三、homebridge插件的安装"></a>三、homebridge插件的安装</h1><p>homebridge是一个桥接ios与智能硬件的平台，想要控制智能硬件，还必须要有相应的插件，在github上面有非常多的插件，而且可以通过npm进行安装，他们的明明都是homebridge-XXX。</p>
<p>比如我想加入一个智能硬件用来控制树莓派的GPIO，就可以在npm上面搜索，可以发现有很多相关的插件。我基本尝试了所有的插件，也都遇到了各种问题，最后选定了homebridge-gpio-wpi2这个插件。github地址为<a href="https://github.com/rsg98/homebridge-gpio-wpi2" target="_blank" rel="external">https://github.com/rsg98/homebridge-gpio-wpi2</a></p>
<p>下面以这个插件为例继续下一步的操作。</p>
<h2 id="1、安装依赖包与插件"><a href="#1、安装依赖包与插件" class="headerlink" title="1、安装依赖包与插件"></a>1、安装依赖包与插件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install wiringpi#wiringpi是用于控制树莓派GPIO的库</div><div class="line">sudo npm install -g homebridge-gpio-wpi2</div></pre></td></tr></table></figure>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/raspi/11.png?raw=true" alt="11"></p>
<h2 id="2、修改配置文件"><a href="#2、修改配置文件" class="headerlink" title="2、修改配置文件"></a>2、修改配置文件</h2><p>配置文件最开始是不存在的，需要新建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo nano /home/pi/.homebridge/config.json</div></pre></td></tr></table></figure>
<p>把下面内容复制进去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">        &quot;bridge&quot;: &#123;</div><div class="line">                &quot;name&quot;: &quot;Homebridge&quot;,</div><div class="line">                &quot;username&quot;: &quot;CC:22:3D:E3:CE:30&quot;,</div><div class="line">                &quot;port&quot;: 51826,</div><div class="line">                &quot;pin&quot;: &quot;133-45-678&quot;</div><div class="line">        &#125;,</div><div class="line"></div><div class="line"></div><div class="line">        &quot;platforms&quot;: [&#123;</div><div class="line">                 &quot;platform&quot; : &quot;WiringPiPlatform&quot;,</div><div class="line">                &quot;name&quot; : &quot;Pi GPIO (WiringPi)&quot;,</div><div class="line">                &quot;overrideCache&quot; : &quot;true&quot;,</div><div class="line">                &quot;autoExport&quot; : &quot;true&quot;,</div><div class="line">                &quot;gpiopins&quot; : [&#123;</div><div class="line">                        &quot;name&quot; : &quot;灯&quot;,</div><div class="line">                        &quot;pin&quot;  : 27,</div><div class="line">                        &quot;enabled&quot; : &quot;true&quot;,</div><div class="line">                        &quot;mode&quot; : &quot;out&quot;,</div><div class="line">                        &quot;pull&quot; : &quot;down&quot;,</div><div class="line">                        &quot;inverted&quot; : &quot;false&quot;,</div><div class="line">                        &quot;duration&quot; : 0,</div><div class="line">                        &quot;polling&quot; : &quot;true&quot;</div><div class="line">                        &#125;,&#123;</div><div class="line">                        &quot;name&quot; : &quot;门&quot;,</div><div class="line">                        &quot;pin&quot;  : 22,</div><div class="line">                        &quot;enabled&quot; : &quot;true&quot;,</div><div class="line">                        &quot;mode&quot; : &quot;in&quot;,</div><div class="line">                        &quot;pull&quot; : &quot;off&quot;,</div><div class="line">                        &quot;inverted&quot; : &quot;false&quot;,</div><div class="line">                        &quot;duration&quot; : 0</div><div class="line">                &#125;]</div><div class="line">        &#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再次打开homebridge</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">homebridge</div></pre></td></tr></table></figure>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/raspi/12.png?raw=true" alt="12"></p>
<p>运行成功，保证手机与树莓派在同一网段内，即可在家庭应用中添加设备并且可以控制。</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/raspi/13.jpg?raw=true" alt="13"></p>
<p>此时打开siri，就可以进行语音控制啦。</p>
<h1 id="四、后记"><a href="#四、后记" class="headerlink" title="四、后记"></a>四、后记</h1><ol>
<li>控制io只是实现了最基础的功能，npm上面有很多插件等着我们去探索，不过插件也是良莠不齐会出现各种问题，要学会去github上面看参考文档。</li>
<li>上面用到的插件是我试过的唯一好用的pgio的插件，具体的配置参数github主页上有非常详细的说明。</li>
<li>homebridge的插件开发文档还很少，后期可以尝试着自己开发插件。</li>
</ol>
<h1 id="五、参考地址"><a href="#五、参考地址" class="headerlink" title="五、参考地址"></a>五、参考地址</h1><p><a href="http://bbs.feng.com/forum.php?mod=viewthread&amp;tid=10857822" target="_blank" rel="external">http://bbs.feng.com/forum.php?mod=viewthread&amp;tid=10857822</a></p>
<p><a href="https://github.com/nfarina/homebridge" target="_blank" rel="external">https://github.com/nfarina/homebridge</a></p>
<p><a href="https://github.com/rsg98/homebridge-gpio-wpi2" target="_blank" rel="external">https://github.com/rsg98/homebridge-gpio-wpi2</a></p>
<p><a href="https://www.npmjs.com/" target="_blank" rel="external">https://www.npmjs.com/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中的final关键字与String类]]></title>
      <url>http://yoursite.com/2017/04/20/Java/Java%E4%B8%AD%E7%9A%84final%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8EString%E7%B1%BB/</url>
      <content type="html"><![CDATA[<p>Java中的String类型为什么是final的?</p>
<p>腾讯二面的时候被问到这个问题，回答的不是很好。以前只是知道String类是不可变的，不可被继承的，但是没有深入研究过，immutable和final并不是一回事，为什么一定要声明为final的。</p>
<p>首先我觉得String类是immutable不可变的，而final则是它不可变的具体实现。所以这其实是两个问题</p>
<ol>
<li>为什么String类是不可变的？</li>
<li>为什么final能保证它的不可变性质？</li>
</ol>
<p>下面分别看一下两个问题</p>
<h1 id="一、final关键字"><a href="#一、final关键字" class="headerlink" title="一、final关键字"></a>一、final关键字</h1><p>Java中的final关键字主要用在三个地方：</p>
<ol>
<li>数据</li>
<li>方法</li>
<li>类</li>
</ol>
<h2 id="1、final数据"><a href="#1、final数据" class="headerlink" title="1、final数据"></a>1、final数据</h2><p>之所以叫final数据而不是final变量，因为Java中分为基本数据类型和对象，final在修饰这两个类的时候也是有一些差别的。</p>
<h3 id="1-1、编译期常量"><a href="#1-1、编译期常量" class="headerlink" title="1.1、编译期常量"></a>1.1、编译期常量</h3><p>对于编译期常量编译器可以将该常量的值带入任何可能用到的计算式中，也就是 说可以在编译时执行计算式，这减轻了一些运行时的负担。</p>
<p>在Java中，这类常量必须是基本数据类型，并且以关键字final表示，在对这个常量进行定义的时候就必须进行赋值。</p>
<p>一个即是static又是final的域只占一段不能改变的存储空间，且变量名全部用大写字母明明，字母之间用下划线隔开。</p>
<h3 id="1-2、final对象"><a href="#1-2、final对象" class="headerlink" title="1.2、final对象"></a>1.2、final对象</h3><p>对于基本类型，final使数值恒定不变。而对于对象引用，final使<strong>引用</strong>恒定不变。一旦引用被初始化指向一个对象，就再无法把它改为指向另一个对象，然而对象自身却是可以被修改的。下面会有例子说明。</p>
<h3 id="1-3、空白final"><a href="#1-3、空白final" class="headerlink" title="1.3、空白final"></a>1.3、空白final</h3><p>Java中的“空白final”是指：被声明为final但又未给定初值的域。但是无论上面情况，编译器都确保空白final在使用前必须被初始化。</p>
<p>空白的final关键字提供了很大的灵活性，一个类的final域可以根据对象而有所不同却又保持其恒定不变的特性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlankFinal</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> a;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.a=a;</div><div class="line">        &#125;</div><div class="line">    &#125;	</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i=<span class="number">0</span>;<span class="comment">//直接初始化</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> j;<span class="comment">//未初始化的空白final</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> A a;<span class="comment">//未初始化的空白final</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlankFinal</span><span class="params">()</span></span>&#123;<span class="comment">//空白final必须在构造器中赋值，不然编译器会报错</span></div><div class="line">        j=<span class="number">1</span>; </div><div class="line">        a=<span class="keyword">new</span> A(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlankFinal</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//空白final必须在构造器中赋值，不然编译器会报错</span></div><div class="line">        j=x;</div><div class="line">        a=<span class="keyword">new</span> A(x);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;		</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>必须在域的定义处或者构造器中对final赋值。</p>
<h3 id="1-4、final参数"><a href="#1-4、final参数" class="headerlink" title="1.4、final参数"></a>1.4、final参数</h3><p>Java还允许在参数列表中以声明的方式将参数指明为final，意味着无法在方法中更改参数引用所指向的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> i)</span></span>&#123;<span class="comment">//编译报错</span></div><div class="line">    i++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2、final方法"><a href="#2、final方法" class="headerlink" title="2、final方法"></a>2、final方法</h2><p>使用final方法的原因有两个</p>
<p>第一就是把方法锁定，以防止任何继承类修改它的含义。确保在继承中是方法行为保持不变，并不会被覆盖。</p>
<p>第二就是在早期的Java实现中，如果一个方法指明为final，就是同意编译器将针对该方法的所有调用都转为内嵌调用。</p>
<h3 id="2-1、private与final"><a href="#2-1、private与final" class="headerlink" title="2.1、private与final"></a>2.1、private与final</h3><p>类中所有的private方法都隐式地指定为final。给private方法添加final关键字，不会有任何意义。</p>
<p>如果试图覆盖一个private方法，编译器不会给出错误，但是还是会有问题的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlankFinal</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        OverridingPrivate2 op2=<span class="keyword">new</span> OverridingPrivate2();</div><div class="line">        op2.f();<span class="comment">//OverridingPrivate2.f()</span></div><div class="line">        OverridingPrivate op=(OverridingPrivate)op2;<span class="comment">//向上转型</span></div><div class="line">        op.f();<span class="comment">//The method f() from the type OverridingPrivate is not visible</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithFinals</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"WithFinals.f()"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverridingPrivate</span> <span class="keyword">extends</span> <span class="title">WithFinals</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"OverridingPrivate.f()"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverridingPrivate2</span> <span class="keyword">extends</span> <span class="title">OverridingPrivate</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"OverridingPrivate2.f()"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果一个基类中的方法是private的，那么对子类来说是隐藏不可见的。</p>
<p>即使在子类中定义了一个名称相同的方法，也只是生成了一个名称相同的方法，但是并没有重写该方法。</p>
<h2 id="3-final类"><a href="#3-final类" class="headerlink" title="3.final类"></a>3.final类</h2><p>将一个类定义为final，则说明该类是不可继承的。最常见的肯定就是下面要介绍的String类了。</p>
<h1 id="二、String类与不可变性"><a href="#二、String类与不可变性" class="headerlink" title="二、String类与不可变性"></a>二、String类与不可变性</h1><p>《Effictive Java》中提到，不可变类只是其实例不能被修改的类。每个实例中包含的所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期内固定不变。</p>
<p>Java类库中包含许多不可变的类，其中有：</p>
<ul>
<li>String</li>
<li>基本数据类型的包装类</li>
<li>BigInteger</li>
<li>BigDecimal</li>
</ul>
<p>为了使类成为不可变，要遵循下面五条规则：</p>
<ol>
<li>不要提供任何会修改对象状态的方法</li>
<li>保证类不会被扩展。一般做法是使这个类成为final的</li>
<li>使所有的域都是final的</li>
<li>使所有的域都成为私有的</li>
<li>确保对于任何可变组件的互斥访问</li>
</ol>
<p>不可变类对象的几点好处：</p>
<ul>
<li>简单：不可变对象只有一种状态，即被创建时的状态</li>
<li>不可变对象本质上是线程安全的，不需要同步</li>
<li>不可变对象可以自由共享</li>
<li>不可变对象之间可以共享内部信息。比如BigInteger，数值相同符号不同，可以共享数值</li>
</ul>
<p>下面以String类的代表来具体进行分析</p>
<p>String类声明为final主要是是为了保证其不可变性。</p>
<p>我个人认为：String在Java中的对象，但是它在使用上其实更接近基本数据类型，所以将它设计成不可变的对象类型，最大程度上接近了基本数据类型，仔细想想面向对象的特性继承封装多态，其实在String类中完全没有体现，所以我觉得它虽然实现上是一个类，但设计者还是想把它当做基本数据类型来使用。</p>
<p>在Java中Long, Double, Integer等类也是final的，也说明了这个问题。</p>
<h2 id="1、什么是不可变"><a href="#1、什么是不可变" class="headerlink" title="1、什么是不可变"></a>1、什么是不可变</h2><p>String不可变很简单。给一个字符串“a”赋值“b”或者执行+操作变成“aa”，不会在原来的内存地址上修改数据，而是生成一个新的String对象然后指向这个新对象。</p>
<h2 id="2、如何实现不可变"><a href="#2、如何实现不可变" class="headerlink" title="2、如何实现不可变"></a>2、如何实现不可变</h2><p>先来看一下String类的定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></div><div class="line">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> &#123;</div><div class="line">    <span class="comment">/** The value is used for character storage. */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</div><div class="line"></div><div class="line">    <span class="comment">/** Cache the hash code for the string */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></div></pre></td></tr></table></figure>
<p>String类声明为final，说明是不可被继承的，而String类的实现，底层是一个char数组，也被声明为final，说明该数组是不可变的。</p>
<p>上面提到了final修饰一个对象的时候保证指向的的引用不变，但是对象自身是可以改变的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> a=<span class="number">1</span>;</div><div class="line">a=<span class="number">2</span>;</div></pre></td></tr></table></figure>
<p>这样编译会报错，因为final的变量不可以被再次赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] a=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</div><div class="line">a[<span class="number">0</span>]=<span class="number">0</span>;</div><div class="line">System.out.println(Arrays.toString(a));</div></pre></td></tr></table></figure>
<p>输出为[0, 2, 3, 4]。这说明虽然a指向的数组对象无法改变，但是数组对象内部的结构却可以改变。</p>
<p>再回到String类中。通过上面这个例子可以知道，如果单纯的把String类中的char数组设置为final，那么这个String的值依然是可以改变的，所以设计人员从以下两个方面进行了保护：</p>
<ol>
<li>数组声明为private，保证最高的访问权限，在自己类内部的方法中也保证不改变这个char数组的值</li>
<li>把String类声明为final， 防止继承的子类对它的equals等关键方法进行重写</li>
</ol>
<h2 id="3、不可变的好处"><a href="#3、不可变的好处" class="headerlink" title="3、不可变的好处"></a>3、不可变的好处</h2><p>String类型设计为不可变主要有以下两个方面：</p>
<ul>
<li>安全方面</li>
<li>性能方面</li>
</ul>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>这个方面很好理解，最熟悉的字符串常量池的存在就是为了性能优化，而如果字符串是可变的，那么常量池存在的意义也就不大了。</p>
<p>字符串的分配，和其他的对象分配一样，耗费高昂的时间与空间代价。JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化。为了减少在JVM中创建的字符串的数量，字符串类维护了一个字符串池，每当代码创建字符串常量时，JVM会首先检查字符串常量池。如果字符串已经存在池中，就返回池中的实例引用。如果字符串不在池中，就会实例化一个字符串并放到池中。Java能够进行这样的优化是因为字符串是不可变的，可以不用担心数据冲突进行共享。</p>
<p>转自<a href="http://www.importnew.com/10756.html" target="_blank" rel="external">http://www.importnew.com/10756.html</a></p>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><h3 id="3-1、线程安全性"><a href="#3-1、线程安全性" class="headerlink" title="3.1、线程安全性"></a>3.1、线程安全性</h3><p>如果一个对象可以被多个线程访问到，但是并没有被声明为final，那么你需要提供额外的线程安全机制。而String类直接声明为final，即不可改变。就不必再额外考虑线程安全的问题。</p>
<h3 id="3-2、String作为参数"><a href="#3-2、String作为参数" class="headerlink" title="3.2、String作为参数"></a>3.2、String作为参数</h3><p>String类的变量经常作为参数进行传递，而Java中对象类型的传递的则是引用，下面来看一个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(String s)</span></span>&#123;</div><div class="line">    s+=<span class="string">" in fun"</span>;</div><div class="line">    System.out.println(s);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(StringBuilder s)</span></span>&#123;</div><div class="line">    s.append(<span class="string">" in fun"</span>);</div><div class="line">    System.out.println(s);</div><div class="line">&#125;	</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    String s1=<span class="string">"s1"</span>;</div><div class="line">    StringBuilder s2=<span class="keyword">new</span> StringBuilder(<span class="string">"s2"</span>);</div><div class="line">    fun(s1);</div><div class="line">    fun(s2);</div><div class="line">    System.out.println(s1);</div><div class="line">    System.out.println(s2);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">s1 in fun</div><div class="line">s2 in fun</div><div class="line">s1</div><div class="line">s2 in fun</div></pre></td></tr></table></figure>
<p>可以看出，与可变的StringBuilder相比，String类作为参数传到另一个方法中之后，无论该方法在传入字符串的基础上如何操作，因为String的不可变性，都会在方法中生成一个新的对象，而对传入的对象没有任何影响。</p>
<h3 id="3-2、String作为key"><a href="#3-2、String作为key" class="headerlink" title="3.2、String作为key"></a>3.2、String作为key</h3><p>在Java中很多地方都是以String类型的对象作为参数的，比如Spring中的bean的name，Socket或者数据库连接的名称等等，还有就是HashMap或者HashSet的key，这些以String类型对象为参数的场景中，如果String是可变的，那么带来很多问题。下面用一个StringBuilder作为例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;		</div><div class="line">    Map&lt;StringBuilder, Integer&gt; map=<span class="keyword">new</span> HashMap&lt;StringBuilder, Integer&gt;();</div><div class="line">    StringBuilder s1=<span class="keyword">new</span> StringBuilder(<span class="string">"aab"</span>);</div><div class="line">    StringBuilder s2=<span class="keyword">new</span> StringBuilder(<span class="string">"aa"</span>);</div><div class="line">    map.put(s1, <span class="number">1</span>);</div><div class="line">    map.put(s2, <span class="number">2</span>);</div><div class="line">    s2.append(<span class="string">"b"</span>);</div><div class="line">    System.out.println(map.keySet());<span class="comment">//[aab, aab]</span></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>从输出结果可以看出，会出现两个key值相等的情况。当然，这个例子并不完全恰当，因为StringBuilder其实没有重写equals方法，所以在map中查找的时候比较的是指向的对象而不是想String一样比较字符串是否相同，这个例子主要体现的就是以String作为key的时候，如果是可变的，那么会出现key值相同的情况。</p>
<h1 id="三、参考地址"><a href="#三、参考地址" class="headerlink" title="三、参考地址"></a>三、参考地址</h1><p>《Java编程思想》第四版</p>
<p>《Effictive Java》第二版</p>
<p><a href="https://www.zhihu.com/question/31345592" target="_blank" rel="external">https://www.zhihu.com/question/31345592</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis中的数据结构与对象]]></title>
      <url>http://yoursite.com/2017/04/09/Database/Redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<p>周末本来不想学习，看完人民的名义没事干，翻了翻刚买的Redis设计与实现这本书，就像追剧一样把第一部分看完了，这本书写的真是不错。</p>
<h1 id="一、Redis简介"><a href="#一、Redis简介" class="headerlink" title="一、Redis简介"></a>一、Redis简介</h1><p>Redis作为著名的非关系型数据库，有着如下几个特点</p>
<ol>
<li>以键值对存储</li>
<li>有字符串，列表，哈希，集合和有序集合五中数据类型</li>
<li>对这些类型都可以原子操作</li>
<li>单进程单线程运行</li>
<li>内存中运行，也支持持久化，有RDB和AOF两种方式</li>
</ol>
<p>对于上面说到的五中数据类型，在redis内部有着不同的实现，也就是说在redis中有着自己定义的数据结构。</p>
<h1 id="二、Redis中的数据结构"><a href="#二、Redis中的数据结构" class="headerlink" title="二、Redis中的数据结构"></a>二、Redis中的数据结构</h1><p>redis内部是C语言写的，所以没有仔细阅读源码，但是对于其中比较基础的数据结构还是可以看懂的，redis中的数据结构主要有以下几种：</p>
<ol>
<li>简单动态字符串</li>
<li>链表</li>
<li>字典</li>
<li>跳跃表</li>
<li>整数集合</li>
<li>压缩列表</li>
</ol>
<h2 id="1、简单动态字符串SDS"><a href="#1、简单动态字符串SDS" class="headerlink" title="1、简单动态字符串SDS"></a>1、简单动态字符串SDS</h2><p>字符串应该是redis中最常用的数据结构了，在C语言中，字符串是<strong>以空字符结尾的字符数组</strong>。在redis中，没有直接采用C中的字符串，而是自己构建了一种名为简单动态字符串的抽象类型，作为字符串的默认字符表示。</p>
<h3 id="1-1、SDS的实现"><a href="#1-1、SDS的实现" class="headerlink" title="1.1、SDS的实现"></a>1.1、SDS的实现</h3><p>SDS全称是Simple Dynamic String，即简单动态字符串，因为redis是C语言写的，所以在里面的数据结构都是通过struct来定义的，因为没怎么用过C语言，所以就不贴代码了，简单的以Java类的角度，分析一下它的内部属性。</p>
<p>SDS中只有两个int属性和一个char[]数组：</p>
<ol>
<li>len：记录buf数组中已经使用字节的数量，等于SDS所保存字符串的长度</li>
<li>free：记录buf数组中未使用字节的数量</li>
<li>buf数组：字节数组，用于保存字符串</li>
</ol>
<h3 id="1-2、SDS与C字符串的区别"><a href="#1-2、SDS与C字符串的区别" class="headerlink" title="1.2、SDS与C字符串的区别"></a>1.2、SDS与C字符串的区别</h3><p>redis自己定义了SDS而没有直接使用C中的字符串主要是出于以下几点的考虑：</p>
<ol>
<li><p>获取字符串长度操作：</p>
<p>通过len属性来记录长度，可以在O(1)时间获取长度，而原始的时间复杂度为O(n)</p>
</li>
<li><p>杜绝缓冲区溢出</p>
<p>因为字符串不记录长度，所以拼接操作的时候可能会造成缓冲区溢出。</p>
<p>而SDS修改前会先检查，如果空间不够则先扩展空间在操作</p>
</li>
<li><p>减少修改字符串带来的内存重分配次数</p>
</li>
<li><p>二进制安全</p>
<p>C中字符串必须符合某种编码，并且除了结尾，中间不能有空字符，导致不能保存图像音频压缩文件等二进制数据。</p>
<p>而SDS则可以保存任意的二进制文件</p>
</li>
<li><p>兼容部分C字符串函数</p>
</li>
</ol>
<h2 id="2、链表"><a href="#2、链表" class="headerlink" title="2、链表"></a>2、链表</h2><p>redis中的链表就是一种双端链表，类似于Java中的LinkedList，它是<strong>列表建</strong>的底层实现之一。</p>
<h3 id="2-1、链表的实现"><a href="#2-1、链表的实现" class="headerlink" title="2.1、链表的实现"></a>2.1、链表的实现</h3><p>首先就是链表结点，listNode(在Java中类名都是直接大写的，C中竟然第一个小写)，三个属性:</p>
<ol>
<li>prev：指向前置结点</li>
<li>next：指向后置结点</li>
<li>value：结点的值，在C中是void的，说明可以保存不同类型的值</li>
</ol>
<p>然后就是链表list，由多个listNode组成，有一下介个属性和方法：</p>
<ol>
<li>head：链表的头结点</li>
<li>tail：链表的尾结点</li>
<li>len：链表中结点的数量</li>
<li>还有几个函数：复制结点，释放结点和对比结点值</li>
</ol>
<p>感觉和Java中的LinkedList基本一致。</p>
<h2 id="3、字典"><a href="#3、字典" class="headerlink" title="3、字典"></a>3、字典</h2><p>字典是<strong>哈希键</strong>的底层实现之一，并且它在redis中使用很广泛，因为作为键值对存储的数据库，redis的数据库就是以字典来作为底层实现的。</p>
<h3 id="3-1、字典的实现"><a href="#3-1、字典的实现" class="headerlink" title="3.1、字典的实现"></a>3.1、字典的实现</h3><p>redis中字典的实现也是采用拉链法，table数组中存储结点，结点通过next指针指向下一个，和Java中的基本一样，当然也有几点区别，主要介绍下几个有区别的地方：</p>
<ol>
<li>字典结构dict有两个哈希表，ht[0]和ht[1]，前者是正常使用，后者用于rehash也就是扩容的时候使用</li>
<li>有一个属性rehashindx，下面再rehash的地方详细介绍</li>
</ol>
<h3 id="3-2、哈希算法"><a href="#3-2、哈希算法" class="headerlink" title="3.2、哈希算法"></a>3.2、哈希算法</h3><p>redis中的hash算法采用的是MurmurHash2算法。</p>
<h3 id="3-3、rehash"><a href="#3-3、rehash" class="headerlink" title="3.3、rehash"></a>3.3、rehash</h3><p>rehash就是分为扩展和收缩两个操作，使负载因子维持在一个合理的范围之内。具体的步骤如下：</p>
<ol>
<li>为字典的ht[1]分配空间，空间大小取决于是要扩展还是要收缩，大小保证是2的幂</li>
<li>将ht[0]中的所有键值对rehash到ht[1]中</li>
<li>当ht[0]中所有键值对都迁移到ht[1]中之后，释放ht[0]的空间，将ht[1]设置为ht[0]，并在ht[1]创建一个空白的哈希表为下次rehash做准备</li>
</ol>
<h3 id="3-4、渐进式rehash"><a href="#3-4、渐进式rehash" class="headerlink" title="3.4、渐进式rehash"></a>3.4、渐进式rehash</h3><p>上面提到的第二个步骤，将ht[0]中的所有键值对rehash到ht[1]中，并不是一次性完成的，而是多次，渐进式完成，类似于Java中的ConcurrentHashMap。虽然不涉及到线程安全，但是由于哈希表里面的数据量可能非常大，一次性复制所有的键值对可能会很长的时间，进而造成服务器在一段时间内停止服务。</p>
<p>渐进式rehash的步骤如下：</p>
<ol>
<li>上面提到字典中有一个变量rehashindx<ul>
<li>如果它的值为-1，说明rehash不在进行。</li>
<li>当它的值为0时，rehash正式开始</li>
</ul>
</li>
<li>在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作，还会顺带将ht[0]哈希表rehashindx索引上的所有键值对rehash到rehash到ht[1]中，完成后再将rehashindx加一</li>
<li>当ht[0]中所有键值对都迁移到ht[1]中之后，程序将rehashindx设置为-1，表示rehash已经完成</li>
</ol>
<p>采用分而治之的方式，将rehash的工作均摊到每个操作之上，避免了一次性rehash庞大的工作量，有点类似于ConcurrentHashMap中多个线程完成rehash的思想，但是它们之间还是不一样的，因为ConcurrentHashMap是由多个线程共同完成rehash。</p>
<p>还有一点需要注意的就是，<strong>在rehash进行过程之中，字典会同时使用ht[0]和ht[1]两个哈希表。</strong></p>
<h2 id="4、跳跃表"><a href="#4、跳跃表" class="headerlink" title="4、跳跃表"></a>4、跳跃表</h2><p>跳跃表是<strong>有序集合键</strong>的底层实现之一。它支持平均O(longN)，最坏O(N)复杂度的结点查找。</p>
<h3 id="4-1、SkipList简介"><a href="#4-1、SkipList简介" class="headerlink" title="4.1、SkipList简介"></a>4.1、SkipList简介</h3><p>目前经常使用的平衡数据结构有：B树，红黑树，AVL树，Splay Tree, Treep，这些数据结构都可以实现logn的查找插入性能，但是它们的实现一般都比较复杂，一提到画红黑树我就想到当年的算法课。</p>
<p>而跳表是平衡树的一种替代的数据结构，但是和红黑树不相同的是，跳表对于树的平衡的实现是基于一种<strong>随机化</strong>的算法的，这样也就是说跳表的插入和删除的工作是比较简单的。目前开源软件 Redis 和 LevelDB 都有用到它。</p>
<h4 id="跳表的性质"><a href="#跳表的性质" class="headerlink" title="跳表的性质"></a>跳表的性质</h4><p>跳表具有如下性质：</p>
<ol>
<li>由很多层结构组成</li>
<li>每一层都是一个有序的链表</li>
<li>最底层(Level 1)的链表包含所有元素</li>
<li>如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现。</li>
<li>每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。</li>
</ol>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/Database/13.png?raw=true" alt=""></p>
<h4 id="Java中的SkipList"><a href="#Java中的SkipList" class="headerlink" title="Java中的SkipList"></a>Java中的SkipList</h4><p>Java中没有定义SkipList，但是在Concurrent包中的ConcurrentSkipListMap和ConcurrentSkipListSet，它们底层都是使用的基于CAS来构建的SkipList。</p>
<p>对于他们的使用：</p>
<ol>
<li>ConcurrentSkipListSet，用于存储有序元素<ul>
<li>如果是单线程，则直接使用TreeMap即可，它是采用红黑树实现的</li>
<li>如果多线程并且并发量不大，可以采用Collections.synchronizedSortedMap()来包装TreeMap</li>
<li>如果并发量很大，则直接使用ConcurrentSkipListSet毕竟他是专门为这个设计的。</li>
</ul>
</li>
<li><p>ConcurrentSkipListMap，存储元素不一定有序</p>
<ul>
<li>如果数据量一定，可以用ConcurrentSkipListMap</li>
<li>如果数量很大，那么应该采用ConcurrentHashMap</li>
<li>毕竟ConcurrentSkipListMap是基于排序的，而ConcurrentHashMap是基于hash的专门用于索引的。从redis中有序集合的底层实现中也可以发现，使用一个字典和一个跳表结合起来，使得查找和范围操作都尽可能的快。</li>
</ul>
<p>​</p>
</li>
</ol>
<h3 id="4-2、redis中的跳跃表实现"><a href="#4-2、redis中的跳跃表实现" class="headerlink" title="4.2、redis中的跳跃表实现"></a>4.2、redis中的跳跃表实现</h3><p>redis中跳跃表也是基于上面的思想：</p>
<ol>
<li><p>由zskiplist和zsliplistNode组成。</p>
<p>zskiplist用于保存跳跃表的头结点、为节点和长度信息</p>
<p>zsliplistNode则用于表示跳跃表的结点，包括层、前进指针、后退指针、跨度、分值和成员对象。</p>
</li>
<li><p>redis中跳跃表的长度固定在1到32之间。</p>
</li>
<li><p>多个结点可以包含相同的分值，但是每个结点的成员对象必须是唯一的</p>
</li>
<li><p>跳跃表按照分之的大小进行排序，如果分值相同，就按照成员对象的大小进行排序</p>
</li>
</ol>
<h2 id="5、整数集合"><a href="#5、整数集合" class="headerlink" title="5、整数集合"></a>5、整数集合</h2><p>整数集合是<strong>集合键</strong>的底层实现之一，当一个集合值包含整数值元素，并且这个集合的元素数量不多时，redis就会使用整数集合作为集合键的底层实现。</p>
<p>整数集合(intset)是redis中用于保存整数值的集合抽象数据结构，它可以保存类型为int16_t，int32_t或者int_64t的整数值，并且保证集合中不会出现重复元素。</p>
<h3 id="5-1、整数集合的实现"><a href="#5-1、整数集合的实现" class="headerlink" title="5.1、整数集合的实现"></a>5.1、整数集合的实现</h3><p>intset结构中共有三个成员：</p>
<ol>
<li>encoding：编码方式，决定了保存元素的数组中元素的类型</li>
<li>length：集合包含元素的数量</li>
<li>contents[]数组：保存元素的数组，元素类型由encoding决定，各个元素按从小到大<strong>有序</strong>排列，并且不包含重复元素。</li>
</ol>
<h3 id="5-3、升级与降级"><a href="#5-3、升级与降级" class="headerlink" title="5.3、升级与降级"></a>5.3、升级与降级</h3><p>升级就是当向集合中添加一个新的元素，而这个元素所占的空间比现在所有的元素类型都要长，这个时候就要进行升级操作。比如开始数组是16位的，突然加入一个32位的元素后，整个数组都要变成32位的。</p>
<p>这样有两个好处：</p>
<ol>
<li>提升灵活性：保证数组所有元素的类型都相同</li>
<li>节省内存：如果数组中元素都比较小，那么就用16位的存储，而不是直接用64位，节省内存。</li>
</ol>
<p>关于降级，一旦升级以后，就无法降级。</p>
<h2 id="6、压缩列表"><a href="#6、压缩列表" class="headerlink" title="6、压缩列表"></a>6、压缩列表</h2><p>压缩列表是<strong>列表键</strong>和<strong>哈希键</strong>的底层实现之一。当列表建值包含少量列表项，并且每个列表项要么就是小整数，要么就是长度比较短的字符串，你们redis就会使用压缩列表来做列表建的底层实现。</p>
<p>所以压缩列表是redis为了节约内存而开发出来的，它由一系列特殊编码的连续内存块组成的顺序性数据结构。一个压缩列表可以包含任意多个结点，每个结点可以保存一个字节数组或者一个整数值。</p>
<h1 id="三、Redis中的对象"><a href="#三、Redis中的对象" class="headerlink" title="三、Redis中的对象"></a>三、Redis中的对象</h1><p>在前面介绍了redis内部定义的几种数据结构，但它们并没有直接的构成键值对数据库，redis是基于这些数据结构创建了一个对象系统，也就是用户用到的五中数据结构：</p>
<ol>
<li>字符串对象</li>
<li>列表对象</li>
<li>哈希对象</li>
<li>集合对象</li>
<li>有序集合对象</li>
</ol>
<p>每种对象都用到了至少一种前面介绍的数据结构。</p>
<p>redis使用对象来表示数据库中的键值对，每次当我们创建一个新的键值对时，至少会创建两个对象，键对象和值对象。</p>
<h2 id="1、对象的实现"><a href="#1、对象的实现" class="headerlink" title="1、对象的实现"></a>1、对象的实现</h2><p>对象在redis中是用redisObject这种数据结构来表示的，它有很多属性，和保存数据相关的有三个属性：</p>
<ol>
<li><p>type：类型</p>
<p>表示对象的类型，键对象都是字符串对象，而值对象可以是上面列出的那五种</p>
<p>上面介绍每个数据结构时都提到是字符串键或者哈希键的底层实现，这里的字符串键，指的就是<strong>这个数据库键所对应的值为字符串对象</strong>。 </p>
<p>| 类型常量         | 对象的名称  |<br>| ———— | —— |<br>| REDIS_STRING | 字符串对象  |<br>| REDIS_LIST   | 列表对象   |<br>| REDIS_HASH   | 哈希对象   |<br>| REDIS_SET    | 集合对象   |<br>| REDIS_ZSET   | 有序集合对象 |</p>
</li>
<li><p>encoding：编码</p>
<p>它表示对象的编码，即这个对象使用了什么数据结构作为底层的实现</p>
<p>| 编码常量                      | 编码所对应的底层数据结构     |<br>| ————————- | —————- |<br>| REDIS_ENCODING_INT        | long类型的整数        |<br>| REDIS_ENCODING_EMBSTR     | embstr编码的简单动态字符串 |<br>| REDIS_ENCODING_RAW        | 简单动态字符串          |<br>| REDIS_ENCODING_HT         | 字典               |<br>| REDIS_ENCODING_LINKEDLIST | 双端链表             |<br>| REDIS_ENCODING_ZIPLIST    | 压缩列表             |<br>| REDIS_ENCODING_INTSET     | 整数集合             |<br>| REDIS_ENCODING_SKIPLIST   | 跳跃表和字典           |</p>
</li>
<li><p>ptr指针：指向底层实现数据结构的指针</p>
<p>每种类型的对象都至少使用了两种不同的编码</p>
<p>| 类型           | 编码                        | 对象   |<br>| ———— | ————————- | —- |<br>| REDIS_STRING | REDIS_ENCODING_INT        |      |<br>| REDIS_STRING | REDIS_ENCODING_EMBSTR     |      |<br>| REDIS_STRING | REDIS_ENCODING_RAW        |      |<br>| REDIS_LIST   | REDIS_ENCODING_ZIPLIST    |      |<br>| REDIS_LIST   | REDIS_ENCODING_LINKEDLIST |      |<br>| REDIS_HASH   | REDIS_ENCODING_ZIPLIST    |      |<br>| REDIS_HASH   | REDIS_ENCODING_HT         |      |<br>| REDIS_SET    | REDIS_ENCODING_INTSE      |      |<br>| REDIS_SET    | REDIS_ENCODING_HT         |      |<br>| REDIS_ZSET   | REDIS_ENCODING_ZIPLIST    |      |<br>| REDIS_ZSET   | REDIS_ENCODING_SKIPLIST   |      |</p>
</li>
</ol>
<p>通过编码的方式，使得每种类型对象都可以灵活选择多种底层实现，根据不同场景使用不同编码，从而优化某一场景下的效率。</p>
<p>下面具体分析一下各种类型对象的编码方式和不同的选择条件。</p>
<h2 id="2、字符串对象"><a href="#2、字符串对象" class="headerlink" title="2、字符串对象"></a>2、字符串对象</h2><p>字符串对象的编码有三种：</p>
<ul>
<li><p>int</p>
<p>如果这个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象就会将整数值保存在ptr属性，并将编码设置为int</p>
</li>
<li><p>raw</p>
<p>如果保存的是一个字符串值，并且字符串的长度大于39，那么就使用一个SDS来保存，并将编码设置为raw</p>
</li>
<li><p>mbstr</p>
<p>如果保存的是一个字符串值，并且这个字符串的长度小于等于39，那么使用embstr编码来保存这个字符串</p>
<p>embstr是专门用于保存短字符串的一种优化编码方式</p>
<ul>
<li>与SDS相比，它只需要分配一次内存，而SDS需要两次，释放次数也是一样。</li>
<li>embstr编码的字符串是只读的，无法修改，执行修改命令时，会先变成raw编码的字符串</li>
</ul>
</li>
</ul>
<p>还有一点，字符串对象是五种类型中唯一一种会被其他四种对象嵌套的对象。</p>
<h2 id="3、列表对象"><a href="#3、列表对象" class="headerlink" title="3、列表对象"></a>3、列表对象</h2><p>列表对象的编码有两种：</p>
<ul>
<li>ziplist：压缩列表</li>
<li>linkedlist：双端链表</li>
</ul>
<p>转换条件：</p>
<ul>
<li>列表对象存放的所有字符串元素的长度都小于64字节</li>
<li>列表元素保存的元素数量小于512</li>
</ul>
<p>同时满足这两个条件时，会使用压缩列表，不然使用双端链表。</p>
<h2 id="4、哈希对象"><a href="#4、哈希对象" class="headerlink" title="4、哈希对象"></a>4、哈希对象</h2><p>哈希对象编码也有两种：</p>
<ul>
<li><p>ziplist：压缩列表</p>
<p>因为列表并不是键值对类型的数据结构，所以它将每个键和值元素相邻来存储键值对</p>
</li>
<li><p>hashtable：字典</p>
<p>字典中的键和值都是字符串对象</p>
</li>
</ul>
<p>转换条件：</p>
<ul>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于64字节</li>
<li>哈希对象保存的键值对的数量小于512个</li>
</ul>
<p>同时满足这两个条件时，会使用压缩列表，不然使用字典。</p>
<h2 id="5、集合对象"><a href="#5、集合对象" class="headerlink" title="5、集合对象"></a>5、集合对象</h2><p>集合对象的编码还是两种：</p>
<ul>
<li><p>intset：整数集合</p>
</li>
<li><p>hashtable：字典</p>
<p>键是一个字符串对象，值为NULL</p>
</li>
</ul>
<p>转换条件：</p>
<ul>
<li>集合对象保存的所有元素都是整数值</li>
<li>集合对象保存的元素数量不超过512个</li>
</ul>
<p>同时满足这两个条件时，会使用整数集合，不然使用字典。</p>
<h2 id="6、有序集合对象"><a href="#6、有序集合对象" class="headerlink" title="6、有序集合对象"></a>6、有序集合对象</h2><p>有序集合的编码方式也是两种：</p>
<ul>
<li><p>ziplist：压缩列表</p>
<p>和保存哈希对象差不多，第一个结点保存元素成员，第二个元素保存元素的分值</p>
</li>
<li><p>skiplist：跳跃表</p>
<p>这里需要注意的是skiplist编码的有序集合使用zset结构作为底层实现，它包括一个<strong>字典</strong>和一个<strong>跳跃表</strong>。</p>
<p>理论上，使用字典和跳表之一就可以实现有序集合，但是</p>
<ul>
<li>如果单独用字典：查找可以O(1)，但字典无序，执行范围操作时就需要排序，最少也要O(NlogN)</li>
<li>如果单独用跳表：集合有序，但是查找操作可能会从O(1)上升到O(N)</li>
<li>所以，将二者结合使用，让有序集合的照抄和防伪操作都尽可能快速的执行。</li>
</ul>
</li>
</ul>
<p>转换条件：</p>
<ul>
<li>有序集合保存的元素数量小于128</li>
<li>有序集合保存的所有元素成员的长度都小于64字节。</li>
</ul>
<p>同时满足这两个条件时，会使用压缩列表，不然使用skiplist。</p>
<p>总结：</p>
<p>五种对象类型中</p>
<ul>
<li>字符串对象是最常用的，有三种编码方式</li>
<li>其他的四种对象，每种都对应两种编码方式，基本思路就是如果保存的元素范围小并且数量少，就用一种节省空间的编码方式来替代<ul>
<li>压缩列表可以用来替代列表对象，哈希对象和有序集合对象</li>
<li>证书集合对象可以用来替代集合对象</li>
</ul>
</li>
<li>替代的条件是可以配置的</li>
</ul>
<h2 id="7、redis的其他特性"><a href="#7、redis的其他特性" class="headerlink" title="7、redis的其他特性"></a>7、redis的其他特性</h2><h3 id="7-1、内存回收"><a href="#7-1、内存回收" class="headerlink" title="7.1、内存回收"></a>7.1、内存回收</h3><p>C语言并没有自动回收内存的功能，所以redis在自己的对象系统中构建了一个<strong>引用计数</strong>计数实现的内存回收机制。</p>
<h3 id="7-2、对象共享"><a href="#7-2、对象共享" class="headerlink" title="7.2、对象共享"></a>7.2、对象共享</h3><p>引用计数还可以实现对象共享的作用，比如当新建的键的值对象已经存在于内存中，就不必再新建一个相同的值对象，而是直接把新的键指向已经存在的值对象，并将这个对象的引用计数加一。</p>
<p>redis在初始化服务器时，会创建0-9999一万个字符串对象的整数值，如果需要用到这些字符串独享，服务器就会直接使用这些共享对象，而不是创建对象。</p>
<p>对象共享也是有限制的，redis<strong>只对包含整数值的字符串对象</strong>进行共享。 </p>
<h3 id="7-3、redisObject中的属性"><a href="#7-3、redisObject中的属性" class="headerlink" title="7.3、redisObject中的属性"></a>7.3、redisObject中的属性</h3><p>redisObject结构中除了前面介绍的三个属性，还有一些其他的属性，比如lru属性。</p>
<p>这个属性作用就是记录对象最后一次被命令程序访问的时间。</p>
<p>给定键的空转时长=当前时间-值对象的lru时间</p>
<p>另一个作用就是服务器打开了maxmemory选项并且内存回收算法为LRU，空转时长较高的那部分键会优先被服务器释放。</p>
<h1 id="四、参考地址"><a href="#四、参考地址" class="headerlink" title="四、参考地址"></a>四、参考地址</h1><p>《Redis设计与实现》黄建宏著</p>
<p><a href="http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html" target="_blank" rel="external">http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_72995dcc01017w1t.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_72995dcc01017w1t.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中的内存泄漏]]></title>
      <url>http://yoursite.com/2017/04/08/Java/Java%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="一、什么是内存泄漏"><a href="#一、什么是内存泄漏" class="headerlink" title="一、什么是内存泄漏"></a>一、什么是内存泄漏</h1><h2 id="1、内存泄漏的定义"><a href="#1、内存泄漏的定义" class="headerlink" title="1、内存泄漏的定义"></a>1、内存泄漏的定义</h2><p>内存泄露(memory leak)，是指程序在申请内存后，无法释放已申请的内存空间。</p>
<p>在Java中就是指：对象已经没有被应用程序使用，但是垃圾回收器没办法移除它们，因为还在被引用着。</p>
<p>最开始以为Java中有垃圾回收机制，所以不会发生内存泄漏，但是通过上面的定义就可以发现</p>
<p>一块内存，如果不再使用后没有被释放，那么就会造成内存泄漏</p>
<p>Java中通过垃圾回收来释放不再使用的内存，而垃圾回收是通过是否有引用指向来判断内存是否不再被使用的。</p>
<p>所以，Java中的内存泄漏，主要造成原因就是程序员以为Java会自动释放所有不再使用的内存，但是Java并不能完全正确地判断内存是否还被继续使用，因此，Java中的内存泄漏，重点关注的就是<strong>已经不再使用，但是依然被引用着的对象</strong>所占的内存。</p>
<h2 id="2、内存泄漏与内存溢出"><a href="#2、内存泄漏与内存溢出" class="headerlink" title="2、内存泄漏与内存溢出"></a>2、内存泄漏与内存溢出</h2><ul>
<li>内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；</li>
<li>内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。</li>
</ul>
<p><strong>memory leak会最终会导致out of memory！</strong></p>
<h1 id="二、内存泄漏的原因"><a href="#二、内存泄漏的原因" class="headerlink" title="二、内存泄漏的原因"></a>二、内存泄漏的原因</h1><h2 id="1、使用容器时造成内存泄漏"><a href="#1、使用容器时造成内存泄漏" class="headerlink" title="1、使用容器时造成内存泄漏"></a>1、使用容器时造成内存泄漏</h2><p>有人提到Java内存泄露的根本原因就是长生命周期的对象持有短生命周期对象的引用。尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是Java中内存泄露的发生场景。</p>
<p>而这一场景，最常见的就是HashMap，ArrayList等集合的使用了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Static Vector v = <span class="keyword">new</span> Vector(<span class="number">10</span>); </div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;<span class="number">100</span>; i++) </div><div class="line">&#123; </div><div class="line">Object o = <span class="keyword">new</span> Object(); </div><div class="line">v.add(o); </div><div class="line">o = <span class="keyword">null</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是网上最常见的一个例子，当定义了一个Object之后，o指向它，正常来说如果o指向null了，你们这个对象就不再被引用了直接被回收。但问题是这个对象被加入到一个容器之中了，这样就不仅仅是o指向它，容器也有指针指向它，所以回收器不会回收这个对象，而这个容器是static的，生命周期基本与jvm的相同，也就是说它持有的所有对象都不会被回收，所以如果想回收这个对象，一定要调用容器的remove方法。或者在容器不用之后直接向容器赋值未null</p>
<h2 id="2、HashSet的hashcode方法引起的内存泄漏问题"><a href="#2、HashSet的hashcode方法引起的内存泄漏问题" class="headerlink" title="2、HashSet的hashcode方法引起的内存泄漏问题"></a>2、HashSet的hashcode方法引起的内存泄漏问题</h2><p>第一种是容器中没有remove造成的泄漏，但是有些时候即使调用了remove方法，也有可能造成内存泄漏，下面也是一个很经典的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Set&lt;Person&gt; set = <span class="keyword">new</span> HashSet&lt;Person&gt;();  </div><div class="line">      Person p1 = <span class="keyword">new</span> Person(<span class="string">"唐僧"</span>,<span class="string">"pwd1"</span>,<span class="number">25</span>);  </div><div class="line">      Person p2 = <span class="keyword">new</span> Person(<span class="string">"孙悟空"</span>,<span class="string">"pwd2"</span>,<span class="number">26</span>);  </div><div class="line">      Person p3 = <span class="keyword">new</span> Person(<span class="string">"猪八戒"</span>,<span class="string">"pwd3"</span>,<span class="number">27</span>);  </div><div class="line">      set.add(p1);  </div><div class="line">      set.add(p2);  </div><div class="line">      set.add(p3);  </div><div class="line">      System.out.println(<span class="string">"总共有:"</span>+set.size()+<span class="string">" 个元素!"</span>);  <span class="comment">//结果：总共有:3 个元素!  </span></div><div class="line">      p3.setAge(<span class="number">2</span>);    <span class="comment">//修改p3的年龄,此时p3元素对应的hashcode值发生改变  </span></div><div class="line">      set.remove(p3);  <span class="comment">//此时remove不掉，造成内存泄漏  </span></div><div class="line">      set.add(p3);     <span class="comment">//重新添加，居然添加成功  </span></div><div class="line">      System.out.println(<span class="string">"总共有:"</span>+set.size()+<span class="string">" 个元素!"</span>);  <span class="comment">//结果：总共有:4 个元素!  </span></div><div class="line">      <span class="keyword">for</span> (Person person : set) &#123;  </div><div class="line">          System.out.println(person);  </div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<p>HashSet中，在对应元素添加进set集合后，不要再去修改元素的值，否则对应元素的hashcode值发生变化，此时如果调用<br>集合的remove(), contains()方法，将不会得到正确的结果。remove()方法并不能正确remove掉对应的元素，造成内存泄漏。</p>
<h2 id="3、JDK1-6中的substring方法造成内存泄漏"><a href="#3、JDK1-6中的substring方法造成内存泄漏" class="headerlink" title="3、JDK1.6中的substring方法造成内存泄漏"></a>3、JDK1.6中的substring方法造成内存泄漏</h2><p>虽然没有遇到过，但是据说在早期的String.substring()方法会很容易引起内存泄漏。</p>
<p>原因在于：String内部是char数组，假如有一个很长的大字符串，调用它的substring生成一个小字符串，新的小字符串并不会新建一个char数组，而是直接指向原来的大字符串中的char数组，这样虽然提高了效率并且节省了空间，但是原来的大字符串对象且一直存在，无法被回收。</p>
<p>在JDK1.7之后，修复了这个问题，每次调用substring都会新建一个char数组。</p>
<h2 id="4、各种连接造成的内存泄漏"><a href="#4、各种连接造成的内存泄漏" class="headerlink" title="4、各种连接造成的内存泄漏"></a>4、各种连接造成的内存泄漏</h2><p>也可以说是提供了close()方法的对象，只要有</p>
<ul>
<li>比如数据库连接(dataSourse.getConnection())</li>
<li>网络连接(socket)</li>
<li>IO连接</li>
</ul>
<p>除非其显式的调用了这些对象的close()方法将其连接关闭，否则是不会自动被GC 回收的。</p>
<p>因为在close()方法调用之前，可能会抛出异常而导致close方法没有被调用，所以通常使用try来执行相关逻辑，将close()方法放在finally之中以确保被执行。</p>
<h2 id="5、监听器"><a href="#5、监听器" class="headerlink" title="5、监听器"></a>5、监听器</h2><p>在java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会</p>
<h2 id="6、单例模式"><a href="#6、单例模式" class="headerlink" title="6、单例模式"></a>6、单例模式</h2><p>不正确使用单例模式是引起内存泄露的一个常见问题，单例对象在被初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部对象的引用，那么这个外部对象将不能被jvm正常回收，导致内存泄露</p>
<h1 id="三、内存泄漏的预防"><a href="#三、内存泄漏的预防" class="headerlink" title="三、内存泄漏的预防"></a>三、内存泄漏的预防</h1><ol>
<li>使用List、Map等集合时，在使用完成后赋值为null</li>
<li>一个对象加入set集合后，不要再去修改可能改变其hashcode方法返回值的属性</li>
<li>目前已知的JDK1.6的substring()方法会导致内存泄露</li>
<li>及时的关闭打开的文件，socket句柄等</li>
<li>多关注事件监听(listeners)和回调(callbacks)，比如注册了一个listener，当它不再被使用的时候，忘了注销该listener，可能就会产生内存泄露</li>
<li>使用大对象时，在用完后赋值为null</li>
</ol>
<h1 id="四、参考地址"><a href="#四、参考地址" class="headerlink" title="四、参考地址"></a>四、参考地址</h1><p><a href="http://www.2cto.com/kf/201605/506042.html" target="_blank" rel="external">http://www.2cto.com/kf/201605/506042.html</a></p>
<p><a href="http://blog.csdn.net/chenleixing/article/details/43646255" target="_blank" rel="external">http://blog.csdn.net/chenleixing/article/details/43646255</a></p>
<p><a href="http://blog.csdn.net/seelye/article/details/8269705" target="_blank" rel="external">http://blog.csdn.net/seelye/article/details/8269705</a></p>
<p><a href="http://blog.csdn.net/xidiancyp/article/details/51418158" target="_blank" rel="external">http://blog.csdn.net/xidiancyp/article/details/51418158</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux中的chmod命令与文件权限]]></title>
      <url>http://yoursite.com/2017/04/01/OperatingSystem/linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84chmod%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/</url>
      <content type="html"><![CDATA[<p>在面试题中经常遇见chmod 777 a.txt 之类的命令。</p>
<h1 id="一、chmod命令"><a href="#一、chmod命令" class="headerlink" title="一、chmod命令"></a>一、chmod命令</h1><p>指令名称 : chmod<br>使用权限 : 所有使用者<br>使用方式 : chmod [-cfvR][–help][–version] mode file… </p>
<p>下面分别介绍下各个参数的意义</p>
<h2 id="1、mode"><a href="#1、mode" class="headerlink" title="1、mode"></a>1、mode</h2><p>权限设定字串，格式如下 : [ugoa…][[+-=][rwxX]…][,…]</p>
<p>其中：</p>
<ul>
<li>+：表示增加权限</li>
<li>-：表示取消权限</li>
<li>=：表示唯一设定权限。 </li>
</ul>
<h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><p>在Linux中的每个用户必须属于一个组，不能独立于组外。在Linux中每个文件有所有者、所在组、其它组的概念</p>
<ul>
<li>u：表示该档案的拥有者(user)</li>
<li>g：表示与该档案的拥有者属于同一个群体者(group)</li>
<li>o：表示其他以外的人(other)</li>
<li>a：表示这三者皆是(all)</li>
</ul>
<h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><ul>
<li>r：表示可读取</li>
<li>w：表示可写入</li>
<li>x：表示可执行</li>
<li>X：表示只有当该档案是个子目录或者该档案已经被设定过为可执行。 </li>
</ul>
<h2 id="2、其他参数"><a href="#2、其他参数" class="headerlink" title="2、其他参数"></a>2、其他参数</h2><ul>
<li>-c : 若该档案权限确实已经更改，才显示其更改动作 </li>
<li>-f : 若该档案权限无法被更改也不要显示错误讯息 </li>
<li>-v : 显示权限变更的详细资料 </li>
<li>-R : 对目前目录下的所有档案与子目录进行相同的权限变更(即以递回的方式逐个变更) </li>
<li>–help : 显示辅助说明 </li>
<li>version : 显示版本 </li>
</ul>
<h2 id="3、举例"><a href="#3、举例" class="headerlink" title="3、举例"></a>3、举例</h2><p>将档案 file1.txt 设为所有人皆可读取 : </p>
<blockquote>
<p>chmod ugo+r file1.txt  </p>
</blockquote>
<p>将档案 file1.txt 设为所有人皆可读取 : </p>
<blockquote>
<p>chmod a+r file1.txt  </p>
</blockquote>
<p>将档案 file1.txt 与 file2.txt 设为该档案拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 : </p>
<blockquote>
<p>chmod ug+w,o-w file1.txt file2.txt  </p>
</blockquote>
<p>将 ex1.py 设定为只有该档案拥有者可以执行 : </p>
<blockquote>
<p>chmod u+x ex1.py  </p>
</blockquote>
<p>将目前目录下的所有档案与子目录皆设为任何人可读取 : </p>
<blockquote>
<p>chmod -R a+r *  </p>
</blockquote>
<h2 id="4、数字表示"><a href="#4、数字表示" class="headerlink" title="4、数字表示"></a>4、数字表示</h2><p>chmod也可以用数字来表示权限如 chmod 777 file </p>
<p>语法为：chmod abc file<br>其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。<br>r=4，w=2，x=1<br>若要rwx属性则4+2+1=7；<br>若要rw-属性则4+2=6；<br>若要r-x属性则4+1=7。 </p>
<p>例如:</p>
<p><code>chmod a=rwx file</code>  和<code>chmod 777 file</code>  效果相同<br><code>chmod ug=rwx,o=x file</code>  和<code>chmod 771 file</code>  效果相同 </p>
<h3 id="chmod-755和chmod-4755的区别"><a href="#chmod-755和chmod-4755的区别" class="headerlink" title="chmod 755和chmod 4755的区别"></a>chmod 755和chmod 4755的区别</h3><p>chmod 4755 filename可以使此程序具有root权限</p>
<p>chmod 755 设置用户的权限为：</p>
<p>1.文件所有者可读可写可执行<br>2.与文件所有者同属一个用户组的其他用户可读可执行<br>3.其它用户组可读可执行</p>
<p>chmod 4755与chmod 755 的区别在于开头多了一位，这个4表示其他用户执行文件时，具有与所有者相当的权限。</p>
<p>例如：root用户创建了一个上网认证程序netlogin，如果其他用户要上网也要用到这个程序，那就需要root用户运行chmod 755 netlogin命令使其他用户也能运行netlogin。</p>
<p>但是netlogin执行时可能需要访问一些只有root用户才有权访问的文件，那么其他用户执行netlogin时可能因为权限不够还是不能上网。</p>
<p>这种情况下，就可以用 chmod 4755 netlogin 设置其他用户在执行netlogin也有root用户的权限，从而顺利上网。</p>
<h1 id="二、查看权限"><a href="#二、查看权限" class="headerlink" title="二、查看权限"></a>二、查看权限</h1><h2 id="1、ls-l"><a href="#1、ls-l" class="headerlink" title="1、ls-l"></a>1、ls-l</h2><p>查看权限的命令是<code>la -l</code></p>
<p>显示的格式如下：</p>
<blockquote>
<p>-rwxrw-r‐-1 root root 1213 Feb 2 09:39 abc</p>
</blockquote>
<p>前面的10个字符确定了它的权限</p>
<ul>
<li>第一个字符代表文件类型：<ul>
<li>-：代表文件</li>
<li>d：代表目录</li>
<li>|：代表链接</li>
</ul>
</li>
<li>后面9个字符，3个位一组：表示不同用户类型的权限：<ul>
<li>第一组rwx：文件<strong>所有者</strong>的权限是读、写和执行 </li>
<li>第二组rw-：与文件所有者<strong>同一组</strong>的用户的权限是读、写但不能执行 </li>
<li>第三组r–：不与文件所有者同组的<strong>其他用户</strong>的权限是读不能写和执行 </li>
</ul>
</li>
</ul>
<p>后面的代表了其他的信息</p>
<ul>
<li>1 表示连接的文件数</li>
<li>root 表示用户</li>
<li>root表示用户所在的组</li>
<li>1213 表示文件大小（字节）</li>
<li>Feb 2 09:39 表示最后修改日期</li>
<li>abc 表示文件名</li>
</ul>
<h2 id="2、目录权限"><a href="#2、目录权限" class="headerlink" title="2、目录权限"></a>2、目录权限</h2><p>关于目录权限，r(浏览目录)和x(进入目录)是有区别的，尤其是和cd命令一起</p>
<ul>
<li>r允许你列出目录内的文件</li>
<li>x只是允许你进入目录.</li>
</ul>
<ul>
<li>如果只有x权限，没有r权限，可以执行cd命令进入目录，但是在目录内无法执行ls命令</li>
<li>如果只有r权限，没有x权限，那么根本无法使用cd命令进入目录</li>
</ul>
<h1 id="三、参考地址"><a href="#三、参考地址" class="headerlink" title="三、参考地址"></a>三、参考地址</h1><p><a href="http://www.cnblogs.com/chengJAVA/p/4319420.html" target="_blank" rel="external">http://www.cnblogs.com/chengJAVA/p/4319420.html</a></p>
<p><a href="http://www.cnblogs.com/123-/p/4189072.html" target="_blank" rel="external">http://www.cnblogs.com/123-/p/4189072.html</a></p>
<p><a href="http://blog.csdn.net/water_cow/article/details/7174881" target="_blank" rel="external">http://blog.csdn.net/water_cow/article/details/7174881</a></p>
<p><a href="http://www.linuxidc.com/Linux/2014-10/107874.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2014-10/107874.htm</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[矩阵相乘与矩阵快速幂]]></title>
      <url>http://yoursite.com/2017/03/27/algorithm/%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%B9%98%E4%B8%8E%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      <content type="html"><![CDATA[<p>网易实习生笔试题，神奇手环，最开始的方法只过了60%，后来想到可以用矩阵的方法来计算。</p>
<h1 id="一、矩阵相乘"><a href="#一、矩阵相乘" class="headerlink" title="一、矩阵相乘"></a>一、矩阵相乘</h1><p>下面的矩阵统一用二维数组来表示，先实现两个矩阵相乘的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 矩阵a与b相乘</div><div class="line">     * a的列数与b的行数相同才有意义</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] multi(<span class="keyword">int</span>[][] a, <span class="keyword">int</span>[][] b)&#123;</div><div class="line">        <span class="keyword">if</span>(a.length==<span class="number">0</span>||a[<span class="number">0</span>].length==<span class="number">0</span>||b.length==<span class="number">0</span>||b[<span class="number">0</span>].length==<span class="number">0</span>||a[<span class="number">0</span>].length!=b.length)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> m=a.length, n=b[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span>[][] re=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</div><div class="line">                <span class="keyword">int</span> sum=<span class="number">0</span>;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;b.length; x++)&#123;</div><div class="line">                    sum+=a[i][x]*b[x][j];</div><div class="line">                &#125;</div><div class="line">                re[i][j]=sum;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> re;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] nums: matrix)&#123;</div><div class="line">            System.out.println(Arrays.toString(nums));</div><div class="line">        &#125;</div><div class="line">    &#125;	</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[][] m1=<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</div><div class="line">            &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,</div><div class="line">            &#123;<span class="number">3</span>,<span class="number">4</span>&#125;,</div><div class="line">            &#123;<span class="number">5</span>,<span class="number">6</span>&#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">int</span>[][] m2=<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</div><div class="line">            &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</div><div class="line">            &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</div><div class="line">        &#125;;</div><div class="line">        printMatrix(multi(m1, m2));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[9, 12, 15]</div><div class="line">[19, 26, 33]</div><div class="line">[29, 40, 51]</div></pre></td></tr></table></figure>
<p>时间复杂度是O(n^3)</p>
<h1 id="二、矩阵快速幂"><a href="#二、矩阵快速幂" class="headerlink" title="二、矩阵快速幂"></a>二、矩阵快速幂</h1><p>矩阵快速幂可以高效地计算矩阵，将O(n)的时间复杂度降到O(logn)。</p>
<p>它的原理与数的快速幂是一样的，先来回忆一下数的快速幂</p>
<h2 id="1、数的快速幂"><a href="#1、数的快速幂" class="headerlink" title="1、数的快速幂"></a>1、数的快速幂</h2><ol>
<li>Pow(x, n)，leetcode原题</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</div><div class="line">        	<span class="keyword">if</span>(n==Integer.MIN_VALUE)&#123;</div><div class="line">        		<span class="keyword">return</span> <span class="number">1.0</span>/myPow(x,Integer.MAX_VALUE)*x;</div><div class="line">        	&#125;<span class="keyword">else</span>&#123;</div><div class="line">        		<span class="keyword">return</span> <span class="number">1.0</span>/myPow(x, -n);</div><div class="line">        	&#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</div><div class="line">        	<span class="keyword">return</span> <span class="number">1.0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">double</span> re=<span class="number">1.0</span>;</div><div class="line">        <span class="keyword">for</span>(; n&gt;<span class="number">0</span>; x*=x, n&gt;&gt;=<span class="number">1</span>)&#123;</div><div class="line">        	<span class="keyword">if</span>((n&amp;<span class="number">1</span>)==<span class="number">1</span>)&#123;</div><div class="line">        		re*=x;</div><div class="line">        	&#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> re;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它的原理就是x^n=x^(n1+n2+n3+…..)=x^n1*xn2*x^n3…,</p>
<p>其中n=n1+n2+n3…   将n用二进制表示，则n1, n2, n3就可以表示为2^0, 2^1， 2^2….</p>
<p>举个例子，x^5=x^4*x^1</p>
<p>这样时间复杂度就从O(n)降到O(logn)。</p>
<h2 id="2、矩阵快速幂"><a href="#2、矩阵快速幂" class="headerlink" title="2、矩阵快速幂"></a>2、矩阵快速幂</h2><p>矩阵快速幂的原理与上面是一样的，在编程之美2.9中也介绍到了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 矩阵a与b相乘</div><div class="line">     * a的列数与b的行数相同才有意义</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] multi(<span class="keyword">int</span>[][] a, <span class="keyword">int</span>[][] b)&#123;</div><div class="line">        <span class="keyword">if</span>(a.length==<span class="number">0</span>||a[<span class="number">0</span>].length==<span class="number">0</span>||b.length==<span class="number">0</span>||b[<span class="number">0</span>].length==<span class="number">0</span>||a[<span class="number">0</span>].length!=b.length)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> m=a.length, n=b[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span>[][] re=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</div><div class="line">                <span class="keyword">int</span> sum=<span class="number">0</span>;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;b.length; x++)&#123;</div><div class="line">                    sum+=a[i][x]*b[x][j];</div><div class="line">                &#125;</div><div class="line">                re[i][j]=sum;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> re;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] nums: matrix)&#123;</div><div class="line">            System.out.println(Arrays.toString(nums));</div><div class="line">        &#125;</div><div class="line">    &#125;	</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 计算矩阵的幂</div><div class="line">     * 方阵a的n次幂</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] matrixPow(<span class="keyword">int</span>[][] a, <span class="keyword">int</span> n)&#123;</div><div class="line">        <span class="keyword">if</span>(a.length==<span class="number">0</span>||a[<span class="number">0</span>].length==<span class="number">0</span>||a.length!=a[<span class="number">0</span>].length)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> len=a.length;</div><div class="line">        <span class="keyword">int</span>[][] re=<span class="keyword">new</span> <span class="keyword">int</span>[len][len];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;<span class="comment">//单位阵</span></div><div class="line">            re[i][i]=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 这里需要注意一下，Java中二维数组是无法用clone实现深拷贝的</div><div class="line">         * 也就是说这个temp指向的内存和a是相同的</div><div class="line">         * 因为multi方法中每次都会返回一个新的数组，所以说a的内容不会被修改</div><div class="line">         * </div><div class="line">         */</div><div class="line">        <span class="keyword">int</span>[][] temp=a.clone();</div><div class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">if</span>((n&amp;<span class="number">1</span>)==<span class="number">1</span>)&#123;</div><div class="line">                re=multi(re, temp);</div><div class="line">            &#125;</div><div class="line">            temp=multi(temp, temp);</div><div class="line">            n&gt;&gt;=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> re;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[][] matrix=<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</div><div class="line">            &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</div><div class="line">            &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,</div><div class="line">            &#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</div><div class="line">        &#125;;</div><div class="line">        printMatrix(matrixPow(matrix, <span class="number">4</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里又两点需要注意</p>
<ol>
<li>在注释中说到的clone方法无法实现二维数组的深拷贝，由于本例的特殊情况才这样写，正常情况下的二维数组拷贝应该遍历</li>
<li>当把上面的参数从4改成8后，输出结果就已经出现负数了，说明已经溢出。而且实际上，即使n等于4的时候，temp中就已经出现负数了。所以可见矩阵乘法的增长速度非常大。在实际情况中，应该使用字符串表示才是最可靠的。</li>
</ol>
<h1 id="三、矩阵快速幂的应用"><a href="#三、矩阵快速幂的应用" class="headerlink" title="三、矩阵快速幂的应用"></a>三、矩阵快速幂的应用</h1><h2 id="1、斐波那契数列"><a href="#1、斐波那契数列" class="headerlink" title="1、斐波那契数列"></a>1、斐波那契数列</h2><p>最早接触到矩阵快速幂的时候应该就是编程之美2.9，斐波那契数列的问题。</p>
<p>不会编辑公式，具体问题和与原理就不描述了，直接上代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MatrixApp</span> </span>&#123;	</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 计算第n个斐波那契数列</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span>[][] A=<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</div><div class="line">            &#123;<span class="number">1</span>,<span class="number">1</span>&#125;,</div><div class="line">            &#123;<span class="number">1</span>,<span class="number">0</span>&#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">int</span>[][] An=Matrix.matrixPow(A, n-<span class="number">1</span>);</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> F1=<span class="number">1</span>, F0=<span class="number">0</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> F1*An[<span class="number">0</span>][<span class="number">0</span>]+F0*An[<span class="number">0</span>][<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(fib(<span class="number">10</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>果然，当输入的n太大后，计算的就不准了，因为超过了int范围。</p>
<h2 id="2、魔幻手环"><a href="#2、魔幻手环" class="headerlink" title="2、魔幻手环"></a>2、魔幻手环</h2><p>终于到了这个网易的笔试题，魔幻手环</p>
<blockquote>
<p>小易拥有一个拥有魔力的手环上面有n个数字(构成一个环),当这个魔力手环每次使用魔力的时候就会发生一种奇特的变化：每个数字会变成自己跟后面一个数字的和(最后一个数字的后面一个数字是第一个),一旦某个位置的数字大于等于100就马上对100取模(比如某个位置变为103,就会自动变为3).现在给出这个魔力手环的构成，请你计算出使用k次魔力之后魔力手环的状态。</p>
</blockquote>
<p><strong>输入描述:</strong></p>
<blockquote>
<p>输入数据包括两行：</p>
<p>第一行为两个整数n(2 ≤ n ≤ 50)和k(1 ≤ k ≤ 2000000000),以空格分隔</p>
<p>第二行为魔力手环初始的n个数，以空格分隔。范围都在0至99.</p>
</blockquote>
<p><strong>输出描述:</strong></p>
<blockquote>
<p>输出魔力手环使用k次之后的状态，以空格分隔，行末无空格。</p>
</blockquote>
<p><strong>输入例子:</strong></p>
<blockquote>
<p>3 2</p>
<p>1 2 3</p>
</blockquote>
<p><strong>输出例子:</strong></p>
<blockquote>
<p>8 9 7</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;	</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 实习笔试 排队形 男生女生</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(String s)</span></span>&#123;</div><div class="line">        <span class="keyword">char</span>[] chars=s.toCharArray();</div><div class="line">        <span class="keyword">int</span> re1=<span class="number">0</span>, re2=<span class="number">0</span>, g=<span class="number">0</span>, b=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;chars.length; i++)&#123;</div><div class="line">            <span class="keyword">if</span>(chars[i]==<span class="string">'G'</span>)&#123;</div><div class="line">                re1+=i-g;</div><div class="line">                g++;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                re2+=i-b;</div><div class="line">                b++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.print(Math.min(re1, re2));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 魔力手环</div><div class="line">     */	</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] multi(<span class="keyword">int</span>[][] a, <span class="keyword">int</span>[][] b)&#123;</div><div class="line">        <span class="keyword">if</span>(a.length==<span class="number">0</span>||a[<span class="number">0</span>].length==<span class="number">0</span>||b.length==<span class="number">0</span>||b[<span class="number">0</span>].length==<span class="number">0</span>||a[<span class="number">0</span>].length!=b.length)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> m=a.length, n=b[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span>[][] re=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</div><div class="line">                <span class="keyword">int</span> sum=<span class="number">0</span>;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;b.length; x++)&#123;</div><div class="line">                    sum+=a[i][x]*b[x][j]%<span class="number">100</span>;</div><div class="line">                &#125;</div><div class="line">                re[i][j]=sum%<span class="number">100</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> re;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span>[] nums=matrix[<span class="number">0</span>];</div><div class="line">        System.out.print(nums[<span class="number">0</span>]);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++)&#123;</div><div class="line">            System.out.print(<span class="string">" "</span>+nums[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] matrixPow(<span class="keyword">int</span>[][] a, <span class="keyword">int</span> n)&#123;</div><div class="line">        <span class="keyword">if</span>(a.length==<span class="number">0</span>||a[<span class="number">0</span>].length==<span class="number">0</span>||a.length!=a[<span class="number">0</span>].length)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> len=a.length;</div><div class="line">        <span class="keyword">int</span>[][] re=<span class="keyword">new</span> <span class="keyword">int</span>[len][len];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;<span class="comment">//单位阵</span></div><div class="line">            re[i][i]=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[][] temp=a.clone();</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">if</span>((n&amp;<span class="number">1</span>)==<span class="number">1</span>)&#123;</div><div class="line">                re=multi(re, temp);</div><div class="line">            &#125;</div><div class="line">            temp=multi(temp, temp);</div><div class="line">            n&gt;&gt;=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> re;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">magicHoop</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span>[][] a=<span class="keyword">new</span> <span class="keyword">int</span>[n][n];</div><div class="line">        a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</div><div class="line">        a[<span class="number">0</span>][n-<span class="number">1</span>]=<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</div><div class="line">            a[i][i]=<span class="number">1</span>;</div><div class="line">            a[i][i-<span class="number">1</span>]=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        print(multi(<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;nums&#125;, matrixPow(a, k)));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">        <span class="keyword">int</span> n=sc.nextInt();</div><div class="line">        <span class="keyword">int</span> k=sc.nextInt();</div><div class="line">        <span class="keyword">int</span>[] nums=<span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</div><div class="line">            nums[i]=sc.nextInt();</div><div class="line">        &#125;</div><div class="line">        sc.close();</div><div class="line">        magicHoop(nums, n, k);		</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>题中特意加了超过100后取模，看来就是为了防止溢出。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[扔鸡蛋问题]]></title>
      <url>http://yoursite.com/2017/02/28/algorithm/%E6%89%94%E9%B8%A1%E8%9B%8B%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h1><p>两个软硬程度一样但未知的鸡蛋，它们有可能都在一楼就摔碎，也可能从一百层楼摔下来没事。有座100层的建筑，要你用这两个鸡蛋确定哪一层是鸡蛋可以安全落下的最高位置。可以摔碎两个鸡蛋。（参见[<a href="http://blog.csdn.net/TravelInHistory/archive/2006/12/07/1434098.aspx" target="_blank" rel="external">两个鸡蛋–一道Google面试题</a>]）</p>
<p>最早在公众号上遇到过，后来腾讯笔试好像也遇到过发现这个题还是很经典的。</p>
<h1 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h1><h2 id="1、数学方法"><a href="#1、数学方法" class="headerlink" title="1、数学方法"></a>1、数学方法</h2><p>一种想法是第一个鸡蛋折半搜索，如100层的楼，先从50层扔下去，如果碎了则第二个鸡蛋在1~49层楼中自底向上线性搜索；如果没碎则第一个鸡蛋再从75层扔。如果这次碎了则第二个鸡蛋在51~74层楼中自底向上线性搜索；如果还没碎则第一个鸡蛋再从88层扔，依此类推。这种方法不是最优，因为最坏情况下安全位置恰好是49层，需要尝试50次。</p>
<p>基于这个最坏的情况进行改进</p>
<ul>
<li>那么我假设最坏情况下会尝试x次。</li>
<li>则第一个鸡蛋第一次从第x层扔（不管碎没碎，还有x-1次尝试机会）。<ul>
<li>如果碎了，则第二个鸡蛋在1～x-1层中线性搜索，最多x-1次；</li>
<li>如果没碎，则第一个鸡蛋第二次从x+(x-1)层扔（现在还剩x-2次尝试机会）。</li>
</ul>
</li>
<li>第二次尝试也是一样。<ul>
<li>如果这次碎了，则第二个鸡蛋在x+1～x+(x-1)-1层中线性搜索，最多x-2次；</li>
<li>如果还没碎第一个鸡蛋再从x+(x-1)+(x-2)层扔。</li>
</ul>
</li>
<li>依此类推。x次尝试所能确定的最高楼层数为x+(x-1)+(x-2)+…+1=x(x+1)/2。</li>
</ul>
<p>如果楼层为100的话，只要保证x(x+1)/2&gt;=100即可，即x&gt;=14，最少进行14次。</p>
<p>具体地说，100层的楼，第一次从14层开始扔。碎了好说，从第1层开始试。不碎的话还有13次机会，再从14+13=27层开始扔。依此类推，各次尝试的楼层依次为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">14</div><div class="line">27 = 14 + 13</div><div class="line">39 = 27 + 12 </div><div class="line">... </div><div class="line">99 = 95 + 4</div><div class="line">100</div></pre></td></tr></table></figure>
<h2 id="2、DP"><a href="#2、DP" class="headerlink" title="2、DP"></a>2、DP</h2><p>上面的解法更直观便于理解，但是从动态规划的角度可以更抽象的描述这个问题。</p>
<p>假设f[n]表示从n层楼找到摔鸡蛋不碎安全位置的最少判断次数。假设第一个鸡蛋第一次从第i层扔下，如果碎了，就剩一个鸡蛋，为确定下面楼层中的安全位置，必须从第一层挨着试，还需要i-1次；如果不碎的话，上面还有n-i层，剩下两个鸡蛋，还需要f[n-i]次（子问题，实体n层楼的上n-i层需要的最少判断次数和实体n-i层楼需要的最少判断次数其实是一样的）。因此，最坏情况下还需要判断max(i-1,f[n-i])次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">状态转移方程：f[n]=min&#123;1+max(i-1,f[n-i]) | i=1..n&#125; </div><div class="line"></div><div class="line">初始条件: f[0]=0, 或f[1]=1</div></pre></td></tr></table></figure>
<p>根据状态转移方程可以写出程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] dp)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</div><div class="line">        <span class="keyword">return</span> n;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(dp[n]&gt;<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> dp[n];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> min=Integer.MAX_VALUE;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</div><div class="line">        min=Math.min(min, <span class="number">1</span>+Math.max(i-<span class="number">1</span>, f(n-i, dp)));</div><div class="line">    &#125;</div><div class="line">    dp[n]=min;</div><div class="line">    <span class="keyword">return</span> min;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">eggThrow</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</div><div class="line">    <span class="keyword">return</span> f(n, dp);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输入100的话输出和上面一样也是14。</p>
<h2 id="3、扩展"><a href="#3、扩展" class="headerlink" title="3、扩展"></a>3、扩展</h2><p>现在把问题进行扩展，n层楼，m个鸡蛋。那么DP就是一个二维的数组了</p>
<p>假设f[n,m]表示n层楼、m个鸡蛋时找到摔鸡蛋不碎的最少判断次数。则一个鸡蛋从第i层扔下，如果碎了，还剩m-1个鸡蛋，为确定下面楼层中的安全位置，还需要f[i-1,m-1]次（子问题）；不碎的话，上面还有n-i层，还需要f[n-i,m]次（子问题，实体n层楼的上n-i层需要的最少判断次数和实体n-i层楼需要的最少判断次数其实是一样的）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">状态转移方程：f[n,m] = min&#123; 1+max(f[i-1,m-1], f[n-i,m]) | i＝1..n &#125; </div><div class="line">初始条件：f[i,0]=0（或f[i,1]=i），对所有i</div></pre></td></tr></table></figure>
<p>程序没有写，但是如果把输出列出来会很有意思：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1个鸡蛋：1+1+1+1+1+...</div><div class="line">2个鸡蛋：1+2+3+4+5+...（之间的差为1,1,1,1,1,1,...）</div><div class="line">3个鸡蛋：1+2+4+7+11+16+...（之间的差为1,2,3,4,5...）</div><div class="line">4个鸡蛋：1+2+4+8+15+26+...（之间的差为1,2,4,7,11...）</div></pre></td></tr></table></figure>
<p>上面这个序列的逆序，就是最后剩余的尝试次数。</p>
<p>关于这个问题有专门的论文进行数学分析。</p>
<h1 id="三、参考地址"><a href="#三、参考地址" class="headerlink" title="三、参考地址"></a>三、参考地址</h1><p><a href="http://blog.csdn.net/joylnwang/article/details/6769160" target="_blank" rel="external">http://blog.csdn.net/joylnwang/article/details/6769160</a></p>
<p><a href="http://www.cnblogs.com/ltang/archive/2010/11/23/1885791.html" target="_blank" rel="external">http://www.cnblogs.com/ltang/archive/2010/11/23/1885791.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一致性hash算法]]></title>
      <url>http://yoursite.com/2017/02/28/algorithm/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>一致性哈希算法，即consistent hashing，是分布式系统中常用的算法。主要应用在分布式存储系统中解决数据的分布式保存问题。</p>
<h1 id="一、基本场景"><a href="#一、基本场景" class="headerlink" title="一、基本场景"></a>一、基本场景</h1><p>比如有N个cache服务器(后面简称cache)，那么如何将一个对象Object映射到这个N个cache中呢？</p>
<p>最基本的办法就是采用普通的hash算法，对Object的hash值取余。即：</p>
<p>hash(Object)%N</p>
<p>当然如果这样做可行的话也就不用向下介绍了，考虑一下两种情况</p>
<ol>
<li>一个 cache 服务器 m down 掉了（在实际应用中必须要考虑这种情况），这样所有映射到 cache m 的对象都会失效，怎么办，需要把 cache m 从 cache 中移除，这时候 cache 是 N-1 台，映射公式变成了 hash(object)%(N-1)</li>
<li>由于访问加重，需要添加 cache ，这时候 cache 是 N+1 台，映射公式变成了 hash(object)%(N+1) </li>
</ol>
<p>以上两种情况下，缓存会全部失效。所以才会有下面的一致性hash算法。</p>
<h1 id="二、一致性hash算法"><a href="#二、一致性hash算法" class="headerlink" title="二、一致性hash算法"></a>二、一致性hash算法</h1><p>consistent hashing 是一种hash算法，简单的说，在移除或者添加一个cache时，它能够尽可能小的改变已存在key映射关系，尽可能的满足单调性的要求。</p>
<h2 id="1、环形hash空间"><a href="#1、环形hash空间" class="headerlink" title="1、环形hash空间"></a>1、环形hash空间</h2><p>在Java中，一个对象的hash方法返回的是一个int型的32位数据，所以，我们把这个空间范围0-2^32-1想象成一个首尾相接的环；</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/algorithm/1.JPG?raw=true" alt="1"></p>
<p>这个环是一致性hash算法的根本，下面的一系列映射都将围绕这个环展开。</p>
<h2 id="2、对象映射到hash空间"><a href="#2、对象映射到hash空间" class="headerlink" title="2、对象映射到hash空间"></a>2、对象映射到hash空间</h2><p>有了环形的hash空间以后，我们就要考虑对象的存储问题。</p>
<p>通过对象的hash方法，就可以直接得到该对象在环形空间上的地址，以下面的四个对象为例：</p>
<p>hash(object1) = key1;</p>
<p>… …</p>
<p>hash(object4) = key4;</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/algorithm/2.JPG?raw=true" alt="2"></p>
<h2 id="3、把cache映射到hash空间"><a href="#3、把cache映射到hash空间" class="headerlink" title="3、把cache映射到hash空间"></a>3、把cache映射到hash空间</h2><p>Consistent hashing 的基本思想就是将对象和cache都映射到同一个hash数值空间中，并且使用相同的hash算法。</p>
<p>所以接下来就要把cache服务器也映射到这个hash空间之中。</p>
<p>以三个cache服务器为例：</p>
<p>hash(cache A) = key A;</p>
<p>… …</p>
<p>hash(cache C) = key C;</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/algorithm/3.JPG?raw=true" alt="3"></p>
<p>对于cache，可以把服务器的ip地址作为hash的输入</p>
<h2 id="4、把对象映射到cache"><a href="#4、把对象映射到cache" class="headerlink" title="4、把对象映射到cache"></a>4、把对象映射到cache</h2><p>通过上面的两个步骤，对象和cache通过相同的hash算法被映射到相同的hash空间之中了，那么接下来就是把对象映射到cache里面了。</p>
<p>在环形空间中，如果沿着顺时针方向从对象的key值出发，直到遇见一个cache ，那么就将该对象存储在这个cache 上，因为对象和cache的hash值是固定的，因此这个cache必然是唯一和确定的。</p>
<p>参照上面的图片，对象Object1将被存储到cache A 上；Object2和Object3对应到cache C ；Object4对应到cache B ；</p>
<h2 id="5、cache的变动"><a href="#5、cache的变动" class="headerlink" title="5、cache的变动"></a>5、cache的变动</h2><p>最原始的hash方法不可行的原因就是当cache的数量发生变化时，缓存会失效，那么接下来看看一致性hash算法的好处。</p>
<h3 id="5-1、移除cache"><a href="#5-1、移除cache" class="headerlink" title="5.1、移除cache"></a>5.1、移除cache</h3><p>假设cache B挂掉了，根据上面讲到的映射方法，这时受影响的将仅是那些沿cache B逆时针遍历直到下一个cache(cache C)之间的对象，也即是本来映射到cache B上的那些对象。</p>
<p>因此这里仅需要变动对象Object4 ，将其重新映射到cache C上即可</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/algorithm/4.JPG?raw=true" alt="4"></p>
<h3 id="5-2、增加cache"><a href="#5-2、增加cache" class="headerlink" title="5.2、增加cache"></a>5.2、增加cache</h3><p>再假设添加一台新的cache D的情况，假设在这个环形hash空间中， cache D被映射在对象Object2和Object3之间。这时受影响的将仅是那些沿cache D逆时针遍历直到上一个cache(cache B)之间的对象(它们是也本来映射到 cache C 上对象的一部分)，将这些对象重新映射到cache D上即可。</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/algorithm/5.JPG?raw=true" alt="5"></p>
<p>可以看出，不管是增加还是移除缓存服务器，都不会对整个分布式缓存系统带来太大的影响。</p>
<h2 id="6、虚拟结点"><a href="#6、虚拟结点" class="headerlink" title="6、虚拟结点"></a>6、虚拟结点</h2><p>通过上面的机制解决了系统的稳定性，而接下来则可以在性能上进一步提高。</p>
<p>考量hash算法的另一个指标是平衡性 (Balance) ，定义如下：</p>
<p>平衡性：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。</p>
<p>hash算法并不是保证绝对的平衡，如果cache较少的话，对象并不能被均匀的映射到cache上，比如在上面的例子中，仅部署cache A和cacheC的情况下，在4 个对象中， cache A仅存储了Object1 ，而cache C则存储了Object2、Object3和Object4。明显是不均衡的。 </p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/algorithm/4.JPG?raw=true" alt=""></p>
<p>为了解决这种情况， consistent hashing引入了“虚拟节点”的概念，它可以如下定义：</p>
<blockquote>
<p>“虚拟节点”（ virtual node ）是实际节点在 hash 空间的复制品（ replica ），一实际个节点对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以 hash 值排列。</p>
</blockquote>
<p>再以仅部署cache A和cache C的情况为例，上面我们已经看到， cache分布并不均匀。现在我们引入虚拟节点，并设置“复制个数”为 2 ，这就意味着一共会存在 4 个“虚拟节点”， cache A1, cache A2 代表了cache A ；cache C1, cache C2 代表了 cache C ；假设一种比较理想的情况，</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/algorithm/6.JPG?raw=true" alt="6"></p>
<p>此时，对象到“虚拟节点”的映射关系为：</p>
<p>Objec1-&gt;cache A2 ； Objec2-&gt;cache A1 ； Objec3-&gt;cache C1 ； Objec4-&gt;cache C2 ；</p>
<p>因此对象Object1和Object2 都被映射到了cache A上，而Object3和Object4映射到了cache C上；平衡性有了很大提高。</p>
<p>引入“虚拟节点”后，映射关系就从 { 对象 -&gt; 节点 } 转换到了 { 对象 -&gt; 虚拟节点 } 。查询物体所在cache时的映射关系如下图</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/algorithm/7.JPG?raw=true" alt="7"></p>
<h1 id="三、参考地址"><a href="#三、参考地址" class="headerlink" title="三、参考地址"></a>三、参考地址</h1><p><a href="http://blog.csdn.net/sparkliang/article/details/5279393" target="_blank" rel="external">http://blog.csdn.net/sparkliang/article/details/5279393</a></p>
<p><a href="http://www.blogjava.net/hello-yun/archive/2012/10/10/389289.html" target="_blank" rel="external">http://www.blogjava.net/hello-yun/archive/2012/10/10/389289.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis源码分析]]></title>
      <url>http://yoursite.com/2017/02/14/MyBatis/MyBatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>下面以<a href="http://www.mybatis.org/mybatis-3/zh/getting-started.html" target="_blank" rel="external">官网</a>给出的入门实例来简单分析MyBatis的源码</p>
<h1 id="一、从-XML-中构建-SqlSessionFactory"><a href="#一、从-XML-中构建-SqlSessionFactory" class="headerlink" title="一、从 XML 中构建 SqlSessionFactory"></a>一、从 XML 中构建 SqlSessionFactory</h1><h2 id="1、使用"><a href="#1、使用" class="headerlink" title="1、使用"></a>1、使用</h2><p>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为中心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。</p>
<p>从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。但是也可以使用任意的输入流(InputStream)实例，包括字符串形式的文件路径或者 file:// 的 URL 形式的文件路径来配置。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，可使从 classpath 或其他位置加载资源文件更加容易。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String resource = <span class="string">"org/mybatis/example/mybatis-config.xml"</span>;</div><div class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</div><div class="line">sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</div></pre></td></tr></table></figure>
<p>下面看一下源码中发生了什么</p>
<h2 id="2、源码"><a href="#2、源码" class="headerlink" title="2、源码"></a>2、源码</h2><h3 id="2-1、SqlSessionFactoryBuilder"><a href="#2-1、SqlSessionFactoryBuilder" class="headerlink" title="2.1、SqlSessionFactoryBuilder"></a>2.1、SqlSessionFactoryBuilder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.apache.ibatis.session;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionFactoryBuilder</span> </span>&#123;</div><div class="line"></div><div class="line">  	<span class="comment">//上面的省略</span></div><div class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> build(inputStream, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> build(inputStream, environment, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, Properties properties)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> build(inputStream, <span class="keyword">null</span>, properties);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</div><div class="line">            <span class="keyword">return</span> build(parser.parse());</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error building SqlSession."</span>, e);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            ErrorContext.instance().reset();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                inputStream.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                <span class="comment">// Intentionally ignore. Prefer previous error.</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(config);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出：</p>
<ol>
<li>不同类型的构造方法最后都调用到build(InputStream inputStream, String environment, Properties properties)</li>
<li>首先定义一个XMLConfigBuilder，这个类主要完成XML文件的解析，通过调用parse()方法，生成一个Configuration对象。前面提到过，Configuration对象中包含着全局的配置参数。</li>
<li>最后调用build()方法，将解析生成的Configuration对象作为参数，来构造一个SqlSessionFactory，SqlSessionFactory是一个接口，这里生成的是它的默认实现类：DefaultSqlSessionFactory</li>
</ol>
<p>下面看一下DefaultSqlSessionFactory类：</p>
<h3 id="2-2、DefaultSqlSessionFactory"><a href="#2-2、DefaultSqlSessionFactory" class="headerlink" title="2.2、DefaultSqlSessionFactory"></a>2.2、DefaultSqlSessionFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.apache.ibatis.session.defaults;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSqlSessionFactory</span> <span class="keyword">implements</span> <span class="title">SqlSessionFactory</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultSqlSessionFactory</span><span class="params">(Configuration configuration)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.configuration = configuration;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//下面的先省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DefaultSqlSessionFactory中有一个final的Configuration变量，构造方法就是将传入的Configuration绑定到改常量，并且不可修改。</p>
<p>至此为止，就生成了SqlSessionFactory对象，可以看出该过程主要就是对配置文件XML文件的解析，然后生成Configuration对象并绑定到SqlSessionFactory上。</p>
<p>下面继续看</p>
<h1 id="二、从-SqlSessionFactory-中获取-SqlSession"><a href="#二、从-SqlSessionFactory-中获取-SqlSession" class="headerlink" title="二、从 SqlSessionFactory 中获取 SqlSession"></a>二、从 SqlSessionFactory 中获取 SqlSession</h1><h2 id="1、使用-1"><a href="#1、使用-1" class="headerlink" title="1、使用"></a>1、使用</h2><p>既然有了 SqlSessionFactory ，顾名思义，我们就可以从中获得 SqlSession 的实例了。SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">SqlSession session = sqlSessionFactory.openSession();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  Blog blog = (Blog) session.selectOne(<span class="string">"org.mybatis.example.BlogMapper.selectBlog"</span>, <span class="number">101</span>);</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">  session.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>诚然这种方式能够正常工作，并且对于使用旧版本 MyBatis 的用户来说也比较熟悉，不过现在有了一种更直白的方式。使用对于给定语句能够合理描述参数和返回值的接口（比如说BlogMapper.class），你现在不但可以执行更清晰和类型安全的代码，而且还不用担心易错的字符串字面值以及强制类型转换。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SqlSession session = sqlSessionFactory.openSession();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  BlogMapper mapper = session.getMapper(BlogMapper.class);</div><div class="line">  Blog blog = mapper.selectBlog(<span class="number">101</span>);</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">  session.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里其实分两个部分，首先研究一下第一句话，也就是SqlSession的获取。</p>
<h2 id="2、源码-1"><a href="#2、源码-1" class="headerlink" title="2、源码"></a>2、源码</h2><h3 id="2-1、DefaultSqlSessionFactory"><a href="#2-1、DefaultSqlSessionFactory" class="headerlink" title="2.1、DefaultSqlSessionFactory"></a>2.1、DefaultSqlSessionFactory</h3><p>再来看一下DefaultSqlSessionFactory中的openSession方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.apache.ibatis.session.defaults;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSqlSessionFactory</span> <span class="keyword">implements</span> <span class="title">SqlSessionFactory</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultSqlSessionFactory</span><span class="params">(Configuration configuration)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.configuration = configuration;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> SqlSession <span class="title">openSession</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//中间的方法省略</span></div><div class="line">    <span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level,</span></span></div><div class="line">            <span class="keyword">boolean</span> autoCommit) &#123;</div><div class="line">        Transaction tx = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</div><div class="line">            <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</div><div class="line">            tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</div><div class="line">            <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call</span></div><div class="line">                                    <span class="comment">// close()</span></div><div class="line">            <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + e, e);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            ErrorContext.instance().reset();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很多重载方法，调用的都是下面这个openSessionFromDataSource方法，有三个参数：</p>
<ul>
<li>ExecutorType</li>
<li>TransactionIsolationLevel</li>
<li>autoCommit</li>
</ul>
<p>这里使用的都是默认值。</p>
<p>而这个openSessionFromDataSource方法的逻辑也很简单：</p>
<ol>
<li>从Configuration中获取Environment</li>
<li>通过Environment获取TransactionFactory</li>
<li>通过TransactionFactory的newTransaction方法构造一个Transaction对象</li>
<li>通过configuration的newExecutor方法构造一个Executor对象</li>
<li>由于SqlSession也是一个接口，所以也返回它的默认实现类DefaultSqlSession。并且将configuration、autoCommit和将刚才生成的executor作为参数。</li>
</ol>
<p>这个过程中主要就是生成了一个Executor对象。该对象非常重要，事实上sqlsession的所有操作都是通过它完成的。下面来看一下这个对象</p>
<h3 id="2-2、Executor"><a href="#2-2、Executor" class="headerlink" title="2.2、Executor"></a>2.2、Executor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.apache.ibatis.session;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> Environment environment;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> safeRowBoundsEnabled;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> safeResultHandlerEnabled = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> mapUnderscoreToCamelCase;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> aggressiveLazyLoading;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> multipleResultSetsEnabled = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> useGeneratedKeys;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> useColumnLabel = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> cacheEnabled = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> callSettersOnNulls;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> useActualParamName = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> returnInstanceForEmptyRow;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> String logPrefix;</div><div class="line">    <span class="keyword">protected</span> Class&lt;? extends Log&gt; logImpl;</div><div class="line">    <span class="keyword">protected</span> Class&lt;? extends VFS&gt; vfsImpl;</div><div class="line">    <span class="keyword">protected</span> LocalCacheScope localCacheScope = LocalCacheScope.SESSION;</div><div class="line">    <span class="keyword">protected</span> JdbcType jdbcTypeForNull = JdbcType.OTHER;</div><div class="line">    <span class="keyword">protected</span> Set&lt;String&gt; lazyLoadTriggerMethods = <span class="keyword">new</span> HashSet&lt;String&gt;(</div><div class="line">            Arrays.asList(<span class="keyword">new</span> String[] &#123; <span class="string">"equals"</span>, <span class="string">"clone"</span>, <span class="string">"hashCode"</span>, <span class="string">"toString"</span> &#125;));</div><div class="line">    <span class="keyword">protected</span> Integer defaultStatementTimeout;</div><div class="line">    <span class="keyword">protected</span> Integer defaultFetchSize;</div><div class="line">    <span class="keyword">protected</span> ExecutorType defaultExecutorType = ExecutorType.SIMPLE;</div><div class="line">    <span class="keyword">protected</span> AutoMappingBehavior autoMappingBehavior = AutoMappingBehavior.PARTIAL;</div><div class="line">    <span class="keyword">protected</span> AutoMappingUnknownColumnBehavior autoMappingUnknownColumnBehavior = AutoMappingUnknownColumnBehavior.NONE;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> Properties variables = <span class="keyword">new</span> Properties();</div><div class="line">    <span class="keyword">protected</span> ReflectorFactory reflectorFactory = <span class="keyword">new</span> DefaultReflectorFactory();</div><div class="line">    <span class="keyword">protected</span> ObjectFactory objectFactory = <span class="keyword">new</span> DefaultObjectFactory();</div><div class="line">    <span class="keyword">protected</span> ObjectWrapperFactory objectWrapperFactory = <span class="keyword">new</span> DefaultObjectWrapperFactory();</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> lazyLoadingEnabled = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">protected</span> ProxyFactory proxyFactory = <span class="keyword">new</span> JavassistProxyFactory(); <span class="comment">// #224</span></div><div class="line">                                                                        <span class="comment">// Using</span></div><div class="line">                                                                        <span class="comment">// internal</span></div><div class="line">                                                                        <span class="comment">// Javassist</span></div><div class="line">                                                                        <span class="comment">// instead</span></div><div class="line">                                                                        <span class="comment">// of</span></div><div class="line">                                                                        <span class="comment">// OGNL</span></div><div class="line"></div><div class="line">    <span class="keyword">protected</span> String databaseId;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Configuration factory class. Used to create Configuration for loading</div><div class="line">     * deserialized unread properties.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@see</span> &lt;a href=</div><div class="line">     *      'https://code.google.com/p/mybatis/issues/detail?id=300'&gt;Issue 300</div><div class="line">     *      (google code)&lt;/a&gt;</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> Class&lt;?&gt; configurationFactory;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> MapperRegistry mapperRegistry = <span class="keyword">new</span> MapperRegistry(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> InterceptorChain interceptorChain = <span class="keyword">new</span> InterceptorChain();</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> TypeHandlerRegistry typeHandlerRegistry = <span class="keyword">new</span> TypeHandlerRegistry();</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> TypeAliasRegistry typeAliasRegistry = <span class="keyword">new</span> TypeAliasRegistry();</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> LanguageDriverRegistry languageRegistry = <span class="keyword">new</span> LanguageDriverRegistry();</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, MappedStatement&gt; mappedStatements = <span class="keyword">new</span> StrictMap&lt;MappedStatement&gt;(</div><div class="line">            <span class="string">"Mapped Statements collection"</span>);</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, Cache&gt; caches = <span class="keyword">new</span> StrictMap&lt;Cache&gt;(<span class="string">"Caches collection"</span>);</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, ResultMap&gt; resultMaps = <span class="keyword">new</span> StrictMap&lt;ResultMap&gt;(<span class="string">"Result Maps collection"</span>);</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, ParameterMap&gt; parameterMaps = <span class="keyword">new</span> StrictMap&lt;ParameterMap&gt;(<span class="string">"Parameter Maps collection"</span>);</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, KeyGenerator&gt; keyGenerators = <span class="keyword">new</span> StrictMap&lt;KeyGenerator&gt;(<span class="string">"Key Generators collection"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Set&lt;String&gt; loadedResources = <span class="keyword">new</span> HashSet&lt;String&gt;();</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, XNode&gt; sqlFragments = <span class="keyword">new</span> StrictMap&lt;XNode&gt;(</div><div class="line">            <span class="string">"XML fragments parsed from previous mappers"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Collection&lt;XMLStatementBuilder&gt; incompleteStatements = <span class="keyword">new</span> LinkedList&lt;XMLStatementBuilder&gt;();</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Collection&lt;CacheRefResolver&gt; incompleteCacheRefs = <span class="keyword">new</span> LinkedList&lt;CacheRefResolver&gt;();</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Collection&lt;ResultMapResolver&gt; incompleteResultMaps = <span class="keyword">new</span> LinkedList&lt;ResultMapResolver&gt;();</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Collection&lt;MethodResolver&gt; incompleteMethods = <span class="keyword">new</span> LinkedList&lt;MethodResolver&gt;();</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * A map holds cache-ref relationship. The key is the namespace that</div><div class="line">     * references a cache bound to another namespace and the value is the</div><div class="line">     * namespace which the actual cache is bound to.</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, String&gt; cacheRefMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Configuration</span><span class="params">(Environment environment)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>();</div><div class="line">        <span class="keyword">this</span>.environment = environment;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Configuration</span><span class="params">()</span> </span>&#123;</div><div class="line">        typeAliasRegistry.registerAlias(<span class="string">"JDBC"</span>, JdbcTransactionFactory.class);</div><div class="line">        typeAliasRegistry.registerAlias(<span class="string">"MANAGED"</span>, ManagedTransactionFactory.class);</div><div class="line"></div><div class="line">        typeAliasRegistry.registerAlias(<span class="string">"JNDI"</span>, JndiDataSourceFactory.class);</div><div class="line">        typeAliasRegistry.registerAlias(<span class="string">"POOLED"</span>, PooledDataSourceFactory.class);</div><div class="line">        typeAliasRegistry.registerAlias(<span class="string">"UNPOOLED"</span>, UnpooledDataSourceFactory.class);</div><div class="line"></div><div class="line">        typeAliasRegistry.registerAlias(<span class="string">"PERPETUAL"</span>, PerpetualCache.class);</div><div class="line">        typeAliasRegistry.registerAlias(<span class="string">"FIFO"</span>, FifoCache.class);</div><div class="line">        typeAliasRegistry.registerAlias(<span class="string">"LRU"</span>, LruCache.class);</div><div class="line">        typeAliasRegistry.registerAlias(<span class="string">"SOFT"</span>, SoftCache.class);</div><div class="line">        typeAliasRegistry.registerAlias(<span class="string">"WEAK"</span>, WeakCache.class);</div><div class="line"></div><div class="line">        typeAliasRegistry.registerAlias(<span class="string">"DB_VENDOR"</span>, VendorDatabaseIdProvider.class);</div><div class="line"></div><div class="line">        typeAliasRegistry.registerAlias(<span class="string">"XML"</span>, XMLLanguageDriver.class);</div><div class="line">        typeAliasRegistry.registerAlias(<span class="string">"RAW"</span>, RawLanguageDriver.class);</div><div class="line"></div><div class="line">        typeAliasRegistry.registerAlias(<span class="string">"SLF4J"</span>, Slf4jImpl.class);</div><div class="line">        typeAliasRegistry.registerAlias(<span class="string">"COMMONS_LOGGING"</span>, JakartaCommonsLoggingImpl.class);</div><div class="line">        typeAliasRegistry.registerAlias(<span class="string">"LOG4J"</span>, Log4jImpl.class);</div><div class="line">        typeAliasRegistry.registerAlias(<span class="string">"LOG4J2"</span>, Log4j2Impl.class);</div><div class="line">        typeAliasRegistry.registerAlias(<span class="string">"JDK_LOGGING"</span>, Jdk14LoggingImpl.class);</div><div class="line">        typeAliasRegistry.registerAlias(<span class="string">"STDOUT_LOGGING"</span>, StdOutImpl.class);</div><div class="line">        typeAliasRegistry.registerAlias(<span class="string">"NO_LOGGING"</span>, NoLoggingImpl.class);</div><div class="line"></div><div class="line">        typeAliasRegistry.registerAlias(<span class="string">"CGLIB"</span>, CglibProxyFactory.class);</div><div class="line">        typeAliasRegistry.registerAlias(<span class="string">"JAVASSIST"</span>, JavassistProxyFactory.class);</div><div class="line"></div><div class="line">        languageRegistry.setDefaultDriverClass(XMLLanguageDriver.class);</div><div class="line">        languageRegistry.register(RawLanguageDriver.class);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//省略一部分</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> newExecutor(transaction, defaultExecutorType);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</div><div class="line">        executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</div><div class="line">        executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</div><div class="line">        Executor executor;</div><div class="line">        <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</div><div class="line">            executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</div><div class="line">            executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (cacheEnabled) &#123;</div><div class="line">            executor = <span class="keyword">new</span> CachingExecutor(executor);</div><div class="line">        &#125;</div><div class="line">        executor = (Executor) interceptorChain.pluginAll(executor);</div><div class="line">        <span class="keyword">return</span> executor;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//下面的也省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于生成Executor的方法在Configuration中，而Configuration对象包含了配置中所有的属性，所以这个类的代码特别多，虽然省略了很大一部分，但可以看出还是很长，上面特意保留了Configuration的所有属性。</p>
<p>生成Executor的方法newExecutor有两个参数：</p>
<ul>
<li>Transaction：主要用于构造Executor。</li>
<li>ExecutorType：Executor的类型，根据它进行判断生成那种Executor。</li>
</ul>
<p>该方法的逻辑：</p>
<ol>
<li><p>检查传入的ExecutorType，如果为null，则将defaultExecutorType赋值给它，如果还为null，则将ExecutorType.SIMPLE赋值给它</p>
</li>
<li><p>根据ExecutorType的类型，创建对应类型的Executor。</p>
<ul>
<li>BatchExecutor：专门用于执行批量sql操作</li>
<li>ReuseExecutor：会重用statement执行sql操作</li>
<li>SimpleExecutor：只是简单执行sql没有什么特别的</li>
</ul>
</li>
<li><p>判断是否开启cache</p>
<p>开启cache的话，就会创建CachingExecutor，它以前面创建的Executor作为唯一参数。CachingExecutor在查询数据库前先查找缓存，若没找到的话调用delegate（就是构造时传入的Executor对象）从数据库查询，并将查询结果存入缓存中。</p>
</li>
<li><p>最后加入插件</p>
<p>Executor对象是可以被插件拦截的，如果定义了针对Executor类型的插件，最终生成的Executor对象是被各个插件插入后的代理对象</p>
</li>
</ol>
<p>至此，Executor就生成了。回到上面，生成的Executor将作为参数，用于构造SqlSession的默认实现类DefaultSqlSession。</p>
<h3 id="2-3、DefaultSqlSession"><a href="#2-3、DefaultSqlSession" class="headerlink" title="2.3、DefaultSqlSession"></a>2.3、DefaultSqlSession</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.apache.ibatis.session.defaults;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSqlSession</span> <span class="keyword">implements</span> <span class="title">SqlSession</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Configuration configuration;</div><div class="line">    <span class="keyword">private</span> Executor executor;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> autoCommit;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> dirty;</div><div class="line">    <span class="keyword">private</span> List&lt;Cursor&lt;?&gt;&gt; cursorList;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultSqlSession</span><span class="params">(Configuration configuration, Executor executor, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.configuration = configuration;</div><div class="line">        <span class="keyword">this</span>.executor = executor;</div><div class="line">        <span class="keyword">this</span>.dirty = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">this</span>.autoCommit = autoCommit;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//下面的先省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DefaultSqlSession类中也有几个成员变量：</p>
<ul>
<li>Configuration</li>
<li>Executor</li>
<li>autoCommit</li>
<li>dirty</li>
<li>List cursorList</li>
</ul>
<p>到此，就获取到了一个SqlSession，这个过程中主要就是生成了Executor。</p>
<h1 id="三、从SqlSession中获取Mapper"><a href="#三、从SqlSession中获取Mapper" class="headerlink" title="三、从SqlSession中获取Mapper"></a>三、从SqlSession中获取Mapper</h1><h2 id="1、使用-2"><a href="#1、使用-2" class="headerlink" title="1、使用"></a>1、使用</h2><p>还是第二段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SqlSession session = sqlSessionFactory.openSession();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  BlogMapper mapper = session.getMapper(BlogMapper.class);</div><div class="line">  Blog blog = mapper.selectBlog(<span class="number">101</span>);</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">  session.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面只介绍了第一句话SqlSession的获取，下面看第二句，分析一个Mapper的获取。</p>
<p>首先先来看一下这个BlogMapper，它是我们定义的一个映射器类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.mybatis.example;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlogMapper</span> </span>&#123;</div><div class="line">  <span class="meta">@Select</span>(<span class="string">"SELECT * FROM blog WHERE id = #&#123;id&#125;"</span>)</div><div class="line">  <span class="function">Blog <span class="title">selectBlog</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它是一个接口，接口中所有方法都映射到对应的sql语句，在使用时，只需要调用接口中的方法，就可以执行对应的sql语句。而这个映射器类的作用就是把我们定义的接口方法和对应的sql语句映射到一起。</p>
<p>当然MyBatis 提供的全部特性可以利用基于 XML 的映射语言来实现</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</div><div class="line"><span class="meta">&lt;!DOCTYPE mapper</span></div><div class="line">  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</div><div class="line">  "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</div><div class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"org.mybatis.example.BlogMapper"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlog"</span> <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span></div><div class="line">    select * from Blog where id = #&#123;id&#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></div></pre></td></tr></table></figure>
<p>好的，下面再来看一下这句话，它获得了一个我们定义的映射器类的接口的实现类</p>
<p>BlogMapper mapper = session.getMapper(BlogMapper.class);</p>
<p>在源码中，它是怎样实现的</p>
<h2 id="2、源码-2"><a href="#2、源码-2" class="headerlink" title="2、源码"></a>2、源码</h2><p>在DefaultSqlSession中，这个方法调用了Configuration的getMapper方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type) &#123;</div><div class="line">    return configuration.&lt;T&gt; getMapper(type, this);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Configuration中，又调用了MapperRegistry的getMapper方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;</div><div class="line">    return mapperRegistry.getMapper(type, sqlSession);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-1、MapperRegistry"><a href="#2-1、MapperRegistry" class="headerlink" title="2.1、MapperRegistry"></a>2.1、MapperRegistry</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.apache.ibatis.binding;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperRegistry</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Configuration config;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapperRegistry</span><span class="params">(Configuration config)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.config = config;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</div><div class="line">        <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is not known to the MapperRegistry."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Error getting mapper instance. Cause: "</span> + e, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个类中有一个重要属性就是上面的Map，它持有着所有的MapperProxyFactory，而map的key就是我们传入的映射器的类型，比如上面定义的BlogMapper.class。</p>
<ol>
<li>通过传入的类型，从map中获取对应的MapperProxyFactory，如果map中没有，那么说明没有对应的映射类，直接抛出异常。这里是一个非常典型的工厂模式。</li>
<li>调用MapperProxyFactory类的newInstance方法，并且传入当前的sqlSession，生成一个映射器类的实例，即上面的BlogMapper的实例。</li>
</ol>
<h3 id="2-2、MapperProxyFactory"><a href="#2-2、MapperProxyFactory" class="headerlink" title="2.2、MapperProxyFactory"></a>2.2、MapperProxyFactory</h3><p>看一下MapperProxyFactory类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.apache.ibatis.binding;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxyFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;<span class="comment">//要代理的接口</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;Method, MapperMethod&gt;();<span class="comment">//接口中的方法与对应的SQL语句</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapperProxyFactory</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mapperInterface = mapperInterface;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getMapperInterface</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mapperInterface;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Method, MapperMethod&gt; <span class="title">getMethodCache</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> methodCache;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;,</div><div class="line">                mapperProxy);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);</div><div class="line">        <span class="keyword">return</span> newInstance(mapperProxy);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个类比较短，所以贴出了所有代码，从import中可以看出，这个类用到了Java中的动态代理。</p>
<p>这个类中包含了MyBatis的关键，利用动态代理技术来生成定义接口的代理对象，从而在调用对应方法的时候执行相应的SQL语句。</p>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>再来回忆一下动态代理的相关知识，涉及的两个关键的类就是Proxy与InvocationHandler</p>
<p>通过Proxy.newProxyInstance()方法可以创建动态代理，这个方法需要三个参数：</p>
<ul>
<li><p>类加载器：通过可以从已经被加载的对象中获取其类加载器并传递给它</p>
<p>上面使用的是mapperInterface.getClassLoader()来获取类加载器</p>
</li>
<li><p>希望该代理实现的接口列表(只能是接口，不能是类或抽象类)</p>
<p>上面使用的是new Class[] { mapperInterface }，即MapperProxyFactory要代理的接口</p>
</li>
</ul>
<ul>
<li><p>InvocationHandler接口的一个实现</p>
<p>上面用的是一个MapperProxy类的对象，该类实现了InvocationHandler接口。下面来看一下MapperProxy这个类。</p>
</li>
</ul>
<h3 id="2-3、MapperProxy"><a href="#2-3、MapperProxy" class="headerlink" title="2.3、MapperProxy"></a>2.3、MapperProxy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.apache.ibatis.binding;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.Serializable;</div><div class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandles;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.ibatis.lang.UsesJava7;</div><div class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.ExceptionUtil;</div><div class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6424540398559729838L</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSession;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapperProxy</span><span class="params">(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.sqlSession = sqlSession;</div><div class="line">        <span class="keyword">this</span>.mapperInterface = mapperInterface;</div><div class="line">        <span class="keyword">this</span>.methodCache = methodCache;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</div><div class="line">                <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123;</div><div class="line">                <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</div><div class="line">        <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> MapperMethod <span class="title">cachedMapperMethod</span><span class="params">(Method method)</span> </span>&#123;</div><div class="line">        MapperMethod mapperMethod = methodCache.get(method);</div><div class="line">        <span class="keyword">if</span> (mapperMethod == <span class="keyword">null</span>) &#123;</div><div class="line">            mapperMethod = <span class="keyword">new</span> MapperMethod(mapperInterface, method, sqlSession.getConfiguration());</div><div class="line">            methodCache.put(method, mapperMethod);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> mapperMethod;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@UsesJava</span>7</div><div class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">invokeDefaultMethod</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="keyword">final</span> Constructor&lt;MethodHandles.Lookup&gt; constructor = MethodHandles.Lookup.class</div><div class="line">                .getDeclaredConstructor(Class.class, <span class="keyword">int</span>.class);</div><div class="line">        <span class="keyword">if</span> (!constructor.isAccessible()) &#123;</div><div class="line">            constructor.setAccessible(<span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">final</span> Class&lt;?&gt; declaringClass = method.getDeclaringClass();</div><div class="line">        <span class="keyword">return</span> constructor.newInstance(declaringClass, MethodHandles.Lookup.PRIVATE)</div><div class="line">                .unreflectSpecial(method, declaringClass).bindTo(proxy).invokeWithArguments(args);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Backport of java.lang.reflect.Method#isDefault()</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDefaultMethod</span><span class="params">(Method method)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> ((method.getModifiers() &amp; (Modifier.ABSTRACT | Modifier.PUBLIC | Modifier.STATIC)) == Modifier.PUBLIC)</div><div class="line">                &amp;&amp; method.getDeclaringClass().isInterface();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>MapperProxy实现了InvocationHandler接口，所以肯定是用于动态代理的。</p>
<p>对于接口的所有方法调用，都会跳到它的invoke(Object proxy, Method method, Object[] args)</p>
<p>方法之中。它有三个参数：</p>
<ul>
<li>Object proxy：最终生成的代理实例。</li>
<li>Method method：是被代理目标实例的某个具体方法，通过它可以发起目标实例方法的反射调用；</li>
<li>Object[] args：是通过被代理实例某一个方法的入参，在方法反射调用时使用。</li>
</ul>
<p>在这个方法的具体实现中我们可以看到：</p>
<ol>
<li><p>首先判断调用被调用方法的getDeclaringClass()方法，该方法的作用为：</p>
<p>返回表示声明由此 Method 对象表示的方法的类或接口的 Class 对象。如果它与传入的Object对象相同，那么则直接调用，这块不是很理解。</p>
</li>
<li><p>再判断是不是isDefaultMethod，这个和上面第一次判断作用应该是差不多的，虽然不完全明白，但大概意思应该是一些没有映射的方法。</p>
</li>
<li><p>如果上面的判断都不满足，则需要代理执行映射的方法：</p>
<ol>
<li>首先获取缓存：MapperMethod mapperMethod = cachedMapperMethod(method);</li>
<li>在缓存中查找该方法，如果缓存中没有，就新建一个然后存入缓存中。</li>
<li>最终获得一个MapperMethod对象，最后的SQl语句就是通过这个类来执行的，下面来看一下这个类。</li>
</ol>
</li>
</ol>
<h3 id="2-4、MapperMethod"><a href="#2-4、MapperMethod" class="headerlink" title="2.4、MapperMethod"></a>2.4、MapperMethod</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.apache.ibatis.binding;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperMethod</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SqlCommand command;<span class="comment">//对应的SQL语句</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MethodSignature method;<span class="comment">//对应的方法</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapperMethod</span><span class="params">(Class&lt;?&gt; mapperInterface, Method method, Configuration config)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.command = <span class="keyword">new</span> SqlCommand(config, mapperInterface, method);</div><div class="line">        <span class="keyword">this</span>.method = <span class="keyword">new</span> MethodSignature(config, mapperInterface, method);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</div><div class="line">        Object result;</div><div class="line">        <span class="keyword">switch</span> (command.getType()) &#123;</div><div class="line">        <span class="keyword">case</span> INSERT: &#123;</div><div class="line">            Object param = method.convertArgsToSqlCommandParam(args);</div><div class="line">            result = rowCountResult(sqlSession.insert(command.getName(), param));</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> UPDATE: &#123;</div><div class="line">            Object param = method.convertArgsToSqlCommandParam(args);</div><div class="line">            result = rowCountResult(sqlSession.update(command.getName(), param));</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> DELETE: &#123;</div><div class="line">            Object param = method.convertArgsToSqlCommandParam(args);</div><div class="line">            result = rowCountResult(sqlSession.delete(command.getName(), param));</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> SELECT:</div><div class="line">            <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</div><div class="line">                executeWithResultHandler(sqlSession, args);</div><div class="line">                result = <span class="keyword">null</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</div><div class="line">                result = executeForMany(sqlSession, args);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</div><div class="line">                result = executeForMap(sqlSession, args);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</div><div class="line">                result = executeForCursor(sqlSession, args);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                Object param = method.convertArgsToSqlCommandParam(args);</div><div class="line">                result = sqlSession.selectOne(command.getName(), param);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> FLUSH:</div><div class="line">            result = sqlSession.flushStatements();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + command.getName());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Mapper method '"</span> + command.getName()</div><div class="line">                    + <span class="string">" attempted to return null from a method with a primitive return type ("</span> + method.getReturnType()</div><div class="line">                    + <span class="string">")."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//后面的全省略</span></div></pre></td></tr></table></figure>
<h4 id="关键属性"><a href="#关键属性" class="headerlink" title="关键属性"></a>关键属性</h4><p>这个类从最上面的两个常量中就可以看出，保存着我们定义的方法和它对应的SQl语句，也就是说我们在Mapper类中定义的每个接口的每个方法最后都会以MapperMethod的形式存在于内存之中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.mybatis.example;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlogMapper</span> </span>&#123;</div><div class="line">  <span class="meta">@Select</span>(<span class="string">"SELECT * FROM blog WHERE id = #&#123;id&#125;"</span>)</div><div class="line">  <span class="function">Blog <span class="title">selectBlog</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>一个接口中有着多个方法，而MapperMethod却是以方法为单位的，从构造函数中可以看出，我们定义的方法是以MethodSignature形式存在的，而它则由接口与方法名来共同标识</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.method = <span class="keyword">new</span> MethodSignature(config, mapperInterface, method);</div></pre></td></tr></table></figure>
<p>而且，一旦构造出来，就会存放在缓存中，下次再获取的时候先从缓存中获取，也就是说每个方法的MapperMethod都只会有一个。</p>
<h4 id="excute方法"><a href="#excute方法" class="headerlink" title="excute方法"></a>excute方法</h4><p>在上面MapperProxy中，以调用的方法为key，找到了对应的MapperMethod，然后就返回了MapperMethod的excute方法，也就是说调用的方法被动态代理后，通过这个excute方法来执行对应的SQl语句。</p>
<p>在调用的时候传入对应的SqlSession与参数，然后判断对应的SQL语句类型，将传入参数合成到最后的SQL语句中，并返回最终的执行结果。</p>
<p>至此，一个最简单的查询就分析完成了。</p>
<h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><h2 id="1、几个关键的类"><a href="#1、几个关键的类" class="headerlink" title="1、几个关键的类"></a>1、几个关键的类</h2><p>通过上面的分析，已经明白了我们的各种配置文件是怎么在MyBatis中存在的。</p>
<h3 id="1-1、Configuration类"><a href="#1-1、Configuration类" class="headerlink" title="1.1、Configuration类"></a>1.1、Configuration类</h3><p>首先我们通过XML文件对全局的所有配置，都是以Configuration类的形式存在的，并且通过DefaultSqlSessionFactory来持有它，通过源码可以发现，在每个生成的DefaultSqlSession中，也会持有这个Configuration。</p>
<h3 id="1-2、MapperProxy类"><a href="#1-2、MapperProxy类" class="headerlink" title="1.2、MapperProxy类"></a>1.2、MapperProxy类</h3><p>这个类有两点：</p>
<ul>
<li>它对应着我们定义的接口，比如上面的BlogMapper，保存着这个接口中定义的所有方法和方法对应的SQL语句</li>
<li>另一方面它实现了InvocationHandler接口，所以对接口的没法方法的调用都会在这个类的invoke方法中得到真正的执行</li>
</ul>
<h3 id="1-3、MapperMethod类"><a href="#1-3、MapperMethod类" class="headerlink" title="1.3、MapperMethod类"></a>1.3、MapperMethod类</h3><p>上面说MapperProxy类定义了一个接口中的所有方法和方法对应的SQL语句，而这个方法和方法对应的SQL语句就是通过MapperMethod来定义的，而且还负责这个方法具体的执行。</p>
<h2 id="2、查询过程"><a href="#2、查询过程" class="headerlink" title="2、查询过程"></a>2、查询过程</h2><p>再来看一下整个过程，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">String resource = <span class="string">"org/mybatis/example/mybatis-config.xml"</span>;</div><div class="line">InputStream inputStream = Resources.getResourceAsStream(resource);<span class="comment">//step1</span></div><div class="line">sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);<span class="comment">//step2</span></div><div class="line">SqlSession session = sqlSessionFactory.openSession();<span class="comment">//step3</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  BlogMapper mapper = session.getMapper(BlogMapper.class);<span class="comment">//step4</span></div><div class="line">  Blog blog = mapper.selectBlog(<span class="number">101</span>);<span class="comment">//step5</span></div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">  session.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大致分为以下几个步骤：</p>
<h3 id="2-1、获取SqlSessionFactoryBuilder"><a href="#2-1、获取SqlSessionFactoryBuilder" class="headerlink" title="2.1、获取SqlSessionFactoryBuilder"></a>2.1、获取SqlSessionFactoryBuilder</h3><p>该类没有属性，主要就是完成文件的定位</p>
<h3 id="2-2、获取SqlSessionFactory"><a href="#2-2、获取SqlSessionFactory" class="headerlink" title="2.2、获取SqlSessionFactory"></a>2.2、获取SqlSessionFactory</h3><ol>
<li>通过SqlSessionFactoryBuilder的build方法来实现XML文件的解析，并将配置信息生成一个对应的Configuration对象</li>
<li>生成一个SqlSessionFactory，保存对应的Configuration。</li>
</ol>
<p>以上两个步骤都是在最开始完成的，两个对象通常都是只要一个实例就足够了，而下面则需要每次查询都去生成。</p>
<h3 id="2-3、获取SqlSession"><a href="#2-3、获取SqlSession" class="headerlink" title="2.3、获取SqlSession"></a>2.3、获取SqlSession</h3><p>SqlSession对应着一次数据库的会话。所以想要对数据库进行操作，首先要获取一个SqlSession。</p>
<ol>
<li>先生成一个Excuter，它是最后的执行者，包含着执行此次会话的各种参数以及事务管理的各种方法</li>
<li>再将原来的Configuration的交给它持有。</li>
</ol>
<h3 id="2-4、获取Mapper"><a href="#2-4、获取Mapper" class="headerlink" title="2.4、获取Mapper"></a>2.4、获取Mapper</h3><p>从我们使用的角度，每个操作都是对应的接口的，而我们通过对接口中方法的调用完成对数据库的操作，首先就要获得这个接口的一个实现类，从源码中我们可以知道，实际生成的是这个接口的动态代理对象，也就是我们获取的这个Mapper。</p>
<ol>
<li>根据传入的接口类型，获取对应的MapperProxyFactory工厂。每个接口类型都有一个自己对应的工厂。</li>
<li>在工厂的newInstance方法，生成一个MapperProxy对象，这个对象对应着一个接口，并且通过一个map保存着该接口所有的方法和方法对应的SQL语句。</li>
<li>通过上面的MapperProxy来生成一个代理类的实例，因为它是InvocationHandler接口的实现，所以对代理类每个方法的调用都会在它的invoke方法中。</li>
</ol>
<h3 id="2-5、方法调用"><a href="#2-5、方法调用" class="headerlink" title="2.5、方法调用"></a>2.5、方法调用</h3><p>获取到代理对象后，就可以通过调用方法来执行对应的SQL语句了。</p>
<ol>
<li>通过动态代理，在MapperProxy的invoke方法中，找到对应的方法。</li>
<li>上面说了MapperProxy保存着这个接口中所有方法与对应的SQL语句，其实是通过一个MapperMethod的类来定义的。</li>
<li>找到方法对应的MapperMethod，并调用它的excute方法，执行对应的语句。</li>
</ol>
<h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><ol>
<li>世界上几乎所有的问题都可以用跳脱的想象力配合超凡的行动力来解决，以前一直想学习一下MyBatis，但就是下不了手，这次不知道是怎么了一鼓作气，用了一天时间就把源码看完了，另外一天写这篇文章</li>
<li>这是第一次完全自己看着源码分析的，因为网上相关的资料并不多，而且源码实现上也没有那么复杂。</li>
<li>里面涉及了两种设计模式：<ul>
<li>工厂模式：每个MapperProxy都对应自己的工厂</li>
<li>动态代理模式：以前不知道这个也是设计模式的一种，上次面试问到了竟然没有答上来，它最经典的例子应该就是AOP了。</li>
</ul>
</li>
</ol>
<h1 id="五、参考地址"><a href="#五、参考地址" class="headerlink" title="五、参考地址"></a>五、参考地址</h1><p><a href="http://www.mybatis.org/mybatis-3/zh/getting-started.html" target="_blank" rel="external">http://www.mybatis.org/mybatis-3/zh/getting-started.html</a></p>
<p><a href="http://blog.csdn.net/hupanfeng/article/details/9238127" target="_blank" rel="external">http://blog.csdn.net/hupanfeng/article/details/9238127</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中的枚举类型enum]]></title>
      <url>http://yoursite.com/2017/02/07/Java/Java%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8Benum/</url>
      <content type="html"><![CDATA[<p>枚举（enum）类型是Java 5新增的特性，它是一种新的类型，允许用常量来表示特定的数据片断，而且全部都以类型安全的形式来表示。<br>在JDK1.5之前，我们定义常量都是：public static fianl….。现在好了，有了枚举，可以把相关的常量分组到一个枚举类型里，而且枚举提供了比常量更多的方法。</p>
<p>虽然在开发过程中不经常使用，但还是要了解一下最基本的应用</p>
<h1 id="一、enum"><a href="#一、enum" class="headerlink" title="一、enum"></a>一、enum</h1><h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><p>下面以《Effective Java》书中的一个例子来说明，比如一个枚举类型，来表示计算器的四个基本运算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operation &#123;</div><div class="line">  PLUS, MINUS, TIMES, DIVIVE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建enum时，编译器会自动为我们生成一个继承自Java.lang.Enum的类，我们上面的enum可以简单看作下面的过程。当然在Java中是不能这样定义的，但是可以这样理解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Operation</span> <span class="keyword">extends</span> <span class="title">Enum</span></span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Operation PLUS;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Operation MINUS;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于上面的例子，我们可以把Operation看作一个类，而把PLUS, MINUS, TIMES, DIVIVE看作类的Operation的实例。<br>当然，这个构建实例的过程不是我们做的，一个enum的构造方法限制是private的，也就是不允许我们调用。</p>
<p>简单理解就是：我们创建了一种特殊的类，这个类的实例只有固定的几个，而且这些实例通过static final 声明为这个类的成员。</p>
<p>枚举类型也可以像正常类一样添加成员变量和方法</p>
<h2 id="2、属性"><a href="#2、属性" class="headerlink" title="2、属性"></a>2、属性</h2><p>比如操作的属性有一个符号属性，正如书中提到</p>
<blockquote>
<p>枚举类型天生就是不可变的，因此所有的域都应该为final的。它们可以是共有的，单最好将它们做成是私有的，并提供共有的访问方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operation &#123;</div><div class="line">  PLUS(<span class="string">"+"</span>), </div><div class="line">  MINUS(<span class="string">"-"</span>), </div><div class="line">  TIMES(<span class="string">"*"</span>), </div><div class="line">  DIVIVE(<span class="string">"/"</span>);</div><div class="line">  </div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String symbol;</div><div class="line">  </div><div class="line">  Operation(String symbol) &#123;</div><div class="line">    <span class="keyword">this</span>.symbol = symbol;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> symbol;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一般都是将属性声明为private final，这样就强制在新建枚举常量的时候初始化了。</p>
<h2 id="3、方法"><a href="#3、方法" class="headerlink" title="3、方法"></a>3、方法</h2><p>有一种方法可以将不同的行为与每个枚举常量关联起来：在枚举类型中声明一个抽象的方法，并且在特定于常量的类主体中，用每个具体的方法覆盖这个常量的抽象方法。</p>
<p>比如Operation类要有一个apply方法，用来计算，那么每操作对应的apply方法自然的不同的，就可以定义一个抽象方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operation &#123;</div><div class="line">  PLUS(<span class="string">"+"</span>) &#123;</div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</div><div class="line">  &#125;, </div><div class="line">  MINUS(<span class="string">"-"</span>) &#123;</div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x - y; &#125;</div><div class="line">  &#125;, </div><div class="line">  TIMES(<span class="string">"*"</span>) &#123;</div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x * y; &#125;</div><div class="line">  &#125;, </div><div class="line">  DIVIVE(<span class="string">"/"</span>) &#123;</div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x / y; &#125;</div><div class="line">  &#125;;</div><div class="line">  </div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String symbol;</div><div class="line">  </div><div class="line">  Operation(String symbol) &#123;</div><div class="line">    <span class="keyword">this</span>.symbol = symbol;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> symbol;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样做的好处就是，如果后面给Operation添加新的常量，就不可能忘记覆盖apply方法。</p>
<p>可以看出，通过成员变量声明为final和方法声明为abstract，保证了每个枚举常量的属性和方法都必须在最开始新建的时候就确定，并且不可改变。</p>
<h2 id="4、使用"><a href="#4、使用" class="headerlink" title="4、使用"></a>4、使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> hello.enumDemo;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operation &#123;</div><div class="line">  PLUS(<span class="string">"+"</span>) &#123;</div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</div><div class="line">  &#125;, </div><div class="line">  MINUS(<span class="string">"-"</span>) &#123;</div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x - y; &#125;</div><div class="line">  &#125;, </div><div class="line">  TIMES(<span class="string">"*"</span>) &#123;</div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x * y; &#125;</div><div class="line">  &#125;, </div><div class="line">  DIVIDE(<span class="string">"/"</span>) &#123;</div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x / y; &#125;</div><div class="line">  &#125;;</div><div class="line">  </div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String symbol;</div><div class="line">  </div><div class="line">  Operation(String symbol) &#123;</div><div class="line">    <span class="keyword">this</span>.symbol = symbol;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> symbol;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPLUS</span><span class="params">(Operation op)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> op.equals(Operation.PLUS);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showOperation</span><span class="params">(Operation op)</span> </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (op) &#123;</div><div class="line">      <span class="keyword">case</span> PLUS: </div><div class="line">        System.out.println(<span class="string">"I am PLUS"</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> MINUS: </div><div class="line">        System.out.println(<span class="string">"I am MINUS"</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> TIMES: </div><div class="line">        System.out.println(<span class="string">"I am TIMES"</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> DIVIDE: </div><div class="line">        System.out.println(<span class="string">"I am DIVIDE"</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">       <span class="keyword">default</span>:</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">double</span> x = <span class="number">0.1234</span>;</div><div class="line">    <span class="keyword">double</span> y = <span class="number">3.6789</span>;</div><div class="line">    <span class="keyword">for</span> (Operation op : Operation.values()) &#123;</div><div class="line">      System.out.printf(<span class="string">"%f %s %f = %f%n"</span>, x, op, y, op.apply(x, y));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    System.out.println(Operation.PLUS);<span class="comment">//+</span></div><div class="line">    System.out.println(isPLUS(Operation.PLUS));<span class="comment">//true</span></div><div class="line">    System.out.println(isPLUS(Operation.MINUS));<span class="comment">//false</span></div><div class="line">    showOperation(Operation.DIVIDE);<span class="comment">//I am DIVIDE</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">0.123400 + 3.678900 = 3.802300</div><div class="line">0.123400 - 3.678900 = -3.555500</div><div class="line">0.123400 * 3.678900 = 0.453976</div><div class="line">0.123400 / 3.678900 = 0.033543</div><div class="line">+</div><div class="line">true</div><div class="line">false</div><div class="line">I am DIVIDE</div></pre></td></tr></table></figure>
<p>可以看出枚举类型不光可以有实例方法，也可以有静态类方法。</p>
<p>还有就是values()方法，这是枚举类型自带的一个静态方法，按照声明顺序返回它的值数组。</p>
<h1 id="二、enum实现单例模式"><a href="#二、enum实现单例模式" class="headerlink" title="二、enum实现单例模式"></a>二、enum实现单例模式</h1><p>目前最为安全的实现单例的方法是通过内部静态enum的方法来实现，因为JVM会保证enum不能被反射并且构造器方法只执行一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSingleton</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">enum</span> Singleton&#123;</div><div class="line">        INSTANCE;</div><div class="line">        </div><div class="line">        <span class="keyword">private</span> EnumSingleton singleton;		</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</div><div class="line">            singleton=<span class="keyword">new</span> EnumSingleton();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> singleton;</div><div class="line">        &#125;		</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        EnumSingleton a=EnumSingleton.getInstance();</div><div class="line">        EnumSingleton b=EnumSingleton.getInstance();</div><div class="line">        System.out.println(a==b);<span class="comment">//true</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再来看一下enum的定义；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt;</span></div><div class="line">        <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span></div></pre></td></tr></table></figure>
<p>可以看到，枚举也提供了序列化机制。某些情况，比如我们要通过网络传输一个数据库连接的句柄，会提供很多帮助。<br>书中推荐这个方法：单元素的枚举类型已经成为实现Singleton的最佳方法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[笔试习题总结]]></title>
      <url>http://yoursite.com/2017/02/02/Java/%E7%AC%94%E8%AF%95%E4%B9%A0%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="一、JSP中静态include指令与动态include指令"><a href="#一、JSP中静态include指令与动态include指令" class="headerlink" title="一、JSP中静态include指令与动态include指令"></a>一、JSP中静态include指令与动态include指令</h1><h2 id="1、使用方法"><a href="#1、使用方法" class="headerlink" title="1、使用方法"></a>1、使用方法</h2><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;%@ page language="java" contentType="text/html; charset=gb2312"%&gt;</div><div class="line">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"&gt;</div><div class="line">&lt;title&gt;Insert title here&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">  &lt;!-- 静态 --&gt;</div><div class="line">&lt;%@include file="scriptlet.jsp" %&gt;</div><div class="line">  &lt;!-- 动态 --&gt;</div><div class="line">&lt;jsp:include page="scriptlet.jsp" /&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h2 id="2、区别"><a href="#2、区别" class="headerlink" title="2、区别"></a>2、区别</h2><ol>
<li>表达式的支持<ul>
<li>静态导入（include指令）通过file属性指定被包含的文件，且file属性不支持任何表达式</li>
<li>动态导入（include动作）通过page属性指定被包含的文件，且page属性支持JSP表达式</li>
</ul>
</li>
<li>编译方式<ul>
<li>使用静态导入（include指令）时，被包含的文件内容会原封不动的插入到包含页中，然后JSP编译器再将成后的文件最终编译成一个Java文件</li>
<li>使用动态导入（include动作）包含文件时，当该标识被执行时，程序会将请求转发（不是请求重定向）到被包含的页面，并将执行结果输出到浏览器中，然后返回包含页继续执行后面的代码。因为服务器执行的是多个文件，所以JSP编译器会分别对这些文件进行编译</li>
</ul>
</li>
<li>命名冲突<ul>
<li>静态导入使用include指令包含文件时，由于被包含的文件最终会生成一个文件，所以在被包含、包含文件中不能有重名的变量或方法</li>
<li>动态导入使用include动作包含文件时，由于每个文件是单独编译的，所以在被包含文件和包含文件中重名的变量和方法是不相冲突的</li>
</ul>
</li>
<li>导入方式<ul>
<li>静态导入是将被导入页面的代码完全融入，两个页面融合成一个整体Servlet，因此被导入页面甚至不需要是一个完整的页面</li>
<li>动态导入则在Servlet中使用include方法来引入被导入页面的内容</li>
</ul>
</li>
<li>编译指令<ul>
<li>静态导入时被导入页面的编译指令会起作用</li>
<li>动态导入时被导入页面的编译指令则失去作用，只是插入被导入页面的body内容</li>
</ul>
</li>
</ol>
<h1 id="二、Java基本语法"><a href="#二、Java基本语法" class="headerlink" title="二、Java基本语法"></a>二、Java基本语法</h1><h2 id="1、抽象类与接口的区别"><a href="#1、抽象类与接口的区别" class="headerlink" title="1、抽象类与接口的区别"></a>1、抽象类与接口的区别</h2><p><strong>抽象类</strong></p>
<p>特点:</p>
<p>1.抽象类中可以构造方法</p>
<p>2.抽象类中可以存在普通属性，方法，静态属性和方法。</p>
<p>3.抽象类中可以存在抽象方法。</p>
<p>4.如果一个类中有一个抽象方法，那么当前类一定是抽象类；抽象类中不一定有抽象方法。</p>
<p>5.抽象类中的抽象方法，需要有子类实现，如果子类不实现，则子类也需要定义为抽象的。</p>
<p><strong>接口</strong></p>
<p>1.在接口中只有方法的声明，没有方法体。</p>
<p>2.在接口中只有常量，因为定义的变量，在编译的时候都会默认加上</p>
<p>public static final </p>
<p>3.在接口中的方法，永远都被public来修饰。</p>
<p>4.接口中没有构造方法，也不能实例化接口的对象。</p>
<p>5.接口可以实现多继承</p>
<p>6.接口中定义的方法都需要有实现类来实现，如果实现类不能实现接口中的所有方法则实现类定义为抽象类。</p>
<h2 id="2、关于final的重要知识点"><a href="#2、关于final的重要知识点" class="headerlink" title="2、关于final的重要知识点;"></a>2、关于final的重要知识点;</h2><ol>
<li>final关键字可以用于成员变量、本地变量、方法以及类。</li>
<li>final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。</li>
<li>不能够对final变量再次赋值。final方法不能被重写。final类不能被继承。</li>
<li>本地变量必须在声明时赋值。</li>
<li>在匿名类中所有变量都必须是final变量。</li>
<li>没有在声明时初始化final变量的称为空白final变量(blank final variable)，它们必须在构造器中初始化，或者调用this()初始化。不这么做的话，编译器会报错“final变量(变量名)需要进行初始化”。</li>
</ol>
<h2 id="3、数据类型转换"><a href="#3、数据类型转换" class="headerlink" title="3、数据类型转换"></a>3、数据类型转换</h2><p>当使用 +、-、*、/、%、运算操作是，遵循如下规则：</p>
<ul>
<li>只要两个操作数中有一个是double类型的，另一个将会被转换成double类型，并且结果也是double类型。</li>
<li>如果两个操作数中有一个是float类型的，另一个将会被转换为float类型，并且结果也是float类型</li>
<li>如果两个操作数中有一个是long类型的，另一个将会被转换成long类型，并且结果也是long类型</li>
<li>否则（操作数为：byte、short、int 、char），两个数都会被转换成int类型，并且结果也是int类型。</li>
</ul>
<p>另外在Java中，给double类型的幅值直接写小数就可以，给float类型的幅值则需要加一个f：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">float</span> f=<span class="number">3.0f</span>;</div><div class="line"><span class="keyword">double</span> d=<span class="number">3.0</span>;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a=<span class="number">1</span>/<span class="number">3</span>;<span class="comment">//结果为int型，不需要转换</span></div><div class="line"><span class="keyword">float</span> b=<span class="number">1</span>/<span class="number">3.0f</span>;<span class="comment">//int与float操作，int转换为float型，结果也为float型</span></div><div class="line"><span class="keyword">float</span> c=(<span class="keyword">float</span>) (<span class="number">1</span>/<span class="number">3.0</span>);<span class="comment">//int与double操作，int转换为double型，结果也为double型，所以必须强制转换为flaot</span></div><div class="line"><span class="keyword">double</span> d=<span class="number">1</span>/<span class="number">3</span>;<span class="comment">//结果为int，自动转换为double</span></div><div class="line"><span class="keyword">double</span> e=<span class="number">1</span>/<span class="number">3.0f</span>;<span class="comment">//结果为float，自动转换为double</span></div><div class="line"><span class="keyword">double</span> f=<span class="number">1</span>/<span class="number">3.0</span>;<span class="comment">//结果为double，不需要转换</span></div></pre></td></tr></table></figure>
<h2 id="4、方法的重写（override）两同两小一大原则："><a href="#4、方法的重写（override）两同两小一大原则：" class="headerlink" title="4、方法的重写（override）两同两小一大原则："></a>4、方法的重写（override）两同两小一大原则：</h2><ul>
<li>方法名相同，参数类型相同</li>
<li>子类返回类型小于等于父类方法返回类型</li>
<li>子类抛出异常小于等于父类方法抛出异常</li>
<li>子类访问权限大于等于父类方法访问权限</li>
</ul>
<h2 id="5、重载"><a href="#5、重载" class="headerlink" title="5、重载"></a>5、重载</h2><p>重载的概念是：</p>
<p>方法名称相同，参数个数、次序、类型不同</p>
<p>因此重载对返回值类型没有要求，可以相同，也可以不同</p>
<p>但是如果参数的个数、类型、次序都相同，方法名也相同，仅返回值类型不同，则无法构成重载</p>
<h2 id="6、操作符优先级"><a href="#6、操作符优先级" class="headerlink" title="6、操作符优先级"></a>6、操作符优先级</h2><table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>结合性</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>() [] .</td>
<td>从左到右</td>
</tr>
<tr>
<td>2</td>
<td>! +(正)  -(负) ~ ++ –</td>
<td>从右向左</td>
</tr>
<tr>
<td>3</td>
<td>* / %</td>
<td>从左向右</td>
</tr>
<tr>
<td>4</td>
<td>+(加) -(减)</td>
<td>从左向右</td>
</tr>
<tr>
<td>5</td>
<td>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</td>
<td>从左向右</td>
</tr>
<tr>
<td>6</td>
<td>&lt; &lt;= &gt; &gt;= instanceof</td>
<td>从左向右</td>
</tr>
<tr>
<td>7</td>
<td>==   !=</td>
<td>从左向右</td>
</tr>
<tr>
<td>8</td>
<td>&amp;(按位与)</td>
<td>从左向右</td>
</tr>
<tr>
<td>9</td>
<td>^</td>
<td>从左向右</td>
</tr>
<tr>
<td>10</td>
<td>\</td>
<td></td>
<td>从左向右</td>
</tr>
<tr>
<td>11</td>
<td>&amp;&amp;</td>
<td>从左向右</td>
</tr>
<tr>
<td>12</td>
<td>\</td>
<td>\</td>
<td></td>
<td>从左向右</td>
</tr>
<tr>
<td>13</td>
<td>?:</td>
<td>从右向左</td>
</tr>
<tr>
<td>14</td>
<td>= += -= *= /= %= &amp;= \</td>
<td>= ^=  ~=  &lt;&lt;= &gt;&gt;=   &gt;&gt;&gt;=</td>
<td>从右向左</td>
</tr>
</tbody>
</table>
<h1 id="三、虚拟机参数配置"><a href="#三、虚拟机参数配置" class="headerlink" title="三、虚拟机参数配置"></a>三、虚拟机参数配置</h1><blockquote>
<p>-Xmx10240m -Xms10240m -Xmn5120m -XXSurvivorRatio=3,其最小内存值和Survivor区总大小分别是（）答案：10240m，2048m</p>
</blockquote>
<ul>
<li>-Xmx10240m：JVM最大可用内存为10240M。</li>
<li>-Xms10240m：JVM初始内存为10240M</li>
<li>-Xmn5120m：代表新生代</li>
<li>-XXSurvivorRatio=3：代表Eden:Survivor = 3。Eden:Survivor=3:1</li>
</ul>
<p>计算Survivor大小， Eden:Survivor = 3，总大小为5120,3x+x+x=5120  x=1024</p>
<h1 id="四、磁盘"><a href="#四、磁盘" class="headerlink" title="四、磁盘"></a>四、磁盘</h1><h2 id="1、磁道，扇区，柱面和磁头数"><a href="#1、磁道，扇区，柱面和磁头数" class="headerlink" title="1、磁道，扇区，柱面和磁头数"></a>1、磁道，扇区，柱面和磁头数</h2><ol>
<li><p>磁道：</p>
<p>当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道。这些磁道用肉眼是根本看不到的，因为它们仅是盘面上以特殊方式磁化了的一些磁化区，磁盘上的信息便是沿着这样的轨道存放的。相邻磁道之间并不是紧挨着的，这是因为磁化单元相隔太近时磁性会相互产生影响，同时也为磁头的读写带来困难。一张1.44MB的3.5英寸软盘，一面有80个磁道，而硬盘上的磁道密度则远远大于此值，通常一面有成千上万个磁道。</p>
</li>
<li><p>扇区：</p>
<p>磁盘上的每个磁道被等分为若干个弧段，这些弧段便是磁盘的扇区，每个扇区可以存放<strong>512个字节</strong>的信息，磁盘驱动器在向磁盘读取和写入数据时，要以扇区为单位。1.44MB3.5英寸的软盘，每个磁道分为18个扇区。</p>
</li>
<li><p>柱面：</p>
<p>硬盘通常由重叠的一组盘片构成，每个盘面都被划分为数目相等的磁道，并从外缘的“0”开始编号，具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面。磁盘的<strong>柱面数</strong>与一个盘面上的<strong>磁道数</strong>是相等的。由于每个盘面都有自己的磁头，因此，盘面数等于总的磁头数。所谓硬盘的CHS，即Cylinder（柱面）、Head（磁头）、Sector（扇区），只要知道了硬盘的CHS的数目，即可确定硬盘的容量</p>
<p>​</p>
</li>
</ol>
<p>硬盘的容量=柱面数*磁头数*扇区数*512B。</p>
<h2 id="2、簇"><a href="#2、簇" class="headerlink" title="2、簇"></a>2、簇</h2><p>“簇”是DOS进行分配的最小单位。当创建一个很小的文件时，如是一个字节，则它在磁盘上并不是只占一个字节的空间，而是占有整个一簇。DOS视不同的存储介质（如软盘，硬盘），不同容量的硬盘，簇的大小也不一样。簇的大小可在称为磁盘参数块（BPB）中获取。簇的概念仅适用于数据区。 </p>
<ol>
<li>簇是DOS进行分配的最小单位。 扇区是磁盘最小的物理存储单元。前者是逻辑上的概念</li>
<li>每个簇可以包括2、4、8、16、32或64个扇区。显然，簇是操作系统所使用的逻辑概念，而非磁盘的物理特性。</li>
<li>不同的存储介质，不同容量的硬盘，不同的DOS版本，簇的大小也不一样。 </li>
<li>簇的概念仅适用于数据区。 </li>
<li>为了更好地管理磁盘空间和更高效地从硬盘读取数据，操作系统规定一个簇中只能放置一个文件的内容，因此文件所占用的空间，只能是<strong>簇的整数倍</strong> ；而如果文件实际大小小于一簇，它也要占一簇的空间。所以，一般情况下文件所占空间要略大于文件的实际大小，只有在少数情况下，即文件的实际大小恰好是簇的整数倍时，文件的实际大小才会与所占空间完全一致。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中的访问权限]]></title>
      <url>http://yoursite.com/2017/01/23/Java/Java%E4%B8%AD%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/</url>
      <content type="html"><![CDATA[<p>虽然问题非常常见，但是越是简单的问题就越是容易被忽略，自己研究一下发现其实并没有完全掌握访问权限相关的知识。脱口而出的就是访问权限有四种修饰符，private、default、protected和public，其实严格来说这个说法是补不正确的。其实这四个修饰符是用来修饰类的成员的，而如果修饰类，则只有public和默认的两种。当然不包括内部类。</p>
<h2 id="1、类成员访问权限"><a href="#1、类成员访问权限" class="headerlink" title="1、类成员访问权限"></a>1、类成员访问权限</h2><p>在一个类的内部，其成员（包括成员变量和成员函数）能否被其他类所访问，取决于该成员的修饰词。Java的类成员访问权限修饰词有四类：</p>
<ul>
<li>public：对于public修饰符，它具有最大的访问权限，可以访问任何一个在CLASSPATH下的类、接口、异常等。它往往用于对外的情况，也就是对象或类对外的一种接口的形式。</li>
<li>protected：对于protected修饰符，它主要的作用就是用来保护子类的。它的含义在于子类可以用它修饰的成员，其他的不可以，它相当于传递给子类的一种继承的东西。</li>
<li>default：对于default来说，它是针对本包访问而设计的，任何处于本包下的类、接口、异常等，都可以相互访问，即使是父类没有用protected修饰的成员也可以。</li>
<li>private：对于private来说，它的访问权限仅限于类的内部，是一种封装的体现，例如，大多数的成员变量都是修饰符为private的，它们不希望被其他任何外部的类访问。</li>
</ul>
<p>下表为Java类成员访问控制符的含义和使用情况</p>
<table>
<thead>
<tr>
<th></th>
<th>类内部</th>
<th>本包</th>
<th>子类</th>
<th>外部包</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>default</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
<p>从表中可以看出，public到private是权限越来越高的，而横向看，类内部的权限最高，包外部权限最低，值得注意的一点就是本包的权限是高于子类的。所以，public和private的权限很好记，容易混淆的就是protected和default，本包和子类。要记住的就是默认情况下对本包开放而不对子类开放，使用了protected以后才可以对子类开放。这点可以联想到Spring中，很多方法需要子类重写的时候，都是用protected修饰的。</p>
<p>还有一点需要注意：Java的访问控制是停留在编译层的，也就是它不会在.class文件中留下任何的痕迹，只在编译的时候进行访问控制的检查。其实，通过反射的手段，是可以访问任何包下任何类中的成员，例如，访问类的私有成员也是可能的。</p>
<h2 id="2、类访问权限"><a href="#2、类访问权限" class="headerlink" title="2、类访问权限"></a>2、类访问权限</h2><p>类访问权限只有public或者default两种，default也就是包内可以访问。</p>
<p>当然这不包括内部类，因为内部类应该属于类的成员。所以访问权限也应该遵循上面的类成员访问权限。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[操作系统中的调度算法]]></title>
      <url>http://yoursite.com/2017/01/19/OperatingSystem/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>面试中常见的几个问题就是操作系统中的磁盘调度算法、内存调度算法以及进程调度算法，它们之间是有区别的。</p>
<h1 id="一、磁盘调度算法"><a href="#一、磁盘调度算法" class="headerlink" title="一、磁盘调度算法"></a>一、磁盘调度算法</h1><p>磁盘是可供多个进程共享的设备，当有多个进程都要求访问磁盘时，应采用一种最佳调度算法，以使各进程对磁盘的平均访问时间最小。由于在访问磁盘的时间中，主要是寻道时间。因此： <strong>磁盘调度算法的目标是使磁盘的平均寻道时间最少</strong></p>
<h2 id="1、磁盘调度算法"><a href="#1、磁盘调度算法" class="headerlink" title="1、磁盘调度算法"></a>1、磁盘调度算法</h2><p>磁盘调度算法有：</p>
<ol>
<li><p>FIFO：先来先服务算法</p>
<p>先进先出的调度策略，这个策略具有公平的优点，因为每个请求都会得到处理，并且是按照接收到的顺序进行处理</p>
</li>
<li><p>SSTF：最短寻道时间优先</p>
<p>选择使磁头从当前位置开始移动最少的磁盘I/O请求，所以SSTF总是选择导致最小寻道时间的请求</p>
</li>
<li><p>SCAN：扫描算法/电梯算法</p>
<p>SCAN要求磁头仅仅沿一个方向移动，并在途中满足所有未完成的请求，知道它到达这个方向上的最后一个磁道，或者在这个方向上没有其他请求为止</p>
</li>
<li><p>C-SCAN：循环扫描算法</p>
<p>把扫描限定在一个方向，当访问到某个方向的最后一个磁道时，磁道返回磁盘相反方向磁道的末端，并再次开始扫描。</p>
</li>
</ol>
<h2 id="2、举例"><a href="#2、举例" class="headerlink" title="2、举例"></a>2、举例</h2><p>磁头当前位置：125。</p>
<p>等待：86，147，1，77，4，50，02，75，30</p>
<p>下面看一下不同调度算法下的访问顺序：</p>
<ol>
<li><p>FIFO：先来先服务算法</p>
<p>​</p>
</li>
<li><p>SSTF：最短寻道时间优先</p>
<p>​</p>
</li>
<li><p>SCAN：扫描算法/电梯算法</p>
<p>​</p>
</li>
<li><p>C-SCAN：循环扫描算法</p>
<p>​</p>
</li>
</ol>
<h1 id="二、内存调度算法"><a href="#二、内存调度算法" class="headerlink" title="二、内存调度算法"></a>二、内存调度算法</h1><h2 id="1、页面置换"><a href="#1、页面置换" class="headerlink" title="1、页面置换"></a>1、页面置换</h2><p>页面置换：在地址映射过程中，若在页面中发现所要访问的页面不再内存中，则产生缺页中断(page fault)。当发生缺页中断时操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。</p>
<p>典型的置换算法有以下四种：</p>
<ol>
<li><p>OPT：最佳替换算法（Optional Replacement）。</p>
<p>替换下次访问距当前时间最长的页。opt算法需要知道操作系统将来的事件，显然不可能实现，只作为一种衡量其他算法的标准。</p>
</li>
<li><p>LRU：最近最少使用(Least Recently Used).</p>
<p>替换上次使用距离当前最远的页。根据局部性原理：替换最近最不可能 访问到的页。性能最接近OPT，但难以实现。可以维护一个关于访问页的栈或者给每个页添加最后访问的时间标签，但开销都很大。</p>
</li>
<li><p>FIFO：先进先出(First In First Out)</p>
<p>将页面看做一个循环缓冲区，按循环方式替换。这是实现最为简单的算法，隐含的逻辑是替换驻留在内存时间最长的页。但由于一部分程序或数据在整个程序的生命周期中使用频率很高，所以会导致反复的换入换出。</p>
</li>
<li><p>Clock：时钟替换算法（Clock）</p>
<p>给每个页帧关联一个使用位。当该页第一次装入内存或者被重新访问到时，将使用位置为1。每次需要替换时，查找使用位被置为0的第一个帧进行替换。在扫描过程中，如果碰到使用位为1的帧，将使用位置为0，在继续扫描。如果所谓帧的使用位都为0，则替换第一个帧。</p>
</li>
</ol>
<h1 id="三、进程调度算法"><a href="#三、进程调度算法" class="headerlink" title="三、进程调度算法"></a>三、进程调度算法</h1><h2 id="1、进程调度与作业调度"><a href="#1、进程调度与作业调度" class="headerlink" title="1、进程调度与作业调度"></a>1、进程调度与作业调度</h2><p>进程调度是真正让某个就绪状态的进程到处理机上运行，而作业调度只是使作业具有了竞争处理机的机会。</p>
<ul>
<li>进程调度（又称微观调度、低级调度、短程调度）：是按照某种调度算法从就绪状态的进程中选择一个进程到处理机上运行。负责进程调度功能的内核程序称为进程调度程序。</li>
<li>作业调度（又称高级调度、宏观调度、长程调度）：是按某种调度算法从后备作业队列中选择作业装入内存运行；另外当该作业执行完毕后，还负责回收系统资源。完成作业调度功能的程序称为作业调度程序。</li>
</ul>
<h2 id="2、调度算法"><a href="#2、调度算法" class="headerlink" title="2、调度算法"></a>2、调度算法</h2><ol>
<li><p>FIFO：先进先出算法</p>
<ul>
<li>该算法既可用于作业调度， 也可用于进程调度。</li>
<li>按照进程进入就绪队列的先后次序来选择。即每当进入进程调度，总是把就绪队列的队首进程投入运行。</li>
<li>这种调度算法有利于长作业（进程），不利于短作业（进程）。有利于CPU繁忙型的作业，不利于I/O繁忙型的作业。</li>
</ul>
</li>
<li><p>SPN：短作业（进程）优先调度算法</p>
<ul>
<li>该算法既可用于作业调度， 也可用于进程调度</li>
<li>最短进程优先，下一次选择所需处理时间最短的进程</li>
<li>可以有效地降低作业的平均等待时间，提高系统吞吐量。</li>
<li>不能保证紧迫性作业（进程）被及时处理；作业的长短只是被估算出来的。</li>
</ul>
</li>
<li><p>SRT：最短剩余时间优先，总是选择预期剩余时间最短的进程</p>
</li>
<li><p>高优先权优先调度</p>
<ul>
<li>可用于作业调度，也可用于进程调度</li>
<li>分为抢占式优先权调度和非抢占式优先权调度</li>
<li>根据优先权的类型分为静态优先权，动态优先权</li>
<li>静态优先权是在创建进程时确定的，且在进程的整个运行过程期间保持不变。</li>
<li>动态优先权是指在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的。</li>
</ul>
</li>
<li><p>HRRN：最高响应比优先，</p>
<ul>
<li>优先权 = 响应时间 / 服务时间</li>
<li>这种算法既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务，实现了一种较好的折中。但是，每次进行调度时，都需先做响应比的计算，增加了系统开销。</li>
</ul>
</li>
<li><p>轮转：时间片轮转法</p>
<ul>
<li>系统将所有的就绪进程按先来先服务的原则，排成一个队列，每次调度时，把CPU分配给队首进程,并令其执行一个时间片。</li>
<li>当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾。</li>
<li>然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程,在一给定的时间内,均能获得一时间片的处理机执行时间。</li>
</ul>
</li>
<li><p>多级反馈队列调度：</p>
<ul>
<li>设置多个队列，各个队列优先级和时间片长短都不同，优先级由高到低，时间片长短逐渐增长，</li>
<li>当一个新进程进入内存后，首先将它放在第一队列的队尾，按照FCFS原则排队等待调度。当轮到该进程执行时，如果能在该时间片内完成，则准备撤离系统，否则将该进程转入到第二队列的队尾，以此类推。</li>
<li>仅当第一队列空闲时，调度程序才调度第二队列中的进程，以此类推。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先级更高的队列，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回第i队列的末尾，把处理机分配给新到的高优先级进程。</li>
</ul>
<p>​</p>
</li>
</ol>
<h1 id="四、参考地址"><a href="#四、参考地址" class="headerlink" title="四、参考地址"></a>四、参考地址</h1><p><a href="http://blog.csdn.net/pi9nc/article/details/19848831" target="_blank" rel="external">http://blog.csdn.net/pi9nc/article/details/19848831</a></p>
<p><a href="http://blog.csdn.net/luyafei_89430/article/details/12971171" target="_blank" rel="external">http://blog.csdn.net/luyafei_89430/article/details/12971171</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux中的sed命令]]></title>
      <url>http://yoursite.com/2017/01/18/OperatingSystem/Linux%E4%B8%AD%E7%9A%84sed%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h1 id="一、195-Tenth-Line"><a href="#一、195-Tenth-Line" class="headerlink" title="一、195. Tenth Line"></a>一、195. Tenth Line</h1><p>How would you print just the 10th line of a file?</p>
<p>For example, assume that <code>file.txt</code> has the following content:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Line 1</div><div class="line">Line 2</div><div class="line">Line 3</div><div class="line">Line 4</div><div class="line">Line 5</div><div class="line">Line 6</div><div class="line">Line 7</div><div class="line">Line 8</div><div class="line">Line 9</div><div class="line">Line 10</div></pre></td></tr></table></figure>
<p>Your script should output the tenth line, which is:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Line 10</div></pre></td></tr></table></figure>
<h1 id="二、sed"><a href="#二、sed" class="headerlink" title="二、sed"></a>二、sed</h1><p>sed是一个很好的文件处理工具，本身是一个管道命令，主要是以行为单位进行处理，可以将数据行进行替换、删除、新增、选取等特定工作，下面先了解一下sed的用法</p>
<h2 id="1、命令格式"><a href="#1、命令格式" class="headerlink" title="1、命令格式"></a>1、命令格式</h2><p> sed [-nefri] ‘command’ 输入文本        </p>
<h2 id="2、常用选项"><a href="#2、常用选项" class="headerlink" title="2、常用选项"></a>2、常用选项</h2><ul>
<li>-n∶使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN的资料一般都会被列出到萤幕上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。</li>
<li>-e∶直接在指令列模式上进行 sed 的动作编辑；</li>
<li>-f∶直接将 sed 的动作写在一个档案内， -f filename 则可以执行 filename 内的sed 动作；</li>
<li>-r∶sed 的动作支援的是延伸型正规表示法的语法。(预设是基础正规表示法语法)</li>
<li>-i∶直接修改读取的档案内容，而不是由萤幕输出。       </li>
</ul>
<h2 id="3、常用命令"><a href="#3、常用命令" class="headerlink" title="3、常用命令"></a>3、常用命令</h2><ul>
<li>a∶新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</li>
<li>c∶取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</li>
<li>d∶删除，因为是删除啊，所以 d 后面通常不接任何咚咚；</li>
<li>i∶插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</li>
<li>p∶列印，亦即将某个选择的资料印出。通常 p 会与参数 sed -n 一起运作～</li>
<li>s∶取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！</li>
</ul>
<h2 id="4、答案"><a href="#4、答案" class="headerlink" title="4、答案"></a>4、答案</h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中的动态代理]]></title>
      <url>http://yoursite.com/2017/01/16/Java/Java%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      <content type="html"><![CDATA[<p>JDK 1.3以后，Java提供了动态代理的技术，允许开发者在运行期创建接口的代理实例。在Sun刚推出动态代理时，还很难想象它有多大的实际用途，现在我们终于发现动态代理是实现AOP的绝好底层技术。 </p>
<p>JDK的动态代理主要涉及到java.lang.reflect包中的两个类：</p>
<ul>
<li>Proxy</li>
<li>InvocationHandler。</li>
</ul>
<p>其中InvocationHandler是一个接口，可以通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态将横切逻辑和业务逻辑编织在一起。 </p>
<h1 id="一、JDK的动态代理"><a href="#一、JDK的动态代理" class="headerlink" title="一、JDK的动态代理"></a>一、JDK的动态代理</h1><p>使用JDK创建代理有一个限制，即它只能为接口创建代理实例。下面写个小例子来验证一下。</p>
<h2 id="1、被代理的接口和实现类"><a href="#1、被代理的接口和实现类" class="headerlink" title="1、被代理的接口和实现类"></a>1、被代理的接口和实现类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> hello.proxy;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomthing</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomthingElse</span><span class="params">(String s)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealObject</span> <span class="keyword">implements</span> <span class="title">Interface</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomthing</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"something"</span>);			</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomthingElse</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"donthingElse: "</span>+s);			</div><div class="line">    &#125;	</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyDemo</span> </span>&#123;		</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">(Interface iface)</span></span>&#123;</div><div class="line">        iface.doSomthing();</div><div class="line">        iface.doSomthingElse(<span class="string">"lalala"</span>);		</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Interface real=<span class="keyword">new</span> RealObject();</div><div class="line">        consumer(real);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">something</div><div class="line">donthingElse: lalala</div></pre></td></tr></table></figure>
<p>这是一个很简单的逻辑，如果需要在这个业务逻辑上面增加其他的横切逻辑，并且不需要在业务逻辑中增加代码，你们就需要用到动态代理。</p>
<h2 id="2、Proxy与InvocationHandler"><a href="#2、Proxy与InvocationHandler" class="headerlink" title="2、Proxy与InvocationHandler"></a>2、Proxy与InvocationHandler</h2><p>改动代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//被代理的接口</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomthing</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomthingElse</span><span class="params">(String s)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//接口的实现类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealObject</span> <span class="keyword">implements</span> <span class="title">Interface</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomthing</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"something"</span>);			</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomthingElse</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"donthingElse: "</span>+s);			</div><div class="line">    &#125;	</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//InvocationHandler接口的实现</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</div><div class="line">    Object proxied;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxyHandler</span><span class="params">(Object proxied)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.proxied=proxied;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        System.out.println(<span class="string">"****proxy: "</span>+proxy.getClass()+</div><div class="line">                <span class="string">", method: "</span>+method+</div><div class="line">                <span class="string">", args: "</span>+Arrays.toString(args));</div><div class="line">        <span class="keyword">return</span> method.invoke(proxied, args);</div><div class="line">    &#125;		</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyDemo</span> </span>&#123;		</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">(Interface iface)</span></span>&#123;</div><div class="line">        iface.doSomthing();</div><div class="line">        iface.doSomthingElse(<span class="string">"lalala"</span>);		</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Interface real=<span class="keyword">new</span> RealObject();</div><div class="line">        consumer(real);</div><div class="line">        Interface proxy=(Interface) Proxy.newProxyInstance(real.getClass().getClassLoader(), real.getClass().getInterfaces(), <span class="keyword">new</span> DynamicProxyHandler(real));</div><div class="line">        consumer(proxy);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">something</div><div class="line">donthingElse: lalala</div><div class="line">****proxy: class hello.proxy.$Proxy0, method: public abstract void hello.proxy.Interface.doSomthing(), args: null</div><div class="line">something</div><div class="line">****proxy: class hello.proxy.$Proxy0, method: public abstract void hello.proxy.Interface.doSomthingElse(java.lang.String), args: [lalala]</div><div class="line">donthingElse: lalala</div></pre></td></tr></table></figure>
<p>可以发现，在不改动原来代码的基础上实现了横切逻辑的实现。涉及的两个关键的类就是Proxy与InvocationHandler。</p>
<p>通过Proxy.newProxyInstance()方法可以创建动态代理，这个方法需要三个参数：</p>
<ul>
<li>类加载器：通过可以从已经被加载的对象中获取其类加载器并传递给它</li>
<li>希望该代理实现的接口列表(只能是接口，不能是类或抽象类)</li>
<li>InvocationHandler接口的一个实现</li>
</ul>
<p>动态代理可以将所有调用重定向到调用处理器，因此通常会向调用处理器的构造器传递一个“实际”对象的引用，从而使得调用处理器在执行其中介任务时，可以请求转发。</p>
<p>调用处理器就是InvocationHandler接口，该接口定义了一个 invoke(Object proxy, Method method, Object[] args)的方法：</p>
<ul>
<li>proxy是最终生成的代理实例，一般不会用到；</li>
<li>method是被代理目标实例的某个具体方法，通过它可以发起目标实例方法的反射调用；</li>
<li>args是通过被代理实例某一个方法的入参，在方法反射调用时使用。 </li>
</ul>
<h1 id="二、CGLib"><a href="#二、CGLib" class="headerlink" title="二、CGLib"></a>二、CGLib</h1><h2 id="1、CGLib"><a href="#1、CGLib" class="headerlink" title="1、CGLib"></a>1、CGLib</h2><p>JDK的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理，cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</div><div class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</div><div class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoSomethingImp</span> <span class="keyword">implements</span> <span class="title">Interface</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomthing</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"something"</span>);			</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomthingElse</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"donthingElse: "</span>+s);			</div><div class="line">    &#125;	</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Enhancer enhancer = <span class="keyword">new</span> Enhancer();  </div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Class clazz)</span> </span>&#123;  </div><div class="line">        enhancer.setSuperclass(clazz); <span class="comment">//① 设置需要创建子类的类  </span></div><div class="line">        enhancer.setCallback(<span class="keyword">this</span>);   </div><div class="line">        <span class="keyword">return</span> enhancer.create(); <span class="comment">//②通过字节码技术动态创建子类实例     </span></div><div class="line">    &#125;      </div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        </div><div class="line">        System.out.println(<span class="string">"开始"</span>);</div><div class="line">        proxy.invokeSuper(obj, args);  </div><div class="line">        System.out.println(<span class="string">"结束"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;	</div><div class="line">    &#125;	</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibDemo</span> </span>&#123;	</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">(Interface iface)</span></span>&#123;</div><div class="line">        iface.doSomthing();</div><div class="line">        iface.doSomthingElse(<span class="string">"lalala"</span>);		</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Interface real=<span class="keyword">new</span> DoSomethingImp();</div><div class="line">        consumer(real);</div><div class="line">        CglibProxy cglib=<span class="keyword">new</span> CglibProxy();  </div><div class="line">        DoSomethingImp bookCglib=(DoSomethingImp)cglib.getProxy(DoSomethingImp.class);  </div><div class="line">        consumer(bookCglib);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">something</div><div class="line">donthingElse: lalala</div><div class="line">开始</div><div class="line">something</div><div class="line">结束</div><div class="line">开始</div><div class="line">donthingElse: lalala</div><div class="line">结束</div></pre></td></tr></table></figure>
<p>有一点需要注意的就是CGLib需要额外的导入jar包，第一次导入cglib-2.1.3.jar后发现运行有异常，解决办法就是下载并导入cglib-nodep-2.1_3.jar然后删除cglib-2.1.3.jar，这样就可以正确运行了。</p>
<h2 id="2、JDK与CGLib"><a href="#2、JDK与CGLib" class="headerlink" title="2、JDK与CGLib"></a>2、JDK与CGLib</h2><p>JDK动态代理所创建的代理对象，在JDK 1.3下，性能强差人意。虽然在高版本的JDK中，动态代理对象的性能得到了很大的提高，但是有研究表明，CGLib所创建的动态代理对象的性能依旧比JDK的所创建的代理对象的性能高不少（大概10倍）。但CGLib在创建代理对象时所花费的时间却比JDK动态代理多（大概8倍），所以对于singleton的代理对象或者具有实例池的代理，因为无须频繁创建代理对象，所以比较适合用CGLib动态代理技术，反之适合用JDK动态代理技术。</p>
<p>值得一提的是，<strong>由于CGLib采用动态创建子类的方式生成代理对象，所以不能对目标类中的final方法进行代理。 </strong> </p>
<h1 id="三、参考地址"><a href="#三、参考地址" class="headerlink" title="三、参考地址"></a>三、参考地址</h1><p><a href="http://www.iteye.com/topic/1123293" target="_blank" rel="external">http://www.iteye.com/topic/1123293</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring基础知识（三）：AOP]]></title>
      <url>http://yoursite.com/2017/01/16/spring/Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(3)AOP/</url>
      <content type="html"><![CDATA[<h1 id="一、AOP"><a href="#一、AOP" class="headerlink" title="一、AOP"></a>一、AOP</h1><h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><p>AOP（Aspect Oriented Programming），即面向切面编程。</p>
<p>可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p>
<p>AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</p>
<p>使用”横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点</p>
<ul>
<li>核心关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。</li>
<li>横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</li>
</ul>
<h2 id="2、核心概念"><a href="#2、核心概念" class="headerlink" title="2、核心概念"></a>2、核心概念</h2><ol>
<li><p>横切关注点</p>
<p>对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点</p>
</li>
<li><p>切面（aspect）</p>
<p>类是对物体特征的抽象，切面就是对横切关注点的抽象</p>
</li>
<li><p>连接点（joinpoint）</p>
<p>被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器</p>
</li>
<li><p>切入点（pointcut）</p>
<p>对连接点进行拦截的定义</p>
</li>
<li><p>通知（advice）</p>
<p>所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类</p>
</li>
<li><p>目标对象</p>
<p>代理的目标对象</p>
</li>
<li><p>织入（weave）</p>
<p>将切面应用到目标对象并导致代理对象创建的过程</p>
</li>
<li><p>引入（introduction）</p>
<p>在不修改代码的前提下，引入可以在<strong>运行期</strong>为类动态地添加一些方法或字段</p>
</li>
</ol>
<h1 id="二、Spring对AOP的支持"><a href="#二、Spring对AOP的支持" class="headerlink" title="二、Spring对AOP的支持"></a>二、Spring对AOP的支持</h1>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux中的grep命令]]></title>
      <url>http://yoursite.com/2017/01/13/OperatingSystem/Linux%E4%B8%AD%E7%9A%84grep%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>leetcode中有几道关于命令行的问题，学习了一下</p>
<h1 id="一、leetcode-193-Valid-Phone-Numbers"><a href="#一、leetcode-193-Valid-Phone-Numbers" class="headerlink" title="一、leetcode: 193. Valid Phone Numbers"></a>一、leetcode: 193. Valid Phone Numbers</h1><p>Given a text file <code>file.txt</code> that contains list of phone numbers (one per line), write a one liner bash script to print all valid phone numbers.</p>
<p>You may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit)</p>
<p>You may also assume each line in the text file must not contain leading or trailing white spaces.</p>
<p>For example, assume that <code>file.txt</code> has the following content:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">987-123-4567</div><div class="line">123 456 7890</div><div class="line">(123) 456-7890</div></pre></td></tr></table></figure>
<p>Your script should output the following valid phone numbers:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">987-123-4567</div><div class="line">(123) 456-7890</div></pre></td></tr></table></figure>
<h1 id="二、grep"><a href="#二、grep" class="headerlink" title="二、grep"></a>二、grep</h1><p>grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。</p>
<p>Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p>
<ul>
<li>grep在数据中查找一个字符串时，是以“整行”为单位进行数据筛选的。</li>
<li>pattern如果是表达式或者超过两个单词的, 需要用引号引用. 可以是单引号也可双引号, 区别是单引号无法引用变量而双引号可以.</li>
</ul>
<h2 id="1、基本用法"><a href="#1、基本用法" class="headerlink" title="1、基本用法"></a>1、基本用法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep [option] &apos;搜索字符串&apos; filename</div></pre></td></tr></table></figure>
<p>常用选项：</p>
<ul>
<li>c：只输出匹配行的计数。</li>
<li>I：不区分大小写(只适用于单字符)。</li>
<li>h：查询多文件时不显示文件名。</li>
<li>l：查询多文件时只输出包含匹配字符的文件名。</li>
<li>n：显示匹配行及行号。</li>
<li>s：不显示不存在或无匹配文本的错误信息。</li>
<li>v：显示不包含匹配文本的所有行。</li>
</ul>
<p>pattern正则表达式主要参数：</p>
<ul>
<li>\： 忽略正则表达式中特殊字符的原有含义。</li>
<li>^：匹配正则表达式的开始行。</li>
<li>$: 匹配正则表达式的结束行。</li>
<li>\&lt;：从匹配正则表达式的行开始。</li>
<li>\&gt;：到匹配正则表达式的行结束。</li>
<li>[ ]：单个字符，如[A]即A符合要求 。</li>
<li>[ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。</li>
<li>.：所有的单个字符。</li>
<li>*：有字符，长度可以为0。</li>
</ul>
<h2 id="2、应用"><a href="#2、应用" class="headerlink" title="2、应用"></a>2、应用</h2><p>grep ‘\<tom\>‘ file   包含单词Tom的行<br>grep ‘Tom savage’ file 包含Tom savage的行<br>grep ‘^Tommy’ file 包含以Tommy开头的行<br>grep ‘.bak$’ file 包含以.bak结束的行<br>grep ‘[Pp]yramid’ file 包含pyramid 或Pyramid的单词的行<br>grep ‘[A-Z]’ file 包含至少一个大写字母的行<br>grep ‘[0-9]’ file 包含至少一个数字的行<br>grep ‘[A-Z]…[0-9]’ file 包含五个字符,以大写开头, 和一个数字结尾的行.<br>grep -w ‘[tT]est’ file 包含单词和test的行.<br>grep -s ‘ken sun’ file 找到包含ken sun的行, 但不打印行, 而是用来检查退出状态.<br>grep -v aaa file 打印不包含aaa的行.<br>grep -i cathy file 打印所有包含cathy的行, 而不考虑大小些.<br>grep -l ‘dear cathy’ * 打印包含dear cathy的文件的文件名清单.<br>grep -n tom file   打印匹配的行并追加行号.<br>grep “$LOGNAME” file 包含变量内容的行, 注意必须用双引号, 单引号则无法引用变量.<br>grep ‘$name’ file 打印包含字符\$name的行.</tom\></p>
<h2 id="3、leetcode答案"><a href="#3、leetcode答案" class="headerlink" title="3、leetcode答案"></a>3、leetcode答案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep &apos;^\(([0-9]\&#123;3\&#125;) \|[0-9]\&#123;3\&#125;-\)[0-9]\&#123;3\&#125;-[0-9]\&#123;4\&#125;$&apos; file.txt</div></pre></td></tr></table></figure>
<h1 id="三、egrep"><a href="#三、egrep" class="headerlink" title="三、egrep"></a>三、egrep</h1><h2 id="1、基本用法-1"><a href="#1、基本用法-1" class="headerlink" title="1、基本用法"></a>1、基本用法</h2><p>egrep = grep -E 可以使用基本的正则表达外, 还可以用扩展表达式. 注意区别.</p>
<p>扩展表达式:</p>
<ul>
<li>匹配一个或者多个先前的字符, 至少一个先前字符.</li>
<li>? 匹配0个或者多个先前字符.</li>
<li>a|b|c 匹配a或b或c</li>
<li>() 字符组, 如: love(able|ers) 匹配loveable或lovers.</li>
<li>(..)(..)\1\2 模板匹配. \1代表前面第一个模板, \2代第二个括弧里面的模板.</li>
<li>x{m,n} =x{m,n} x的字符数量在m到n个之间.</li>
</ul>
<h2 id="2、应用-1"><a href="#2、应用-1" class="headerlink" title="2、应用"></a>2、应用</h2><p>egrep ‘^+’ file   以一个或者多个空格开头的行.<br>grep ‘^<em>‘ file   同上<br>egrep ‘(TOM|DAN) SAVAGE’ file 包含 TOM SAVAGE 和DAN SAVAGE的行.<br>egrep ‘(ab)+’ file 包含至少一个ab的行.<br>egrep ‘x[0-9]?’ file 包含x或者x后面跟着0个或者多个数字的行.<br>egrep ‘fun.$’ </em> 所有文件里面以fun.结尾的行.<br>egrep ‘[A-Z]+’ file 至少包含一个大写字母的行.<br>egrep ‘[0-9]’ file 至少一个数字的行.<br>egrep ‘[A-Z]…[0-9]’ file 有五个字符, 第一个式大写, 最后一个是数字的行.<br>egrep ‘[tT]est’ file 包含单词test或Test的行.<br>egrep ‘ken sun’ file 包含ken sun的行.<br>egrep -v ‘marry’ file 不包含marry的行.<br>egrep -i ‘sam’ file 不考虑sam的大小写,含有sam的行.<br>egrep -l “dear ken” * 包含dear ken的所有文件的清单.<br>egrep -n tom file 包含tom的行, 每行前面追加行号.<br>egrep -s “$name” file 找到变量名\$name的, 不打印而是显示退出状态. 0表示找到. 1表示表达式没找到符合要求的, 2表示文件没找到.</p>
<h2 id="3、leetcode答案-1"><a href="#3、leetcode答案-1" class="headerlink" title="3、leetcode答案"></a>3、leetcode答案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">grep &apos;^\(([0-9]\&#123;3\&#125;) \|[0-9]\&#123;3\&#125;-\)[0-9]\&#123;3\&#125;-[0-9]\&#123;4\&#125;$&apos; file.txt</div><div class="line">grep -E &apos;^([0-9]&#123;3&#125;-|\([0-9]&#123;3&#125;\) )[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$&apos; file.txt </div><div class="line">egrep &apos;^([0-9]&#123;3&#125;-|\([0-9]&#123;3&#125;\) )[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$&apos; file.txt</div></pre></td></tr></table></figure>
<p>两个都可以，可以看出和基本正则的区别。</p>
<p><a href="http://www.cnblogs.com/end/archive/2012/02/21/2360965.html" target="_blank" rel="external">http://www.cnblogs.com/end/archive/2012/02/21/2360965.html</a></p>
<p><a href="http://blog.csdn.net/newthinker_wei/article/details/8219293" target="_blank" rel="external">http://blog.csdn.net/newthinker_wei/article/details/8219293</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SpringMVC（三）：DispatcherServlet请求转发的实现]]></title>
      <url>http://yoursite.com/2017/01/11/spring/SpringMVC(3)DispatcherServlet%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>上一篇介绍的是init初始化过程，这次继续研究Servlet生命周期中的第二部分，service方法，在“service”阶段中，每一次Http请求到来，容器都会启动一个请求线程，通过service()方法，委派到doGet()或者doPost()这些方法，完成Http请求的处理。</p>
<h1 id="一、HttpServlet"><a href="#一、HttpServlet" class="headerlink" title="一、HttpServlet"></a>一、HttpServlet</h1><p>首先看一下HttpServlet中的service方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></div><div class="line">    <span class="keyword">throws</span> ServletException, IOException</div><div class="line">&#123;</div><div class="line">    String method = req.getMethod();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</div><div class="line">        <span class="keyword">long</span> lastModified = getLastModified(req);</div><div class="line">        <span class="keyword">if</span> (lastModified == -<span class="number">1</span>) &#123;</div><div class="line">            <span class="comment">// servlet doesn't support if-modified-since, no reason</span></div><div class="line">            <span class="comment">// to go through further expensive logic</span></div><div class="line">            doGet(req, resp);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">long</span> ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);</div><div class="line">            <span class="keyword">if</span> (ifModifiedSince &lt; lastModified) &#123;</div><div class="line">                <span class="comment">// If the servlet mod time is later, call doGet()</span></div><div class="line">                <span class="comment">// Round down to the nearest second for a proper compare</span></div><div class="line">                <span class="comment">// A ifModifiedSince of -1 will always be less</span></div><div class="line">                maybeSetLastModified(resp, lastModified);</div><div class="line">                doGet(req, resp);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</div><div class="line">        <span class="keyword">long</span> lastModified = getLastModified(req);</div><div class="line">        maybeSetLastModified(resp, lastModified);</div><div class="line">        doHead(req, resp);</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_POST)) &#123;</div><div class="line">        doPost(req, resp);</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_PUT)) &#123;</div><div class="line">        doPut(req, resp);</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_DELETE)) &#123;</div><div class="line">        doDelete(req, resp);</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_OPTIONS)) &#123;</div><div class="line">        doOptions(req,resp);</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_TRACE)) &#123;</div><div class="line">        doTrace(req,resp);</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//</span></div><div class="line">        <span class="comment">// Note that this means NO servlet supports whatever</span></div><div class="line">        <span class="comment">// method was requested, anywhere on this server.</span></div><div class="line">        <span class="comment">//</span></div><div class="line"></div><div class="line">        String errMsg = lStrings.getString(<span class="string">"http.method_not_implemented"</span>);</div><div class="line">        Object[] errArgs = <span class="keyword">new</span> Object[<span class="number">1</span>];</div><div class="line">        errArgs[<span class="number">0</span>] = method;</div><div class="line">        errMsg = MessageFormat.format(errMsg, errArgs);</div><div class="line">        </div><div class="line">        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据不同的请求，它们分别被不同的方法处理。</p>
<h1 id="二、FrameworkServlet"><a href="#二、FrameworkServlet" class="headerlink" title="二、FrameworkServlet"></a>二、FrameworkServlet</h1><p>在FrameworkServlet中，处理各种请求的方法都被重写，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Delegate GET requests to processRequest/doService.</div><div class="line"> * &lt;p&gt;Will also be invoked by HttpServlet's default implementation of &#123;<span class="doctag">@code</span> doHead&#125;,</div><div class="line"> * with a &#123;<span class="doctag">@code</span> NoBodyResponse&#125; that just captures the content length.</div><div class="line"> * <span class="doctag">@see</span> #doService</div><div class="line"> * <span class="doctag">@see</span> #doHead</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></div><div class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line"></div><div class="line">    processRequest(request, response);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Delegate POST requests to &#123;<span class="doctag">@link</span> #processRequest&#125;.</div><div class="line"> * <span class="doctag">@see</span> #doService</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></div><div class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line"></div><div class="line">    processRequest(request, response);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Delegate PUT requests to &#123;<span class="doctag">@link</span> #processRequest&#125;.</div><div class="line"> * <span class="doctag">@see</span> #doService</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPut</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></div><div class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line"></div><div class="line">    processRequest(request, response);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Delegate DELETE requests to &#123;<span class="doctag">@link</span> #processRequest&#125;.</div><div class="line"> * <span class="doctag">@see</span> #doService</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doDelete</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></div><div class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line"></div><div class="line">    processRequest(request, response);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，这些方法都同意的调用了processRequest方法，而没有进行特殊的处理，注意一点这些方法都是final的，不会再被重写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Process this request, publishing an event regardless of the outcome.</div><div class="line"> * &lt;p&gt;The actual event handling is performed by the abstract</div><div class="line"> * &#123;<span class="doctag">@link</span> #doService&#125; template method.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></div><div class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line"></div><div class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</div><div class="line">    Throwable failureCause = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();</div><div class="line">    LocaleContext localeContext = buildLocaleContext(request);</div><div class="line"></div><div class="line">    RequestAttributes previ eousAttributes = RequestContextHolder.getRequestAttributes();</div><div class="line">    ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);</div><div class="line"></div><div class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</div><div class="line">    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class="keyword">new</span> RequestBindingInterceptor());</div><div class="line"></div><div class="line">    initContextHolders(request, localeContext, requestAttributes);</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        doService(request, response);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (ServletException ex) &#123;</div><div class="line">        failureCause = ex;</div><div class="line">        <span class="keyword">throw</span> ex;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">        failureCause = ex;</div><div class="line">        <span class="keyword">throw</span> ex;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">        failureCause = ex;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NestedServletException(<span class="string">"Request processing failed"</span>, ex);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">finally</span> &#123;</div><div class="line">        resetContextHolders(request, previousLocaleContext, previousAttributes);</div><div class="line">        <span class="keyword">if</span> (requestAttributes != <span class="keyword">null</span>) &#123;</div><div class="line">            requestAttributes.requestCompleted();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">            <span class="keyword">if</span> (failureCause != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">this</span>.logger.debug(<span class="string">"Could not complete request"</span>, failureCause);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</div><div class="line">                    logger.debug(<span class="string">"Leaving response open for concurrent processing"</span>);</div><div class="line">                   &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">this</span>.logger.debug(<span class="string">"Successfully completed request"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        publishRequestHandledEvent(request, response, startTime, failureCause);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></div><div class="line">        <span class="keyword">throws</span> Exception;</div></pre></td></tr></table></figure>
<p>整体上分为三个部分：</p>
<ol>
<li>处理前的准备</li>
<li>doService(request, response);进行处理</li>
<li>处理完成后的工作</li>
</ol>
<h2 id="1、处理过程"><a href="#1、处理过程" class="headerlink" title="1、处理过程"></a>1、处理过程</h2><p>这部分有些地方和网上看见的或者书上看见的源码都不一样，应该是新版本进行了改进：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">     LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();</div><div class="line">     LocaleContext localeContext = buildLocaleContext(request);</div><div class="line"></div><div class="line">     RequestAttributes previ eousAttributes = RequestContextHolder.getRequestAttributes();</div><div class="line">     ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);</div><div class="line"></div><div class="line">     WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</div><div class="line">     asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class="keyword">new</span> RequestBindingInterceptor());</div><div class="line"></div><div class="line">     initContextHolders(request, localeContext, requestAttributes);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initContextHolders</span><span class="params">(</span></span></div><div class="line">        HttpServletRequest request, LocaleContext localeContext, RequestAttributes requestAttributes) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (localeContext != <span class="keyword">null</span>) &#123;</div><div class="line">        LocaleContextHolder.setLocaleContext(localeContext, <span class="keyword">this</span>.threadContextInheritable);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (requestAttributes != <span class="keyword">null</span>) &#123;</div><div class="line">        RequestContextHolder.setRequestAttributes(requestAttributes, <span class="keyword">this</span>.threadContextInheritable);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</div><div class="line">        logger.trace(<span class="string">"Bound request context to thread: "</span> + request);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过大体的思路还是一样的，这里涉及几个关键的类和变量：</p>
<ul>
<li>LocaleContext和RequestAttributes：</li>
<li>LocaleContextHolder和RequestContextHolder，持有上面的两个对象，通过get获得，处理之后通过set设置</li>
</ul>
<p>下面看一下这两个holder对应的抽象类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LocaleContextHolder</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;LocaleContext&gt; localeContextHolder =</div><div class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"LocaleContext"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;LocaleContext&gt; inheritableLocaleContextHolder =</div><div class="line">            <span class="keyword">new</span> NamedInheritableThreadLocal&lt;&gt;(<span class="string">"LocaleContext"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 下面的省略  </span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestContextHolder</span>  </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> jsfPresent =</div><div class="line">            ClassUtils.isPresent(<span class="string">"javax.faces.context.FacesContext"</span>, RequestContextHolder.class.getClassLoader());</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;RequestAttributes&gt; requestAttributesHolder =</div><div class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Request attributes"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;RequestAttributes&gt; inheritableRequestAttributesHolder =</div><div class="line">            <span class="keyword">new</span> NamedInheritableThreadLocal&lt;&gt;(<span class="string">"Request context"</span>);</div><div class="line">  	<span class="comment">// 下面的省略  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>他们内部都包含有ThreadLocal对象，所以，就可以知道整个过程的作用就是分别将这两个东西和请求线程做了绑定。</p>
<ol>
<li><p>为了保证当前线程的LocaleContext和RequestAttributes可以在当前请求后还能恢复，提取当前线程的两个属性</p>
</li>
<li><p>根据当前的request创建对应的LocaleContext和RequestAttributes，并绑定到当前线程。</p>
</li>
<li><p>doService(request, response)方法，按照一贯套路，肯定又是在子类中重写</p>
</li>
<li><p>请求处理结束后恢复线程到原始状态</p>
</li>
<li><p>请求处理结束后无论成功与否都发布事件通知。每次请求处理结束后，容器上下文都发布了一个ServletRequestHandledEvent事件，可以注册监听器来监听该事件。</p>
<p>​</p>
</li>
</ol>
<p>可以看到，processRequest()方法只是做了一些线程安全的隔离，真正的请求处理，发生在doService()方法中。</p>
<h1 id="三、DispatcherServlet"><a href="#三、DispatcherServlet" class="headerlink" title="三、DispatcherServlet"></a>三、DispatcherServlet</h1><h2 id="1、doService"><a href="#1、doService" class="headerlink" title="1、doService"></a>1、doService</h2><p>doService方法在DispatcherServlet中被重写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Exposes the DispatcherServlet-specific request attributes and delegates to &#123;<span class="doctag">@link</span> #doDispatch&#125;</div><div class="line"> * for the actual dispatching.</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">        String resumed = WebAsyncUtils.getAsyncManager(request).hasConcurrentResult() ? <span class="string">" resumed"</span> : <span class="string">""</span>;</div><div class="line">        logger.debug(<span class="string">"DispatcherServlet with name '"</span> + getServletName() + <span class="string">"'"</span> + resumed +</div><div class="line">                <span class="string">" processing "</span> + request.getMethod() + <span class="string">" request for ["</span> + getRequestUri(request) + <span class="string">"]"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Keep a snapshot of the request attributes in case of an include,</span></div><div class="line">    <span class="comment">// to be able to restore the original attributes after the include.</span></div><div class="line">    Map&lt;String, Object&gt; attributesSnapshot = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</div><div class="line">        attributesSnapshot = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</div><div class="line">        <span class="keyword">while</span> (attrNames.hasMoreElements()) &#123;</div><div class="line">            String attrName = (String) attrNames.nextElement();</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.cleanupAfterInclude || attrName.startsWith(<span class="string">"org.springframework.web.servlet"</span>)) &#123;</div><div class="line">                attributesSnapshot.put(attrName, request.getAttribute(attrName));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Make framework objects available to handlers and view objects.</span></div><div class="line">    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</div><div class="line">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.localeResolver);</div><div class="line">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.themeResolver);</div><div class="line">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</div><div class="line"></div><div class="line">    FlashMap inputFlashMap = <span class="keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</div><div class="line">    <span class="keyword">if</span> (inputFlashMap != <span class="keyword">null</span>) &#123;</div><div class="line">        request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</div><div class="line">    &#125;</div><div class="line">    request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> FlashMap());</div><div class="line">    request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="keyword">this</span>.flashMapManager);</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        doDispatch(request, response);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</div><div class="line">            <span class="comment">// Restore the original attribute snapshot, in case of an include.</span></div><div class="line">            <span class="keyword">if</span> (attributesSnapshot != <span class="keyword">null</span>) &#123;</div><div class="line">                restoreAttributesAfterInclude(request, attributesSnapshot);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>几个requet.setAttribute()方法的调用，将前面在初始化流程中实例化的对象设置到http请求的属性中，供下一步处理使用，其中有容器的上下文对象、本地化解析器等SpringMVC特有的编程元素。不同于Struts2中的ValueStack，SpringMVC的数据并没有从HttpServletRequest对象中抽离出来再存进另外一个编程元素，这也跟SpringMVC的设计思想有关。因为从一开始，SpringMVC的设计者就认为，不应该将请求处理过程和Web容器完全隔离。</p>
<h2 id="2、doDispatch"><a href="#2、doDispatch" class="headerlink" title="2、doDispatch"></a>2、doDispatch</h2><p>接下来让我们看看doDispatch()这个整个请求转发流程中最核心的方法。DispatcherServlet所接收的Http请求，经过层层转发，最终都是汇总到这个方法中来进行最后的请求分发和处理。doDispatch()这个方法的内容，就是SpringMVC整个框架的精华所在。它通过高度抽象的接口，描述出了一个MVC（Model-View-Controller）设计模式的实现方案。Model、View、Controller三种层次的编程元素，在SpringMVC中都有大量的实现类，各种处理细节也是千差万别。但是，它们最后都是由，也都能由doDispatch()方法来统一描述，这就是接口和抽象的威力，万变不离其宗。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Process the actual dispatching to the handler.</div><div class="line"> * &lt;p&gt;The handler will be obtained by applying the servlet's HandlerMappings in order.</div><div class="line"> * The HandlerAdapter will be obtained by querying the servlet's installed HandlerAdapters</div><div class="line"> * to find the first that supports the handler class.</div><div class="line"> * &lt;p&gt;All HTTP methods are handled by this method. It's up to HandlerAdapters or handlers</div><div class="line"> * themselves to decide which methods are acceptable.</div><div class="line"> * <span class="doctag">@param</span> request current HTTP request</div><div class="line"> * <span class="doctag">@param</span> response current HTTP response</div><div class="line"> * <span class="doctag">@throws</span> Exception in case of any kind of processing failure</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    HttpServletRequest processedRequest = request;</div><div class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        ModelAndView mv = <span class="keyword">null</span>;</div><div class="line">        Exception dispatchException = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          	<span class="comment">//step1</span></div><div class="line">            processedRequest = checkMultipart(request);</div><div class="line">            multipartRequestParsed = (processedRequest != request);</div><div class="line"></div><div class="line">          	<span class="comment">//step2</span></div><div class="line">            <span class="comment">// Determine handler for the current request.</span></div><div class="line">            mappedHandler = getHandler(processedRequest);</div><div class="line">          	<span class="comment">//step3</span></div><div class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</div><div class="line">                noHandlerFound(processedRequest, response);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">          	<span class="comment">//step4</span></div><div class="line">            <span class="comment">// Determine handler adapter for the current request.</span></div><div class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</div><div class="line"></div><div class="line">          	<span class="comment">//step5</span></div><div class="line">            <span class="comment">// Process last-modified header, if supported by the handler.</span></div><div class="line">            String method = request.getMethod();</div><div class="line">            <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</div><div class="line">            <span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</div><div class="line">                <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</div><div class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">                    logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">          	<span class="comment">//step6</span></div><div class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">          	<span class="comment">//step7</span></div><div class="line">            <span class="comment">// Actually invoke the handler.</span></div><div class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            applyDefaultViewName(processedRequest, mv);</div><div class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">            dispatchException = ex;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">catch</span> (Throwable err) &#123;</div><div class="line">            <span class="comment">// As of 4.3, we're processing Errors thrown from handler methods as well,</span></div><div class="line">            <span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></div><div class="line">            dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, err);</div><div class="line">        &#125;</div><div class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (Throwable err) &#123;</div><div class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler,</div><div class="line">                <span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</div><div class="line">            <span class="comment">// Instead of postHandle and afterCompletion</span></div><div class="line">            <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</div><div class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// Clean up any resources used by a multipart request.</span></div><div class="line">            <span class="keyword">if</span> (multipartRequestParsed) &#123;</div><div class="line">                cleanupMultipart(processedRequest);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对应步骤：</p>
<ol>
<li>对MultipartContent类型的Request处理</li>
<li>根据request信息寻找对应的Handler</li>
<li>没找到对应的Handler的错误处理</li>
<li>感觉当前Handler寻找对应的HandlerAdapter</li>
<li>缓存处理</li>
<li>HandlerInterceptor的处理</li>
<li>逻辑处理</li>
<li>异常视图处理</li>
<li>根据视图跳转页面</li>
</ol>
<p>下面主要分析几个关键的步骤</p>
<h1 id="三、doDispatch"><a href="#三、doDispatch" class="headerlink" title="三、doDispatch"></a>三、doDispatch</h1><p>这个过程有几个问题不太明白再详细研究一下。</p>
<p>首先就是关于自己定义的Controller是怎么被执行的，这个要先明白Controller的定义方式，最原始的MVC的做法就是继承Controller接口，当然更高级的就是使用@Controller和@RequestMapping注解。这里先从Controller接口的方法分析，因为这个比较简单。定义一个bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeAction</span> <span class="keyword">implements</span> <span class="title">Controller</span></span>&#123;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest request,  </span></span></div><div class="line">            HttpServletResponse response) <span class="keyword">throws</span> Exception &#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"hello"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="1、HandlerMapping和HandlerAdapter"><a href="#1、HandlerMapping和HandlerAdapter" class="headerlink" title="1、HandlerMapping和HandlerAdapter"></a>1、HandlerMapping和HandlerAdapter</h2><p>下面再来回顾一下SpringMVC处理请求的流程</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/spring/11.png?raw=true" alt=""></p>
<p>用过python Django框架的都知道Django对于访问方式的配置就是，一个url路径和一个函数配对，你访问这个url，就会直接调用这个函数，简单明了。对于java的面向对象来说，就要分两步走。</p>
<ol>
<li>第一步首先要找到是哪个对象，即handler，本工程的handler则是HomeAction对象。</li>
<li>第二步要找到访问的函数，即HomeAction的handleRequest方法。</li>
</ol>
<p>所以就出现了两个接口HandlerMapping和HandlerAdapter，前者负责第一步，后者负责第二步</p>
<p>HandlerMapping的实现类：</p>
<ul>
<li>BeanNameUrlHandlerMapping：通过对比url和bean的name找到对应的对象 </li>
<li>SimpleUrlHandlerMapping ：也是直接配置url和对应bean，比BeanNameUrlHandlerMapping功能更多 </li>
<li>RequestMappingHandlerMapping ：主要是针对注解配置@RequestMapping的，取代了最早的DefaultAnnotationHandlerMapping </li>
</ul>
<p>HandlerAdapter的实现类:</p>
<ul>
<li><p>SimpleControllerHandlerAdapter：要求handler实现Controller接口，该接口的方法为</p>
<blockquote>
<p>ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response)，</p>
</blockquote>
<p>也就是上面例子所采用的</p>
</li>
</ul>
<ul>
<li><p>HttpRequestHandlerAdapter ： 要求handler实现HttpRequestHandler接口，该接口的方法为：</p>
<blockquote>
<p>void handleRequest(HttpServletRequest request, HttpServletResponse response)</p>
</blockquote>
<p>也就是 handler必须有一个handleRequest方法                                                     </p>
</li>
<li><p>RequestMappingHandlerAdapter : 和上面的RequestMappingHandlerMapping配对使用，针对@RequestMapping，取代了最早的AnnotationMethodHandlerAdapter。</p>
</li>
</ul>
<p>先简单的说下这个工程的流程，访问<a href="http://localhost:8080/index首先由DispatcherServlet进行转发，通过BeanNameUrlHandlerMapping(含有" target="_blank" rel="external">http://localhost:8080/index首先由DispatcherServlet进行转发，通过BeanNameUrlHandlerMapping(含有</a> /index-&gt;HomeAction的配置)，找到了HomeAction,然后再拿HomeAction和每个adapter进行适配，由于HomeAction实现了Controller接口，所以最终会有SimpleControllerHandlerAdapter来完成对HomeAction的handleRequest方法的调度。然后就顺利的执行了我们想要的方法。</p>
<p>了解了这些实现之后，再来看一下在源码中的实现。</p>
<h2 id="2、HandlerExecutionChain的获取"><a href="#2、HandlerExecutionChain的获取" class="headerlink" title="2、HandlerExecutionChain的获取"></a>2、HandlerExecutionChain的获取</h2><h3 id="2-1、getHandler方法"><a href="#2-1、getHandler方法" class="headerlink" title="2.1、getHandler方法"></a>2.1、getHandler方法</h3><p>该过程对应的就是这一句</p>
<blockquote>
<p>mappedHandler = getHandler(processedRequest);</p>
</blockquote>
<p>相关的类在第一篇文章中已经介绍过了，有几点必须清楚：</p>
<ol>
<li><p>HandlerMapping是一个接口，DispatcherServlet中持有一个List&lt; HandlerMapping&gt;</p>
</li>
<li><p>获取HandlerExecutionChain的过程就是DispatcherServlet遍历这个List&lt; HandlerMapping&gt;的过程，并将第一个返回结果不为null作为得到的HandlerExecutionChain</p>
</li>
<li><p>上面的说法这个步骤叫作Handler的获取，但其实这个类是HandlerExecutionChain，只不过变量名与handler有关，真正的handler是封装在HandlerExecutionChain里面的。</p>
<blockquote>
<p>HandlerExecutionChain mappedHandler = null;</p>
</blockquote>
</li>
</ol>
<p>下面看一下具体的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">for</span> (HandlerMapping hm : <span class="keyword">this</span>.handlerMappings) &#123;</div><div class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</div><div class="line">            logger.trace(</div><div class="line">                    <span class="string">"Testing handler map ["</span> + hm + <span class="string">"] in DispatcherServlet with name '"</span> + getServletName() + <span class="string">"'"</span>);</div><div class="line">        &#125;</div><div class="line">        HandlerExecutionChain handler = hm.getHandler(request);</div><div class="line">        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> handler;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个就是对应的遍历过程，而hm.getHandler(request)方法是在HandlerMapping接口中定义的，也就是说遍历的这个List中的所有实现类的对象都有这个方法，</p>
<h3 id="2-2、BeanNameUrlHandlerMapping类与getHandler方法"><a href="#2-2、BeanNameUrlHandlerMapping类与getHandler方法" class="headerlink" title="2.2、BeanNameUrlHandlerMapping类与getHandler方法"></a>2.2、BeanNameUrlHandlerMapping类与getHandler方法</h3><p>BeanNameUrlHandlerMapping是前面提到的默认加载的HandlerMapping之一，来看一下它的类继承关系，</p>
<p> <img src="https://github.com/paine1690/HelloWorld/blob/master/pic/spring/5.png?raw=true" alt=""></p>
<p>它的父父父类AbstractHandlerMapping实现了HandlerMapping接口，所以在这里可以看见对HandlerMapping接口方法getHandler的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHandlerMapping</span> <span class="keyword">extends</span> <span class="title">WebApplicationObjectSupport</span> <span class="keyword">implements</span> <span class="title">HandlerMapping</span>, <span class="title">Ordered</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 上面的都省略</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Look up a handler for the given request, falling back to the default</div><div class="line">     * handler if no specific one is found.</div><div class="line">     * <span class="doctag">@param</span> request current HTTP request</div><div class="line">     * <span class="doctag">@return</span> the corresponding handler instance, or the default handler</div><div class="line">     * <span class="doctag">@see</span> #getHandlerInternal</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">      	<span class="comment">//1.根据request信息查找对应的handler</span></div><div class="line">        Object handler = getHandlerInternal(request);</div><div class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</div><div class="line">            handler = getDefaultHandler();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// Bean name or resolved handler?</span></div><div class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</div><div class="line">            String handlerName = (String) handler;</div><div class="line">            handler = getApplicationContext().getBean(handlerName);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//2.加入拦截器到执行链</span></div><div class="line">        HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);</div><div class="line">        <span class="keyword">if</span> (CorsUtils.isCorsRequest(request)) &#123;</div><div class="line">            CorsConfiguration globalConfig = <span class="keyword">this</span>.globalCorsConfigSource.getCorsConfiguration(request);</div><div class="line">            CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);</div><div class="line">            CorsConfiguration config = (globalConfig != <span class="keyword">null</span> ? globalConfig.combine(handlerConfig) : handlerConfig);</div><div class="line">            executionChain = getCorsHandlerExecutionChain(request, executionChain, config);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> executionChain;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">  </div><div class="line">  	<span class="comment">//2.加入拦截器到执行链具体实现</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandlerExecutionChain</span><span class="params">(Object handler, HttpServletRequest request)</span></span>&#123;</div><div class="line">        HandlerExecutionChain chain = (handler <span class="keyword">instanceof</span> HandlerExecutionChain ?</div><div class="line">                (HandlerExecutionChain) handler : <span class="keyword">new</span> HandlerExecutionChain(handler));</div><div class="line"></div><div class="line">        String lookupPath = <span class="keyword">this</span>.urlPathHelper.getLookupPathForRequest(request);</div><div class="line">        <span class="keyword">for</span> (HandlerInterceptor interceptor : <span class="keyword">this</span>.adaptedInterceptors) &#123;</div><div class="line">            <span class="keyword">if</span> (interceptor <span class="keyword">instanceof</span> MappedInterceptor) &#123;</div><div class="line">                MappedInterceptor mappedInterceptor = (MappedInterceptor) interceptor;</div><div class="line">                <span class="keyword">if</span> (mappedInterceptor.matches(lookupPath, <span class="keyword">this</span>.pathMatcher)) &#123;</div><div class="line">                    chain.addInterceptor(mappedInterceptor.getInterceptor());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                chain.addInterceptor(interceptor);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> chain;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法是final的，说明子类不会再重写，根据代码可以看出，该方法主要分两步：</p>
<ol>
<li><p>根据request信息查找对应的handler</p>
<p>这个gethandlerInternal方法主要就是根据url来获取对应的Handler，并且最后返回的handler是一个Object类型的对象。</p>
</li>
<li><p>加入拦截器到执行链</p>
<p>前面介绍过HandlerExecutionChain中，封装了一个handler和n个拦截器，所以在找到对应的handler之后还要加入相应的拦截器。最后封装成HandlerExecutionChain。</p>
</li>
</ol>
<p>经过两个步骤，实现根据输入的request到返回HandlerExecutionChain的过程。</p>
<h2 id="3、HandlerAdapter的获取"><a href="#3、HandlerAdapter的获取" class="headerlink" title="3、HandlerAdapter的获取"></a>3、HandlerAdapter的获取</h2><h3 id="3-1、getHandlerAdapter方法"><a href="#3-1、getHandlerAdapter方法" class="headerlink" title="3.1、getHandlerAdapter方法"></a>3.1、getHandlerAdapter方法</h3><p>该过程对应的是这句</p>
<blockquote>
<p>HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</p>
</blockquote>
<p>与上面的方法非常类似，也是遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Return the HandlerAdapter for this handler object.</div><div class="line"> * <span class="doctag">@param</span> handler the handler object to find an adapter for</div><div class="line"> * <span class="doctag">@throws</span> ServletException if no HandlerAdapter can be found for the handler. This is a fatal error.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> HandlerAdapter <span class="title">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">    <span class="keyword">for</span> (HandlerAdapter ha : <span class="keyword">this</span>.handlerAdapters) &#123;</div><div class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</div><div class="line">            logger.trace(<span class="string">"Testing handler adapter ["</span> + ha + <span class="string">"]"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (ha.supports(handler)) &#123;</div><div class="line">            <span class="keyword">return</span> ha;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"No adapter for handler ["</span> + handler +</div><div class="line">            <span class="string">"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>遍历所有的HandlerAdapter,判断他们是否支持这个handler。 这里还是要找到默认配置中三个HandlerAdapter实现类中的一个，SimpleControllerHandlerAdapter，它要求handler实现Controller接口。</p>
<h3 id="3-2、SimpleControllerHandlerAdapter类"><a href="#3-2、SimpleControllerHandlerAdapter类" class="headerlink" title="3.2、SimpleControllerHandlerAdapter类"></a>3.2、SimpleControllerHandlerAdapter类</h3><p>因为它和HttpRequestHandlerAdapter的代码都不长，所以就一起贴出来了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.web.servlet.mvc;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleControllerHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</div><div class="line">      	<span class="comment">//就是判断handler是否实现了Controller接口  </span></div><div class="line">        <span class="keyword">return</span> (handler <span class="keyword">instanceof</span> Controller);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></div><div class="line">            <span class="keyword">throws</span> Exception &#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> ((Controller) handler).handleRequest(request, response);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> LastModified) &#123;</div><div class="line">            <span class="keyword">return</span> ((LastModified) handler).getLastModified(request);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1L</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpRequestHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</div><div class="line">      	<span class="comment">//就是判断handler是否实现了HttpRequestHandler接口  </span></div><div class="line">        <span class="keyword">return</span> (handler <span class="keyword">instanceof</span> HttpRequestHandler);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></div><div class="line">            <span class="keyword">throws</span> Exception &#123;</div><div class="line">        <span class="comment">//若handler实现了HttpRequestHandler接口，则调用该接口的方法，执行我们在该方法中写的业务逻辑  </span></div><div class="line">        ((HttpRequestHandler) handler).handleRequest(request, response);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> LastModified) &#123;</div><div class="line">            <span class="keyword">return</span> ((LastModified) handler).getLastModified(request);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1L</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出它们的各个supports方法的唯一区别就是，不同的适配器支持不同的传入的handler类型。</p>
<p>所以再来看一下这个过程就是遍历所有的适配器，找到第一个支持这个handler的适配器，然后返回。</p>
<p>从上面的例子来看，SimpleControllerHandlerAdapter是支持HomeAction的，所以就会返回这个适配器，然后通过它来执行下面的handle方法，也就进入了自己定义的逻辑之中。</p>
<h3 id="3-3、适配器模式"><a href="#3-3、适配器模式" class="headerlink" title="3.3、适配器模式"></a>3.3、适配器模式</h3><p>到这里更加理解这个适配器模式了，这个handler的类型有很多种，而最上面的HandlerExecutionChain持有的时候并不知道它是什么类型，因为是Object类型的，它可能是Controller类，也有可能是HttpRequestHandler类，而这些不同的实现类具体的实现方法肯定是不同的，所以，每个实现类都有一个对应的适配器类，得到这个handler的时候遍历所有的适配器，遇到适配器支持的实现类，则返回这个适配器，然后通过这个适配器来调用具体实现类中的方法。</p>
<p>这样对于DispatcherServlet来说，它不知道每个handler具体的实现过程和方法，它需要的就是support和handle方法，至于具体对应到实现类中的哪个方法，则由适配器来决定。</p>
<p>而这个handle方法，则是第7步对应的逻辑处理了。</p>
<h2 id="4、handle方法"><a href="#4、handle方法" class="headerlink" title="4、handle方法"></a>4、handle方法</h2><p>在适配器中，handle方法被转换成handler的handleRequest方法。并且返回一个ModelAndView类对象，这里就是执行用户定义的Controller的地方了。</p>
<p>所以这里针对不同方式定义的Controller，执行的方式也是不同的。</p>
<h1 id="四、参考地址"><a href="#四、参考地址" class="headerlink" title="四、参考地址"></a>四、参考地址</h1><p><a href="https://my.oschina.net/lichhao/blog/104943" target="_blank" rel="external">https://my.oschina.net/lichhao/blog/104943</a></p>
<p><a href="http://blog.csdn.net/zljjava/article/details/50414585" target="_blank" rel="external">http://blog.csdn.net/zljjava/article/details/50414585</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SpringMVC（二）：DispatcherServlet的初始化过程]]></title>
      <url>http://yoursite.com/2017/01/10/spring/SpringMVC(2)DispatcherServlet%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>上篇介绍了SpringMVC相关的基础类，下面分析一下各个类是如何工作的。</p>
<p>首先从web.xml这个配置文件开始，在介绍Servlet的时候，提到过：</p>
<blockquote>
<p>ApplicationContext是Spring的核心，在介绍Spring的时候知道它是一个Bean容器，在SpringMVC中，会用到的是WebApplicationContext，它继承自ApplicationContext。</p>
<p>WebApplicationContext的初始化方式和以前介绍的BeanFactory、ApplicationContext容器有所区别，因为WebApplicationContext需要ServletContext实例，也就是说它必须在拥有Web容器的前提下才能完成启动的工作。</p>
<p>在web.xml中配置自启动的Servlet或定义Web容器监听器(ServletContextListener)，借助着两者中的任何一个，我们就可以启动Spring Web应用上下文的工作。</p>
</blockquote>
<p>下面就来介绍一下这个web监听容器ServletContextListener。</p>
<h1 id="一、ContextLoaderListener"><a href="#一、ContextLoaderListener" class="headerlink" title="一、ContextLoaderListener"></a>一、ContextLoaderListener</h1><p>这两个名字非常相似，首先ServletContextListener是一个接口，使用这个接口，它的位置是package javax.servlet，与Spring无关，使用这个接口，开发者能够在为客户端请求提供服务之前向ServletContext中添加任意的对象。</p>
<p>而ContextLoaderListener就是Spring用来实现这一接口的类，它向ServletContext中添加的对象就是一个WebApplicationContext对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.web.context;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.servlet.ServletContextEvent;</div><div class="line"><span class="keyword">import</span> javax.servlet.ServletContextListener;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLoaderListener</span> <span class="keyword">extends</span> <span class="title">ContextLoader</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span><span class="params">(WebApplicationContext context)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</div><div class="line">        initWebApplicationContext(event.getServletContext());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</div><div class="line">        closeWebApplicationContext(event.getServletContext());</div><div class="line">        ContextCleanupListener.cleanupAttributes(event.getServletContext());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ContextLoaderListener实现了ServletContextListener接口，在Servlet容器启动的时候，会初始化一个WebApplicationContext的实现类，并将其作为ServletContext的一个属性设置到Servlet环境中，具体实现代码在父类ContextLoader中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">this</span>.context);</div></pre></td></tr></table></figure>
<p>ContextLoaderListener所初始化的这个Spring容器上下文，被称为<strong>根上下文</strong>。 </p>
<p>下面会介绍到，Spring在DispatcherServlet的初始化过程中，同样会初始化一个WebApplicationContext的实现类，作为自己独有的上下文，这个独有的上下文，会将上面的根上下文作为自己的父上下文，来存放SpringMVC的配置元素，然后同样作为ServletContext的一个属性，被设置到ServletContext中，只不过它的key就稍微有点不同，key和具体的DispatcherServlet注册在web.xml文件中的名字有关，从这一点也决定了，我们可以在web.xml文件中注册多个DispatcherServlet，因为Servlet容器中注册的Servlet名字肯定不一样，设置到Servlet环境中的key也肯定不同。</p>
<p>由于在Spring容器中，子上下文可以访问到所有父上下文中的信息，而父上下文访问不到子上下文的信息，这个根上下文，就很适合作为多个子上下文配置的集中点。以官方文档中的图来说明：</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/spring/3.png?raw=true" alt="img"></p>
<p>还有一张图比较直观：</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/spring/4.png?raw=true" alt=""></p>
<p>从图中可以看出：</p>
<ul>
<li>ContextLoaderListener初始化的上下文加载的Bean是对于整个应用程序共享的，不管是使用什么表现层技术，一般如DAO层、Service层Bean；</li>
<li>DispatcherServlet初始化的上下文加载的Bean是只对Spring Web MVC有效的Bean，如Controller、HandlerMapping、HandlerAdapter等等，该初始化上下文应该只加载Web相关组件。</li>
</ul>
<p>下面具体介绍一下Servlet接口的实现类，也是SpringMVC的核心，DispatcherServlet。</p>
<h1 id="二、DispatcherServlet"><a href="#二、DispatcherServlet" class="headerlink" title="二、DispatcherServlet"></a>二、DispatcherServlet</h1><h2 id="1、类继承关系"><a href="#1、类继承关系" class="headerlink" title="1、类继承关系"></a>1、类继承关系</h2><p>再来看一下它的继承关系。</p>
<p> <img src="https://github.com/paine1690/HelloWorld/blob/master/pic/spring/2.png?raw=true" alt="QQ截图20170109110308"></p>
<p>它最上面继承自HttpServlet，下面主要有三个具体的类：</p>
<ul>
<li>HttpServletBean</li>
<li>FrameworkServlet</li>
<li>DispatcherServlet</li>
</ul>
<p>通过这三个不同层次的类，来抽象不同的职责。</p>
<p>而因为它继承自HttpServlet，所以先简单回顾一下Servlet的生命周期:</p>
<ol>
<li><p>初始化阶段 init()方法</p>
<p>容器调用 init() 方法(一生只调一次，并且是在第一次调用Servlet的时候执行)</p>
</li>
<li><p>运行阶段  Service()方法</p>
</li>
<li><p>销毁阶段   destroy() 方法</p>
</li>
</ol>
<p>这篇文章介绍的主要就是初始化方法，也就是从web容器调用init()方法开始。</p>
<h2 id="2、HttpServletBean类与init方法"><a href="#2、HttpServletBean类与init方法" class="headerlink" title="2、HttpServletBean类与init方法"></a>2、HttpServletBean类与init方法</h2><p>init方法在HttpServletBean类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.web.servlet;</div><div class="line"></div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServletBean</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span></div><div class="line">        <span class="keyword">implements</span> <span class="title">EnvironmentCapable</span>, <span class="title">EnvironmentAware</span> &#123;</div><div class="line"></div><div class="line">    <span class="comment">/** 上面的方法都省略了 */</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Map config parameters onto bean properties of this servlet, and</div><div class="line">     * invoke subclass initialization.</div><div class="line">     * <span class="doctag">@throws</span> ServletException if bean properties are invalid (or required</div><div class="line">     * properties are missing), or if subclass initialization fails.</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">            logger.debug(<span class="string">"Initializing servlet '"</span> + getServletName() + <span class="string">"'"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Set bean properties from init parameters.</span></div><div class="line">      	<span class="comment">//1、如下代码的作用是将Servlet初始化参数设置到该组件上  </span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</div><div class="line">            BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</div><div class="line">            ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</div><div class="line">            bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> ResourceEditor(resourceLoader, getEnvironment()));</div><div class="line">            initBeanWrapper(bw);</div><div class="line">            bw.setPropertyValues(pvs, <span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</div><div class="line">            logger.error(<span class="string">"Failed to set bean properties on servlet '"</span> + getServletName() + <span class="string">"'"</span>, ex);</div><div class="line">            <span class="keyword">throw</span> ex;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Let subclasses do whatever initialization they like.</span></div><div class="line">      	<span class="comment">//2、提供给子类初始化的扩展点，该方法由FrameworkServlet覆盖  </span></div><div class="line">        initServletBean();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">            logger.debug(<span class="string">"Servlet '"</span> + getServletName() + <span class="string">"' configured successfully"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 下面的方法都省略了</div><div class="line">     */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法主要做了两件事：</p>
<ul>
<li><p>将Servlet初始化参数（init-param）设置到该组件上（如contextAttribute、contextClass、namespace、contextConfigLocation），通过BeanWrapper简化设值过程，方便后续使用；</p>
</li>
<li><p>提供给子类初始化扩展点，initServletBean()，该方法由FrameworkServlet覆盖。</p>
<p>​</p>
</li>
</ul>
<p>关于这个设置属性，HttpServletBean这个类的设计中，运用了依赖注入思想完成了<code>&lt;init-param&gt;</code>配置元素的读取。他抽离出HttpServletBean这个类的目的也在于此，就是“以依赖注入的方式来读取Servlet类的<code>&lt;init-param&gt;</code>配置信息”，而且这里很明显是一种setter注入。</p>
<p>明白了HttpServletBean类的设计思想，我们也就知道可以如何从中获益。具体来说，<strong>我们继承HttpServletBean类（就像DispatcherServlet做的那样），在类中定义一个属性，为这个属性加上setter方法后，我们就可以在<code>&lt;init-param&gt;</code>元素中为其定义值。</strong>在类被初始化后，值就会被注入进来，我们可以直接使用它，避免了样板式的getInitParameter()方法的使用，而且还免费享有Spring中资源编辑器的功能，可以在web.xml中，通过“classpath:”直接指定类路径下的资源文件。</p>
<p>个人理解：从这个类的名字上也可以看出它的作用，HttpServletBean，分别为HttpServlet和Bean，一方面继承自HttpServlet，重写init方法作为入口，另一方面又是Bean，并且加载了在web.xml里面通过参数配置，来实现依赖注入。</p>
<p>下面就是调用的initServletBean方法。</p>
<h2 id="2、FrameworkServlet类与initServletBean方法"><a href="#2、FrameworkServlet类与initServletBean方法" class="headerlink" title="2、FrameworkServlet类与initServletBean方法"></a>2、FrameworkServlet类与initServletBean方法</h2><p>这个方法在子类FrameworkServlet中重写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.web.servlet;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameworkServlet</span> <span class="keyword">extends</span> <span class="title">HttpServletBean</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/** 省略 */</span></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Overridden method of &#123;<span class="doctag">@link</span> HttpServletBean&#125;, invoked after any bean properties</div><div class="line">     * have been set. Creates this servlet's WebApplicationContext.</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">        <span class="comment">//省略部分代码  </span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          	<span class="comment">//1、初始化Web上下文  </span></div><div class="line">            <span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</div><div class="line">          	<span class="comment">//2、提供给子类初始化的扩展点  </span></div><div class="line">            initFrameworkServlet();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//省略部分代码  </span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">/** 省略 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法主要做了两件事：</p>
<ul>
<li>初始化web上下文</li>
<li>提供给子类初始化扩展点</li>
</ul>
<p>这个上下文是DispatcherServlet创建的上下文，和上面Listener创建的上下文是父子关系。</p>
<p>下面是初始化web上下文的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line"> 	<span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</div><div class="line">     	<span class="comment">//1.</span></div><div class="line">    WebApplicationContext rootContext =</div><div class="line">            WebApplicationContextUtils.getWebApplicationContext(getServletContext());</div><div class="line">    WebApplicationContext wac = <span class="keyword">null</span>;</div><div class="line">    </div><div class="line">     	<span class="comment">//2.</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// A context instance was injected at construction time -&gt; use it</span></div><div class="line">        wac = <span class="keyword">this</span>.webApplicationContext;</div><div class="line">        <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</div><div class="line">            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</div><div class="line">            <span class="keyword">if</span> (!cwac.isActive()) &#123;</div><div class="line">                <span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></div><div class="line">                <span class="comment">// setting the parent context, setting the application context id, etc</span></div><div class="line">                <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">// The context instance was injected without an explicit parent -&gt; set</span></div><div class="line">                    <span class="comment">// the root application context (if any; may be null) as the parent</span></div><div class="line">                    cwac.setParent(rootContext);</div><div class="line">                &#125;</div><div class="line">                configureAndRefreshWebApplicationContext(cwac);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">     	<span class="comment">//3.</span></div><div class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// No context instance was injected at construction time -&gt; see if one</span></div><div class="line">        <span class="comment">// has been registered in the servlet context. If one exists, it is assumed</span></div><div class="line">        <span class="comment">// that the parent context (if any) has already been set and that the</span></div><div class="line">        <span class="comment">// user has performed any initialization such as setting the context id</span></div><div class="line">        wac = findWebApplicationContext();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">     	<span class="comment">//4.</span></div><div class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></div><div class="line">        wac = createWebApplicationContext(rootContext);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">     	<span class="comment">//5</span></div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) &#123;</div><div class="line">        <span class="comment">// Either the context is not a ConfigurableApplicationContext with refresh</span></div><div class="line">        <span class="comment">// support or the context injected at construction time had already been</span></div><div class="line">        <span class="comment">// refreshed -&gt; trigger initial onRefresh manually here.</span></div><div class="line">        onRefresh(wac);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">     	<span class="comment">//6.</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.publishContext) &#123;</div><div class="line">        <span class="comment">// Publish the context as a servlet context attribute.</span></div><div class="line">        String attrName = getServletContextAttributeName();</div><div class="line">        getServletContext().setAttribute(attrName, wac);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</div><div class="line">            <span class="keyword">this</span>.logger.debug(<span class="string">"Published WebApplicationContext of servlet '"</span> + getServletName() +</div><div class="line">                    <span class="string">"' as ServletContext attribute with name ["</span> + attrName + <span class="string">"]"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> wac;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</div><div class="line">    <span class="comment">// For subclasses: do nothing by default.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结合上面的注释，看一下具体过程：</p>
<ol>
<li>获取由ContextLoaderListener初始化并注册在ServletContext中的根上下文，记为rootContext</li>
<li>如果webApplicationContext已经不为空，表示这个Servlet类是通过编程式注册到容器中的（Servlet 3.0+中的ServletContext.addServlet() ），上下文也由编程式传入。若这个传入的上下文还没被初始化，将rootContext上下文设置为它的父上下文，然后将其初始化，否则直接使用。</li>
<li>通过wac变量的引用是否为null，判断第2步中是否已经完成上下文的设置（即上下文是否已经用编程式方式传入），如果wac==null成立，说明该Servlet不是由编程式注册到容器中的。此时以contextAttribute属性的值为键，在ServletContext中查找上下文，查找得到，说明上下文已经以别的方式初始化并注册在contextAttribute下，直接使用。</li>
<li>检查wac变量的引用是否为null，如果wac==null成立，说明2、3两步中的上下文初始化策略都没成功，此时调用createWebApplicationContext(rootContext)，建立一个全新的以rootContext为父上下文的上下文，作为SpringMVC配置元素的容器上下文。大多数情况下我们所使用的上下文，就是这个新建的上下文。</li>
<li>以上三种初始化上下文的策略，都会回调onRefresh(ApplicationContext context)方法（回调的方式根据不同策略有不同），onRefresh方法在DispatcherServlet类中被覆写，以上面得到的上下文为依托，完成SpringMVC中默认实现类的初始化。</li>
<li>最后，将这个上下文发布到ServletContext中，也就是将上下文以一个和Servlet类在web.xml中注册名字有关的值为键，设置为ServletContext的一个属性。你可以通过改变publishContext的值来决定是否发布到ServletContext中，默认为true。</li>
</ol>
<p>以上面6点跟踪FrameworkServlet类中的代码，可以比较清晰的了解到整个容器上下文的建立过程，也就能够领会到FrameworkServlet类的设计目的，<strong>它是用来建立一个和Servlet关联的Spring容器上下文，并将其注册到ServletContext中的。</strong>跳脱开SpringMVC体系，我们也能通过继承FrameworkServlet类，得到与Spring容器整合的好处，FrameworkServlet和HttpServletBean一样，是一个可以独立使用的类。整个SpringMVC设计中，处处体现开闭原则，这里显然也是其中一点。</p>
<p>可以看见最下面的onRefresh方法，和上面的套路一样，都是留给子类实现的。</p>
<h2 id="3、DispatcherServlet类与onRefresh方法"><a href="#3、DispatcherServlet类与onRefresh方法" class="headerlink" title="3、DispatcherServlet类与onRefresh方法"></a>3、DispatcherServlet类与onRefresh方法</h2><p>FrameworkServlet的子类自然就是DispatcherServlet了，看一下它的onRefresh方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.web.servlet;</div><div class="line"></div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title">FrameworkServlet</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * This implementation calls &#123;<span class="doctag">@link</span> #initStrategies&#125;.</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</div><div class="line">        initStrategies(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Initialize the strategy objects that this servlet uses.</div><div class="line">     * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</div><div class="line">        initMultipartResolver(context);</div><div class="line">        initLocaleResolver(context);</div><div class="line">        initThemeResolver(context);</div><div class="line">        initHandlerMappings(context);</div><div class="line">        initHandlerAdapters(context);</div><div class="line">        initHandlerExceptionResolvers(context);</div><div class="line">        initRequestToViewNameTranslator(context);</div><div class="line">        initViewResolvers(context);</div><div class="line">        initFlashMapManager(context);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DispatcherServlet类覆写了父类FrameworkServlet中的onRefresh(ApplicationContext context)方法，提供了SpringMVC各种编程元素的初始化。当然这些编程元素，都是作为容器上下文中一个个bean而存在的。具体的初始化策略，在initStrategies()方法中封装。</p>
<h2 id="4、initHandlerMappings方法"><a href="#4、initHandlerMappings方法" class="headerlink" title="4、initHandlerMappings方法"></a>4、initHandlerMappings方法</h2><p>我们以其中initHandlerMappings(context)方法为例，分析一下这些SpringMVC编程元素的初始化策略，其他的方法，都是以类似的策略初始化的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Initialize the HandlerMappings used by this class.</div><div class="line"> * &lt;p&gt;If no HandlerMapping beans are defined in the BeanFactory for this namespace,</div><div class="line"> * we default to BeanNameUrlHandlerMapping.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerMappings</span><span class="params">(ApplicationContext context)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.handlerMappings = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.detectAllHandlerMappings) &#123;</div><div class="line">        <span class="comment">// Find all HandlerMappings in the ApplicationContext, including ancestor contexts.</span></div><div class="line">        Map&lt;String, HandlerMapping&gt; matchingBeans =</div><div class="line">                BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line">        <span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</div><div class="line">            <span class="keyword">this</span>.handlerMappings = <span class="keyword">new</span> ArrayList&lt;&gt;(matchingBeans.values());</div><div class="line">            <span class="comment">// We keep HandlerMappings in sorted order.</span></div><div class="line">            AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.handlerMappings);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);</div><div class="line">            <span class="keyword">this</span>.handlerMappings = Collections.singletonList(hm);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</div><div class="line">            <span class="comment">// Ignore, we'll add a default HandlerMapping later.</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Ensure we have at least one HandlerMapping, by registering</span></div><div class="line">    <span class="comment">// a default HandlerMapping if no other mappings are found.</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);</div><div class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">            logger.debug(<span class="string">"No HandlerMappings found in servlet '"</span> + getServletName() + <span class="string">"': using default"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段光是看代码和注释就可以看明白，关键的一个变量在于this.detectAllHandlerMappings</p>
<ul>
<li>如果为true：会把上下文中所有HandlerMapping类型的Bean都注册在handlerMappings这个List变量中。</li>
<li>如果为false：那么将尝试获取名为handlerMapping的Bean，新建一个只有一个元素的List，将其赋给handlerMappings</li>
<li>如果经过上面的过程，handlerMappings变量仍为空，那么说明你没有在上下文中提供自己HandlerMapping类型的Bean定义。此时，SpringMVC将采用默认初始化策略来初始化handlerMappings。</li>
</ul>
<p>而这个变量默认为true，可以通过修改web.xml中DispatcherServlet的初始参数来将其设置为false</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">  	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>detectAllHandlerMappings<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">  	<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div></pre></td></tr></table></figure>
<p>下面再看一下这个默认的初始化策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Create a List of default strategy objects for the given strategy interface.</div><div class="line"> * &lt;p&gt;The default implementation uses the "DispatcherServlet.properties" file (in the same</div><div class="line"> * package as the DispatcherServlet class) to determine the class names. It instantiates</div><div class="line"> * the strategy objects through the context's BeanFactory.</div><div class="line"> * <span class="doctag">@param</span> context the current WebApplicationContext</div><div class="line"> * <span class="doctag">@param</span> strategyInterface the strategy interface</div><div class="line"> * <span class="doctag">@return</span> the List of corresponding strategy objects</div><div class="line"> */</div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">getDefaultStrategies</span><span class="params">(ApplicationContext context, Class&lt;T&gt; strategyInterface)</span> </span>&#123;</div><div class="line">    String key = strategyInterface.getName();</div><div class="line">    String value = defaultStrategies.getProperty(key);</div><div class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</div><div class="line">        String[] classNames = StringUtils.commaDelimitedListToStringArray(value);</div><div class="line">        List&lt;T&gt; strategies = <span class="keyword">new</span> ArrayList&lt;&gt;(classNames.length);</div><div class="line">        <span class="keyword">for</span> (String className : classNames) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Class&lt;?&gt; clazz = ClassUtils.forName(className, DispatcherServlet.class.getClassLoader());</div><div class="line">                Object strategy = createDefaultStrategy(context, clazz);</div><div class="line">                strategies.add((T) strategy);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(</div><div class="line">                        <span class="string">"Could not find DispatcherServlet's default strategy class ["</span> + className +</div><div class="line">                                <span class="string">"] for interface ["</span> + key + <span class="string">"]"</span>, ex);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">catch</span> (LinkageError err) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(</div><div class="line">                        <span class="string">"Error loading DispatcherServlet's default strategy class ["</span> + className +</div><div class="line">                                <span class="string">"] for interface ["</span> + key + <span class="string">"]: problem with class file or dependent class"</span>, err);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> strategies;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它是一个范型的方法，承担所有SpringMVC编程元素的默认初始化策略比如HandlerAdapters的默认初始化策略也通过它。方法的内容比较直白，就是以传递类的名称为键，从defaultStrategies这个Properties变量中获取实现类，然后反射初始化。</p>
<p>需要说明一下的是defaultStrategies变量的初始化，它是在DispatcherServlet的静态初始化代码块中加载的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_STRATEGIES_PATH = <span class="string">"DispatcherServlet.properties"</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Properties defaultStrategies;</div><div class="line"></div><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">    <span class="comment">// Load default strategy implementations from properties file.</span></div><div class="line">    <span class="comment">// This is currently strictly internal and not meant to be customized</span></div><div class="line">    <span class="comment">// by application developers.</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class);</div><div class="line">        defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not load 'DispatcherServlet.properties': "</span> + ex.getMessage());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个DispatcherServlet.properties里面，以键值对的方式，记录了SpringMVC默认实现类，在org.springframework.web.servlet包里面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"># Default implementation classes for DispatcherServlet&apos;s strategy interfaces.</div><div class="line"># Used as fallback when no matching beans are found in the DispatcherServlet context.</div><div class="line"># Not meant to be customized by application developers.</div><div class="line"></div><div class="line">org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</div><div class="line"></div><div class="line">org.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver</div><div class="line"></div><div class="line">org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</div><div class="line">    org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping</div><div class="line"></div><div class="line">org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\</div><div class="line">    org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\</div><div class="line">    org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter</div><div class="line"></div><div class="line">org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver,\</div><div class="line">    org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\</div><div class="line">    org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</div><div class="line"></div><div class="line">org.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</div><div class="line"></div><div class="line">org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver</div><div class="line"></div><div class="line">org.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager</div></pre></td></tr></table></figure>
<p>spring 3.1 以后有些类可能进行了替换，比如</p>
<p>RequestMappingHandlerMapping 来替换 DefaultAnnotationHandlerMapping，</p>
<p>用 RequestMappingHandlerAdapter 来替换 AnnotationMethodHandlerAdapter。</p>
<p>看一下默认的几个HandlerMapping的作用：</p>
<ul>
<li>BeanNameUrlHandlerMapping：通过对比url和bean的name找到对应的对象</li>
<li>RequestMappingHandlerMapping：主要是针对注解配置@RequestMapping的，取代了最早的DefaultAnnotationHandlerMapping</li>
</ul>
<p>再看一下HandlerAdapter：</p>
<ul>
<li><p>HttpRequestHandlerAdapter：要求handler实现Controller接口，该接口的方法为</p>
<blockquote>
<p>ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response)</p>
</blockquote>
</li>
<li><p>SimpleControllerHandlerAdapter:要求handler实现HttpRequestHandler接口，该接口的方法为：</p>
<blockquote>
<p>void handleRequest(HttpServletRequest request, HttpServletResponse response)</p>
</blockquote>
</li>
<li><p>RequestMappingHandlerAdapter:和上面的RequestMappingHandlerMapping配对使用，针对@RequestMapping，取代了最早的AnnotationMethodHandlerAdapter。</p>
</li>
</ul>
<p>至此，我们分析完了initHandlerMappings(context)方法的执行过程，其他的初始化过程与这个方法非常类似。所有初始化方法执行完后，SpringMVC正式完成初始化，静静等待Web请求的到来。</p>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>上面介绍了DispatcherServlet对应Servlet生命周期的init阶段，可以发现HttpServletBean、FrameworkServlet、DispatcherServlet三个不同的类层次，SpringMVC的设计者将三种不同的职责分别抽象，运用模版方法设计模式分别固定在三个类层次中。</p>
<ul>
<li>HttpServletBean完成的是<code>&lt;init-param&gt;</code>配置元素的依赖注入</li>
<li>FrameworkServlet完成的是容器上下文的建立</li>
<li>DispatcherServlet完成的是SpringMVC具体编程元素的初始化策略。</li>
</ul>
<h1 id="四、参考地址"><a href="#四、参考地址" class="headerlink" title="四、参考地址"></a>四、参考地址</h1><p><a href="https://my.oschina.net/lichhao/blog/100138" target="_blank" rel="external">https://my.oschina.net/lichhao/blog/100138</a></p>
<p><a href="https://my.oschina.net/lichhao/blog/102315" target="_blank" rel="external">https://my.oschina.net/lichhao/blog/102315</a></p>
<p><a href="http://blog.csdn.net/lqx1988221/article/details/12620689" target="_blank" rel="external">http://blog.csdn.net/lqx1988221/article/details/12620689</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SpringMVC（一）：请求处理流程与关键类]]></title>
      <url>http://yoursite.com/2017/01/09/spring/SpringMVC(1)%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%85%B3%E9%94%AE%E7%B1%BB/</url>
      <content type="html"><![CDATA[<p>学习完IOC容器的初始化，来看一下SpringMVC的实现。</p>
<h1 id="一、Spring-MVC的请求处理流程"><a href="#一、Spring-MVC的请求处理流程" class="headerlink" title="一、Spring MVC的请求处理流程"></a>一、Spring MVC的请求处理流程</h1><p>首先必须知道Spring MVC处理请求的流程，从接受请求到生成响应，关于这个流程有很多种说法，虽然有略微差别但主体思路都是相同的，找到一个比较直观的图片</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/spring/1.png?raw=true" alt=""></p>
<ol>
<li>首先用户发送请求——&gt;DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；</li>
<li>DispatcherServlet——&gt;HandlerMapping， HandlerMapping将会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象、多个HandlerInterceptor拦截器）对象，通过这种策略模式，很容易添加新的映射策略；</li>
<li>DispatcherServlet——&gt;HandlerAdapter，DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。HandlerAdapter将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；</li>
<li>HandlerAdapter——&gt;处理器功能处理方法的调用，HandlerAdapter将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；</li>
<li>Handler执行完成后，返回一个ModelAndView对象（包含模型数据、逻辑视图名）；</li>
<li>ModelAndView的逻辑视图名——&gt; ViewResolver， ViewResolver将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；</li>
<li>View——&gt;渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术；</li>
<li>返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。</li>
</ol>
<h1 id="二、源码中的相关类与接口"><a href="#二、源码中的相关类与接口" class="headerlink" title="二、源码中的相关类与接口"></a>二、源码中的相关类与接口</h1><p>上面这个经典的流程就是SpringMVC的核心，这其中涉及到几个关键的类和接口。</p>
<h2 id="1、DispatcherServlet"><a href="#1、DispatcherServlet" class="headerlink" title="1、DispatcherServlet"></a>1、DispatcherServlet</h2><p>从流程中可以看见，DispatcherServlet是整个流程的核心，先来看一下它的继承关系：</p>
<p> <img src="https://github.com/paine1690/HelloWorld/blob/master/pic/spring/2.png?raw=true" alt="QQ截图20170109110308"></p>
<p>它继承自HttpServlet，也就是说它是一个标准的Servlet，所以它的使用方法就是在web.xml中配置，然后再web容器初始化的时候加载。</p>
<p>这个类中定义了整个处理流程，后面再详细分析它。</p>
<h2 id="2、HandlerMapping"><a href="#2、HandlerMapping" class="headerlink" title="2、HandlerMapping"></a>2、HandlerMapping</h2><h3 id="2-1、源码"><a href="#2-1、源码" class="headerlink" title="2.1、源码"></a>2.1、源码</h3><p>DispatcherServlet处理请求的第一步就是根据url来获取相应的HandlerExecutionChain ，它是一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.web.servlet;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMapping</span> </span>&#123;</div><div class="line"></div><div class="line">    String PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".pathWithinHandlerMapping"</span>;</div><div class="line"></div><div class="line">    String BEST_MATCHING_PATTERN_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".bestMatchingPattern"</span>;</div><div class="line"></div><div class="line"></div><div class="line">    String INTROSPECT_TYPE_LEVEL_MAPPING = HandlerMapping.class.getName() + <span class="string">".introspectTypeLevelMapping"</span>;</div><div class="line"></div><div class="line"></div><div class="line">    String URI_TEMPLATE_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".uriTemplateVariables"</span>;</div><div class="line"></div><div class="line">    String MATRIX_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".matrixVariables"</span>;</div><div class="line"></div><div class="line">    String PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".producibleMediaTypes"</span>;</div><div class="line"></div><div class="line">    <span class="function">HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个接口中有一堆字符串，还有唯一一个关键的方法：</p>
<blockquote>
<p>HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception;</p>
</blockquote>
<p>它会返回一个HandlerExecutionChain对象。</p>
<h3 id="2-2、调用"><a href="#2-2、调用" class="headerlink" title="2.2、调用"></a>2.2、调用</h3><p>而它在哪里进行调用呢？回到DispatcherServlet的处理流程，当，由标准Servlet类处理方法doGet或者doPost，</p>
<ul>
<li>DispatcherServlet中有一个HandlerMapping类的List</li>
<li>DispatcherServlet接收到web请求后会遍历这个List</li>
<li>该web请求的HttpServletRequest对象为参数，依次调用其getHandler方法，第一个不为null的调用结果，将被返回。</li>
</ul>
<p>DispatcherServlet类中的这个方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** List of HandlerMappings used by this servlet */</span></div><div class="line"><span class="keyword">private</span> List&lt;HandlerMapping&gt; handlerMappings;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">for</span> (HandlerMapping hm : <span class="keyword">this</span>.handlerMappings) &#123;</div><div class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</div><div class="line">            logger.trace(</div><div class="line">                    <span class="string">"Testing handler map ["</span> + hm + <span class="string">"] in DispatcherServlet with name '"</span> + getServletName() + <span class="string">"'"</span>);</div><div class="line">        &#125;</div><div class="line">        HandlerExecutionChain handler = hm.getHandler(request);</div><div class="line">        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> handler;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-3、作用"><a href="#2-3、作用" class="headerlink" title="2.3、作用"></a>2.3、作用</h3><p>上面这个方法就对应了流程中的第二步，一个web请求经过处理后，会得到一个HandlerExecutionChain对象，这就是SpringMVC对URl映射给出的回答。需要留意的是，HandlerMapping接口的getHandler方法参数是HttpServletRequest，这意味着，HandlerMapping的实现类可以利用HttpServletRequest中的所有信息来做出这个HandlerExecutionChain对象的生成”决策“。这包括，请求头、url路径、cookie、session、参数等等一切你从一个web请求中可以得到的任何东西（最常用的是url路径）。</p>
<p>SpirngMVC的第一个扩展点，就出现在这里。我们可以编写任意的HandlerMapping实现类，依据任何策略来决定一个web请求到HandlerExecutionChain对象的生成。</p>
<p>这里涉及到一个设计模式：<strong>策略模式</strong></p>
<h3 id="2-4、策略模式"><a href="#2-4、策略模式" class="headerlink" title="2.4、策略模式"></a>2.4、策略模式</h3><p>策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。</p>
<p>这个模式涉及到三个角色：</p>
<ul>
<li><strong>环境(Context)角色：</strong>持有一个Strategy的引用。对应的就是DispatcherServlet，它持有多个策略，根据不同的请求进行判断。</li>
<li><strong>抽象策略(Strategy)角色：</strong>这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。对应的就是HandlerMapping接口。</li>
<li><strong>具体策略(ConcreteStrategy)角色：</strong>包装了相关的算法或行为。对应一个具体的HandlerMapping实现类。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复</li>
<li>使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。对应的就是DispatcherServlet中有一个HandlerMapping的List。</li>
<li>由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。</li>
</ul>
<h2 id="3、HandlerExecutionChain"><a href="#3、HandlerExecutionChain" class="headerlink" title="3、HandlerExecutionChain"></a>3、HandlerExecutionChain</h2><p>如果getHandler的返回不为null，那么则返回它的HandlerExecutionChain对象。</p>
<p>从名字可以直观的看得出，这个对象是一个执行链的封装。熟悉Struts2的都知道，Action对象也是被层层拦截器包装，这里可以做个类比，说明SpringMVC确实是吸收了Struts2的部分设计思想。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.web.servlet;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerExecutionChain</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(HandlerExecutionChain.class);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object handler;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> HandlerInterceptor[] interceptors;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> List&lt;HandlerInterceptor&gt; interceptorList;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> interceptorIndex = -<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerExecutionChain</span><span class="params">(Object handler)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(handler, (HandlerInterceptor[]) <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerExecutionChain</span><span class="params">(Object handler, HandlerInterceptor... interceptors)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> HandlerExecutionChain) &#123;</div><div class="line">            HandlerExecutionChain originalChain = (HandlerExecutionChain) handler;</div><div class="line">            <span class="keyword">this</span>.handler = originalChain.getHandler();</div><div class="line">            <span class="keyword">this</span>.interceptorList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            CollectionUtils.mergeArrayIntoCollection(originalChain.getInterceptors(), <span class="keyword">this</span>.interceptorList);</div><div class="line">            CollectionUtils.mergeArrayIntoCollection(interceptors, <span class="keyword">this</span>.interceptorList);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">this</span>.handler = handler;</div><div class="line">            <span class="keyword">this</span>.interceptors = interceptors;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.handler;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(HandlerInterceptor interceptor)</span> </span>&#123;</div><div class="line">        initInterceptorList().add(interceptor);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(HandlerInterceptor... interceptors)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</div><div class="line">            initInterceptorList().addAll(Arrays.asList(interceptors));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> List&lt;HandlerInterceptor&gt; <span class="title">initInterceptorList</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.interceptorList == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">this</span>.interceptorList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.interceptors != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// An interceptor array specified through the constructor</span></div><div class="line">                <span class="keyword">this</span>.interceptorList.addAll(Arrays.asList(<span class="keyword">this</span>.interceptors));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.interceptors = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.interceptorList;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> HandlerInterceptor[] getInterceptors() &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.interceptors == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.interceptorList != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">this</span>.interceptors = <span class="keyword">this</span>.interceptorList.toArray(<span class="keyword">new</span> HandlerInterceptor[<span class="keyword">this</span>.interceptorList.size()]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.interceptors;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        HandlerInterceptor[] interceptors = getInterceptors();</div><div class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interceptors.length; i++) &#123;</div><div class="line">                HandlerInterceptor interceptor = interceptors[i];</div><div class="line">                <span class="keyword">if</span> (!interceptor.preHandle(request, response, <span class="keyword">this</span>.handler)) &#123;</div><div class="line">                    triggerAfterCompletion(request, response, <span class="keyword">null</span>);</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">this</span>.interceptorIndex = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">applyPostHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, ModelAndView mv)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        HandlerInterceptor[] interceptors = getInterceptors();</div><div class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = interceptors.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">                HandlerInterceptor interceptor = interceptors[i];</div><div class="line">                interceptor.postHandle(request, response, <span class="keyword">this</span>.handler, mv);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">triggerAfterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Exception ex)</span></span></div><div class="line">            <span class="keyword">throws</span> Exception &#123;</div><div class="line"></div><div class="line">        HandlerInterceptor[] interceptors = getInterceptors();</div><div class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.interceptorIndex; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">                HandlerInterceptor interceptor = interceptors[i];</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    interceptor.afterCompletion(request, response, <span class="keyword">this</span>.handler, ex);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">catch</span> (Throwable ex2) &#123;</div><div class="line">                    logger.error(<span class="string">"HandlerInterceptor.afterCompletion threw exception"</span>, ex2);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">applyAfterConcurrentHandlingStarted</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</div><div class="line">        HandlerInterceptor[] interceptors = getInterceptors();</div><div class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = interceptors.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">                <span class="keyword">if</span> (interceptors[i] <span class="keyword">instanceof</span> AsyncHandlerInterceptor) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        AsyncHandlerInterceptor asyncInterceptor = (AsyncHandlerInterceptor) interceptors[i];</div><div class="line">                        asyncInterceptor.afterConcurrentHandlingStarted(request, response, <span class="keyword">this</span>.handler);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">                        logger.error(<span class="string">"Interceptor ["</span> + interceptors[i] + <span class="string">"] failed in afterConcurrentHandlingStarted"</span>, ex);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.handler == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"HandlerExecutionChain with no handler"</span>;</div><div class="line">        &#125;</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        sb.append(<span class="string">"HandlerExecutionChain with handler ["</span>).append(<span class="keyword">this</span>.handler).append(<span class="string">"]"</span>);</div><div class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(<span class="keyword">this</span>.interceptorList)) &#123;</div><div class="line">            sb.append(<span class="string">" and "</span>).append(<span class="keyword">this</span>.interceptorList.size()).append(<span class="string">" interceptor"</span>);</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.interceptorList.size() &gt; <span class="number">1</span>) &#123;</div><div class="line">                sb.append(<span class="string">"s"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有点长，关键地方是最上面的两个属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object handler;</div><div class="line"></div><div class="line"><span class="keyword">private</span> HandlerInterceptor[] interceptors;</div></pre></td></tr></table></figure>
<p>正如上面流程中说的。一个HandlerExecutionChain对象包含一个Handler处理器（页面控制器）对象、多个HandlerInterceptor拦截器对象。</p>
<p>和Strust2中的实现一样，下面的过程都将围绕这个执行链展开。</p>
<h2 id="4、HandlerInterceptor"><a href="#4、HandlerInterceptor" class="headerlink" title="4、HandlerInterceptor"></a>4、HandlerInterceptor</h2><p>下面看一下拦截器，它是一个接口，里面有三个方法，这个在项目确实使用过，比如实现用户角色判断，就需要自己定义一个拦截器</p>
<p>看一下在项目中自己写的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></div><div class="line">            <span class="keyword">throws</span> Exception &#123;</div><div class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;MyInterceptor&gt;&gt;&gt;&gt;&gt;"</span>+request.getRequestURI());</div><div class="line">        <span class="keyword">if</span>(request.getRequestURI().equals(<span class="string">"/psxt"</span>)||request.getRequestURI().equals(<span class="string">"/psxt/login"</span>)</div><div class="line">        		||request.getRequestURI().equals(<span class="string">"/psxt/superadmin"</span>)</div><div class="line">        		||request.getRequestURI().equals(<span class="string">"/psxt/schooladmin"</span>)</div><div class="line">        		||request.getRequestURI().equals(<span class="string">"/psxt/teacheradmin"</span>))&#123;</div><div class="line">        	<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        User user = (User) request.getSession().getAttribute(SessionKey.USERNAME.name());</div><div class="line">        <span class="keyword">if</span>(user==<span class="keyword">null</span>||user.getRole()==<span class="number">0</span>)&#123;</div><div class="line">        	response.sendRedirect(request.getContextPath() + <span class="string">"/psxt302"</span>);</div><div class="line">        	<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里只重写了一个方法，用于用户角色的判断，而这个接口实际上有三个方法，用于重写，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.web.servlet;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.web.method.HandlerMethod;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerInterceptor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></div><div class="line">            <span class="keyword">throws</span> Exception &#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(</span></span></div><div class="line">            HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</div><div class="line">            <span class="keyword">throws</span> Exception &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(</span></span></div><div class="line">            HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</div><div class="line">            <span class="keyword">throws</span> Exception &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这三个方法的名称也可以看出，主要是围绕handler的执行展开：</p>
<ul>
<li>在真正调用其handler对象前，HandlerInterceptor接口实现类组成的数组将会被遍历，其preHandle方法会被依次调用，然后真正的handler对象将被调用。</li>
<li>handler对象被调用后，就生成了需要的响应数据，在将处理结果写到HttpServletResponse对象之前（SpringMVC称为渲染视图），其postHandle方法会被依次调用。</li>
<li>视图渲染完成后，最后afterCompletion方法会被依次调用，整个web请求的处理过程就结束了。</li>
</ul>
<p>HandlerInterceptor，是SpringMVC的第二个扩展点的暴露，通过自定义拦截器，我们可以在一个请求被真正处理之前、请求被处理但还没输出到响应中、请求已经被输出到响应中之后这三个时间点去做任何我们想要做的事情。Struts2框架的成功，就是源于这种拦截器的设计，SpringMVC吸收了这种设计思想，并推陈出新，更合理的划分了三个不同的时间点，从而给web请求处理这个流程，提供了更大的扩展性。</p>
<h2 id="5、HandlerAdapter"><a href="#5、HandlerAdapter" class="headerlink" title="5、HandlerAdapter"></a>5、HandlerAdapter</h2><p>接下来就是这个handler了，涉及到一个接口HandlerAdapter。感觉这个接口和HandlerMapping很像，采用和它一样的分析方式</p>
<h3 id="5-1、源码"><a href="#5-1、源码" class="headerlink" title="5.1、源码"></a>5.1、源码</h3><p>接口定义的源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.web.servlet;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-2、调用"><a href="#5-2、调用" class="headerlink" title="5.2、调用"></a>5.2、调用</h3><p>在DispatcherServlet中，除了上面提到的HandlerMapping实现类的列表，同样也注册了一个HandlerAdapter实现类组成的列表，有代码为证。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** List of HandlerMappings used by this servlet */</span></div><div class="line"><span class="keyword">private</span> List&lt;HandlerMapping&gt; handlerMappings;</div><div class="line"></div><div class="line"><span class="comment">/** List of HandlerAdapters used by this servlet */</span></div><div class="line"><span class="keyword">private</span> List&lt;HandlerAdapter&gt; handlerAdapters;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> HandlerAdapter <span class="title">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">    <span class="keyword">for</span> (HandlerAdapter ha : <span class="keyword">this</span>.handlerAdapters) &#123;</div><div class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</div><div class="line">            logger.trace(<span class="string">"Testing handler adapter ["</span> + ha + <span class="string">"]"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (ha.supports(handler)) &#123;</div><div class="line">            <span class="keyword">return</span> ha;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"No adapter for handler ["</span> + handler +</div><div class="line">            <span class="string">"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-3、作用"><a href="#5-3、作用" class="headerlink" title="5.3、作用"></a>5.3、作用</h3><p>HandlerExecutionChain中的handler对象会被作为参数传递进去，在DispatcherServlet类中注册的HandlerAdapter实现类列表会被遍历，然后返回第一个supports方法返回true的HandlerAdapter对象，用这个HandlerAdapter实现类中的handle方法处理handler对象，并返回ModelAndView这个包含了视图和数据的对象。</p>
<p>HandlerAdapter就是SpringMVC提供的第三个扩展点，你可以提供自己的实现类来处理handler对象。</p>
<h3 id="5-4、适配器模式"><a href="#5-4、适配器模式" class="headerlink" title="5.4、适配器模式"></a>5.4、适配器模式</h3><p>这里又涉及到一个适配器模式：</p>
<blockquote>
<p>适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</p>
</blockquote>
<p>模式所涉及的角色有：</p>
<ul>
<li><strong>目标(Target)角色：</strong>这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。</li>
<li><strong>源(Adapee)角色：</strong>现在需要适配的类。</li>
<li><strong>适配器(Adaper)角色：</strong>适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。</li>
</ul>
<p>虽然这个接口的名字中带有Adapter，但是不知道这里到底是不是适配器模式，详细的分析可以参考</p>
<p><a href="http://zouruixin.iteye.com/blog/1441846" target="_blank" rel="external">http://zouruixin.iteye.com/blog/1441846</a>，觉得这个讲解的很明白。</p>
<p>正如上面流程中说到的HandlerAdapter将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；这里的处理器指的应该就是Controller。</p>
<p>由于Controller的类型不同，有多种实现方式，那么调用方式就不是确定的，如果需要直接调用Controller方法，需要在代码中写成如下形式： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(mappedHandler.getHandler() <span class="keyword">instanceof</span> MultiActionController)&#123;  </div><div class="line">   ((MultiActionController)mappedHandler.getHandler()).xxx  </div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(mappedHandler.getHandler() <span class="keyword">instanceof</span> XXX)&#123;  </div><div class="line">    ...  </div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(...)&#123;  </div><div class="line">   ...  </div><div class="line">&#125;  </div><div class="line">...</div></pre></td></tr></table></figure>
<p>这样假设如果我们增加一个HardController，就要在代码中加入一行 if(mappedHandler.getHandler() instanceof  HardController)<br>这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 –  对扩展开放，对修改关闭。 </p>
<p>因此Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类，<br>让适配器代替Controller执行相应的方法。这样在扩展Controller 时，只需要增加一个适配器类就完成了SpringMVC的扩展了，真的是很精巧的做法！ </p>
<p>在一个典型的SpringMVC调用中，</p>
<ol>
<li>HandlerExecutionChain中封装handler对象就是用@Controller注解标识的类的一个实例</li>
<li>根据类级别和方法级别的@RequestMapping注解，由默认注册的RequestMappingHandlerMapping生成HandlerExecutionChain对象</li>
<li>RequestMappingHandlerAdapter类来执行这个HandlerExecutionChain对象</li>
<li>生成最终的ModelAndView对象后，再由具体的View对象的render方法渲染视图。</li>
</ol>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><ol>
<li>把源码编译后导入到eclipse里面以后看源码的效率提高了不少，学到一个Ctrl+T快捷键</li>
<li>了解整个MVC框架处理请求的流程</li>
<li><p>学习了两个新的设计模式：</p>
<ul>
<li>策略模式</li>
<li>适配器模式</li>
</ul>
</li>
<li>进一步体会到了Spring在设计上的优雅与巧妙，Spring中的一个原则：开闭原则：对扩展开放，对修改关闭<ul>
<li>类中所有的变量声明，几乎都以接口的形式给出，并没有绑定在具体的实现类上。</li>
<li>使用模版方法模式，在父类中对基础行为进行定义，让子类实现模版方法扩展行为。</li>
</ul>
</li>
</ol>
<h1 id="四、参考地址"><a href="#四、参考地址" class="headerlink" title="四、参考地址"></a>四、参考地址</h1><p><a href="http://blog.csdn.net/zuoluoboy/article/details/19766131" target="_blank" rel="external">http://blog.csdn.net/zuoluoboy/article/details/19766131</a></p>
<p><a href="http://jinnianshilongnian.iteye.com/blog/1594806" target="_blank" rel="external">http://jinnianshilongnian.iteye.com/blog/1594806</a></p>
<p><a href="http://www.cnblogs.com/java-my-life/archive/2012/05/10/2491891.html" target="_blank" rel="external">http://www.cnblogs.com/java-my-life/archive/2012/05/10/2491891.html</a></p>
<p><a href="http://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html" target="_blank" rel="external">http://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html</a></p>
<p><a href="https://my.oschina.net/lichhao/blog/99039" target="_blank" rel="external">https://my.oschina.net/lichhao/blog/99039</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中的线程池]]></title>
      <url>http://yoursite.com/2017/01/07/MultiThreading/Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      <content type="html"><![CDATA[<p>大多数并发应用程序是以执行任务（task）为基本单位进行管理的。通常情况下，我们会为每个任务单独创建一个线程来执行。这样会带来两个问题：</p>
<ol>
<li>大量的线程（&gt;100）会消耗系统资源，使线程调度的开销变大，引起性能下降；</li>
<li>对于生命周期短暂的任务，频繁地创建和消亡线程并不是明智的选择。因为创建和消亡线程的开销可能会大于使用多线程带来的性能好处。</li>
</ol>
<p>一种更加合理的使用多线程的方法是使用线程池（Thread Pool）。 java.util.concurrent 提供了一个灵活的线程池实现：Executor 框架。</p>
<h1 id="一、Executor"><a href="#一、Executor" class="headerlink" title="一、Executor"></a>一、Executor</h1><p>Executor框架可以用于异步任务执行，而且支持很多不同类型的任务执行策略。它还为任务提交和任务执行之间的解耦提供了标准的方法，为使用 Runnable 描述任务提供了通用的方式。 Executor 的实现还提供了对生命周期的支持和 hook 函数，可以添加如统计收集、应用程序管理机制和监视器等扩展。</p>
<h2 id="1、Executor接口"><a href="#1、Executor接口" class="headerlink" title="1、Executor接口"></a>1、Executor接口</h2><p>并发编程的一种编程方式是把任务拆分为一些列的小任务，即Runnable，然后在提交给一个Executor执行，<strong>Executor.execute(Runnalbe)</strong> 。Executor在执行时使用内部的线程池完成操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该接口只有一个execute方法，执行已提交的 Runnable 任务对象。此接口提供一种将任务提交与每个任务将如何运行的机制（包括线程使用的细节、调度等）分离开来的方法。通常使用 Executor 而不是显式地创建线程。</p>
<p>Executor基于生产者消费者模式，提交任务的操作相当于生产者（生产待完成的工作单元），执行任务的线程则相当于消费者（执行完这些工作单元）。如果在程序中实现一个生产者消费者的设计，那么最简单的方式通常就是使用Executor。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Executor executor=Executors.newCachedThreadPool();</div><div class="line">    executor.execute(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">            System.out.println(<span class="string">"hello"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码有两个问题：</p>
<ol>
<li>使用了Executors类的工厂方法来获得了一个Executor的实例，这个类会在下面详细介绍</li>
<li>这个程序会一直运行下去，不会终止。因为这个接口中并没有用于管理生命周期的方法。</li>
</ol>
<h2 id="2、ExecutorService接口"><a href="#2、ExecutorService接口" class="headerlink" title="2、ExecutorService接口"></a>2、ExecutorService接口</h2><p>ExecutorService继承自Executor接口，添加了一些用于生命周期管理的方法，同时还有一些用于任务提交的遍历方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException;</div><div class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</div><div class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</div><div class="line">    Future&lt;?&gt; submit(Runnable task);</div><div class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</div><div class="line">        <span class="keyword">throws</span> InterruptedException;</div><div class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</div><div class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</div><div class="line">        <span class="keyword">throws</span> InterruptedException;</div><div class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException;</div><div class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></div><div class="line">                    <span class="keyword">long</span> timeout, TimeUnit unit)</div><div class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-1、shutdown与shutdownNow"><a href="#2-1、shutdown与shutdownNow" class="headerlink" title="2.1、shutdown与shutdownNow"></a>2.1、shutdown与shutdownNow</h3><p>这两个方法都用于终止ExecutorService。</p>
<ul>
<li><p>shutdown方法将执行平缓的关闭过程：不再接受新的任务，同时等待已经提交的任务执行完成（包括那些还没开始执行的任务）。</p>
</li>
<li><p>shutdownNow() 方法试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。</p>
<p> 无法保证能够停止正在处理的活动执行任务，但是会尽力尝试。例如，通过 Thread.interrupt() 来取消典型的实现，所以任何任务无法响应中断都可能永远无法终止。</p>
<p>​</p>
</li>
</ul>
<h2 id="2-2、submit方法"><a href="#2-2、submit方法" class="headerlink" title="2.2、submit方法"></a>2.2、submit方法</h2><p>submit方法是execute的一个扩展，它传入的参数是可返回值的Callable。</p>
<ul>
<li>\<t> Future\<t> submit(Callable\<t> task)： 提交一个返回值的任务用于执行，返回一个表示任务的返回结果的 Future。该 Future 的 get 方法在成功完成时将会返回该任务的结果。</t></t></t></li>
<li>\<t> Future\<t> submit(Runnable task,T result):交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。该 Future 的 get 方法在成功完成时将会返回给定的结果。 result表示返回的结果</t></t></li>
<li>Future&lt;?&gt; submit(Runnable task)：提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。该 Future 的 get 方法在成功完成时将会返回 null。</li>
</ul>
<h2 id="3、Excutors类"><a href="#3、Excutors类" class="headerlink" title="3、Excutors类"></a>3、Excutors类</h2><p>Executors类，提供了一系列工厂方法用于创建线程池，返回的线程池都实现了ExecutorService接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    ExecutorService executor1=Executors.newFixedThreadPool(nThreads);</div><div class="line">    ExecutorService executor2=Executors.newCachedThreadPool();</div><div class="line">    ExecutorService executor3=Executors.newSingleThreadExecutor();</div><div class="line">    ExecutorService executor4=Executors.newScheduledThreadPool(corePoolSize);		</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><p>newFixedThreadPool：</p>
<p>创建一个固定长度的线程池，每当提交一个任务时就创建一个线程，直到达到线程池的最大数量，这时线程池的规模将不再变化。如果某个线程由于发生了未预期的Exception而结束，那么线程池会补充一个新的线程。</p>
</li>
<li><p>newCachedThreadPool：</p>
<p>创建一个可缓存的线程池，如果线程池当前规模超过了处理需求时，那么将回收空闲线程，而当需求增加时，则可以添加新的线程，线程池的规模不受任何限制。</p>
</li>
<li><p>newSingleThreadExecutor：</p>
<p>单线程的Executor，它创建单个工作者线程来执行任务，如果这个线程异常结束，会创建一个线程来替代。</p>
<p>newSingleThreadExecutor能够确保依照任务在队列中的顺序来串行执行。</p>
</li>
<li><p>newScheduledThreadPool：</p>
<p>创建一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。</p>
</li>
</ol>
<p>newFixedThreadPool和newCachedThreadPool这两个方法都返回ThreadPoolExecutor实例，这些实例可以直接用来构造专门用途的executor。</p>
<h1 id="二、ThreadPoolExecutor"><a href="#二、ThreadPoolExecutor" class="headerlink" title="二、ThreadPoolExecutor"></a>二、ThreadPoolExecutor</h1><p>ThreadPoolExecutor是ExecutorService的一个实现类，它使用可能的几个池线程之一执行每个提交的任务，通常使用 Executors 工厂方法配置。</p>
<p>获取ThreadPoolExecutor实例有一下几个方法：</p>
<ul>
<li>new关键词调用构造函数</li>
<li>Executors工厂方法获取<ul>
<li>Executors.newCachedThreadPool()</li>
<li>Executors.newFixedThreadPool(int)</li>
<li>Executors.newSingleThreadExecutor()</li>
</ul>
</li>
</ul>
<p>通过Executors类获取的三种上面已经介绍过，它们为大多数使用场景预定义了设置。如果需要自己定制属性，那么就需要通过构造函数显式的创建，构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line">                          <span class="keyword">int</span> maximumPoolSize,</div><div class="line">                          <span class="keyword">long</span> keepAliveTime,</div><div class="line">                          TimeUnit unit,</div><div class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                          ThreadFactory threadFactory,</div><div class="line">                          RejectedExecutionHandler handler) &#123;&#125;</div></pre></td></tr></table></figure>
<h2 id="1、线程池的大小"><a href="#1、线程池的大小" class="headerlink" title="1、线程池的大小"></a>1、线程池的大小</h2><p>线程池的大小由一下两个参数决定：</p>
<ul>
<li>corePoolSize：线程池的基本大小，</li>
<li>maximumPoolSize：线程池的最大大小</li>
</ul>
<ul>
<li>当新任务在方法 execute(java.lang.Runnable) 中提交时，如果运行的线程少于 corePoolSize，则创建新线程来处理请求，即使有线程是空闲的。</li>
<li>如果运行的线程多于corePoolSize而少于maximumPoolSize，则仅当队列满时才创建新线程。</li>
<li>如果设置的 corePoolSize 和 maximumPoolSize 相同，则创建了固定大小的线程池，即newFixedThreadPool</li>
<li>如果将 maximumPoolSize 设置为基本的无界值（如 Integer.MAX_VALUE），则允许池适应任意数量的并发任务，即newCachedThreadPool</li>
</ul>
<h2 id="2、任务队列"><a href="#2、任务队列" class="headerlink" title="2、任务队列"></a>2、任务队列</h2><p>如果提交的任务超过了线程池的处理速度，那么新到达的请求将积累起来。在ThreadPoolExecutor中有一个专门管理这些Runnable的队列。它们会在这个队列中等待。基本的任务排队方法有三种：</p>
<ul>
<li>无界队列</li>
<li>有界队列</li>
<li>同步移交</li>
</ul>
<h3 id="2-1、无界队列"><a href="#2-1、无界队列" class="headerlink" title="2.1、无界队列"></a>2.1、无界队列</h3><p>newFixedThreadPool(int)和newSingleThreadExecutor()在默认情况下使用一个无界的LinkedBlockingQueue。如果所有的工作者线程都处于忙碌状态，那么任务将在队列中等候。</p>
<p>如果任务持续快速到达，并且超过了线程池处理它们的速度，那么队列将无限制的增长。</p>
<h3 id="2-2、有界队列"><a href="#2-2、有界队列" class="headerlink" title="2.2、有界队列"></a>2.2、有界队列</h3><p>一种更稳妥的资源管理策略是使用有界队列，例如ArrayBlockingQueue，有界的LinkedBlockingQueue、PriorityBlockingQueue。有界队列有助于避免资源耗尽的情况，但同时也带来一个新的问题，<strong>当队列填满之后，新来的任务怎么办？</strong>这个主要涉及到下面的饱和策略。</p>
<p>队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销。</p>
<p>LinkedBlockingQueue或者ArrayBlockingQueue可以保证先进先出，而如果使用PriorityBlockingQueue，则可以根据优先级来安排。</p>
<h3 id="2-3、同步移交"><a href="#2-3、同步移交" class="headerlink" title="2.3、同步移交"></a>2.3、同步移交</h3><p>工作队列的默认选项是 SynchronousQueue，它将任务直接提交给线程而不保持它们。</p>
<p>SynchronousQueue不是一个真正的队列，而是一种在线程之间进行移交的机制。</p>
<ul>
<li>要将一个元素放入SynchronousQueue中，必须有一个线程正在等待接收这个元素。</li>
<li>如果没有线程正在等待，并且线程池的大小小于最大值，那么ThreadPoolExecutor会创建一个新的线程。</li>
<li>否则，根据饱和策略，这个任务将会被拒绝。</li>
</ul>
<p>newCachedThreadPool()返回的ThreadPoolExecutor中就使用了SynchronousQueue。</p>
<p>对于Executor，newCachedThreadPool工厂方法是一个很好的默认选择，它能提供比固定大小的线程池更好的排队性能。</p>
<h2 id="3、饱和策略"><a href="#3、饱和策略" class="headerlink" title="3、饱和策略"></a>3、饱和策略</h2><p>上面提到当有界队列被填满或者SynchronousQueue超出设置的最大值的时候，饱和策略开始发挥作用。</p>
<p>构造函数中看到了最后一个参数RejectedExecutionHandler handler就是饱和策略。</p>
<p>JDK提供了几种不同的实现：</p>
<ul>
<li>AbortPolicy</li>
<li>CallerRunsPolicy</li>
<li>DiscardPolicy</li>
<li>DiscardOldestPolicy</li>
</ul>
<h3 id="3-1、Abort-中止"><a href="#3-1、Abort-中止" class="headerlink" title="3.1、Abort 中止"></a>3.1、Abort 中止</h3><p>中止策略是默认的饱和策略，就是中止任务，该策略将抛出RejectedExecutionException。调用者可以捕获这个异常然后去编写代码处理异常。</p>
<h3 id="3-2、Discard-抛弃"><a href="#3-2、Discard-抛弃" class="headerlink" title="3.2、Discard 抛弃"></a>3.2、Discard 抛弃</h3><p>当新提交的任务无法保存到队列中等待执行时</p>
<ul>
<li>DiscardPolicy会稍稍的抛弃该任务</li>
<li>DiscardOldestPolicy则会抛弃最旧的（下一个将被执行的任务），然后尝试重新提交新的任务。</li>
</ul>
<p>如果工作队列是那个优先级队列时，搭配DiscardOldestPolicy饱和策略会导致优先级最高的那个任务被抛弃，所以两者不要组合使用。</p>
<h3 id="3-3、CallerRuns-调用者运行"><a href="#3-3、CallerRuns-调用者运行" class="headerlink" title="3.3、CallerRuns 调用者运行"></a>3.3、CallerRuns 调用者运行</h3><p>CallerRunsPolicy是“调用者运行”策略，实现了一种调节机制 。它不会抛弃任务，也不会抛出异常。 而是将任务回退到调用者。它不会在线程池中执行任务，而是在一个调用了Executor的线程中执行该任务。</p>
<h2 id="4、线程工厂"><a href="#4、线程工厂" class="headerlink" title="4、线程工厂"></a>4、线程工厂</h2><p>每当线程池需要创建一个线程时，都是通过线程工厂方法来完成的。而不是传统的new Thread。</p>
<p>默认情况下为Executors.defaultThreadFactory()，ThreadFactory接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadFactory</span> </span>&#123;  </div><div class="line">    <span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们也可以采用自定义的ThreadFactory工厂，增加对线程创建与销毁等更多的控制，并且作为参数来传入线程池中，这样就可以使用自己定义的线程工厂来创建线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadFactoryDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">        <span class="keyword">private</span> Runnable target;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WorkerThread</span><span class="params">(Runnable target, <span class="keyword">int</span> cnt)</span></span>&#123;</div><div class="line">            <span class="keyword">super</span>(String.valueOf(cnt));</div><div class="line">            <span class="keyword">this</span>.target=target;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">try</span>&#123;</div><div class="line">                target.run();</div><div class="line">            &#125;<span class="keyword">finally</span>&#123;				</div><div class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"end"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;		</div><div class="line">    &#125;	</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        ExecutorService executorService=Executors.newCachedThreadPool(<span class="keyword">new</span> ThreadFactory()&#123;</div><div class="line">            <span class="keyword">private</span> AtomicInteger count=<span class="keyword">new</span> AtomicInteger();			</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">                <span class="keyword">int</span> cnt=count.incrementAndGet();</div><div class="line">                System.out.println(<span class="string">"Thread: "</span>+cnt+<span class="string">" created"</span>);						</div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> WorkerThread(r, cnt);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">        executorService.execute(<span class="keyword">new</span> ThreadFactoryDemo());</div><div class="line">        executorService.execute(<span class="keyword">new</span> ThreadFactoryDemo());</div><div class="line">        executorService.execute(<span class="keyword">new</span> ThreadFactoryDemo());</div><div class="line">        executorService.execute(<span class="keyword">new</span> ThreadFactoryDemo());</div><div class="line">        executorService.execute(<span class="keyword">new</span> ThreadFactoryDemo());</div><div class="line">        executorService.execute(<span class="keyword">new</span> ThreadFactoryDemo());</div><div class="line">        executorService.execute(<span class="keyword">new</span> ThreadFactoryDemo());</div><div class="line">      	System.out.println(<span class="string">"shutdown"</span>);</div><div class="line">        executorService.shutdown();</div><div class="line"> </div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Thread: "</span>+Thread.currentThread().getName()+<span class="string">" run"</span>);		</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Thread: 1 created</div><div class="line">Thread: 2 created</div><div class="line">Thread: 1 run</div><div class="line">Thread: 2 run</div><div class="line">Thread: 3 created</div><div class="line">Thread: 3 run</div><div class="line">Thread: 2 run</div><div class="line">Thread: 1 run</div><div class="line">Thread: 4 created</div><div class="line">Thread: 3 run</div><div class="line">shutdown</div><div class="line">Thread: 4 run</div><div class="line">4end</div><div class="line">2end</div><div class="line">1end</div><div class="line">3end</div></pre></td></tr></table></figure>
<p>每次的输出都不确定，因为线程池不一定会创建多少个线程，由于任务执行的比较快，有可能一个线程执行多次任务，这样虽然打印出的run与输入的相同，但是却不一定创建了那么多个数量的线程，这也体现出了使用线程池的优势，就是减少了多次线程创建与销毁所消耗的时间。</p>
<h1 id="三、参考地址"><a href="#三、参考地址" class="headerlink" title="三、参考地址"></a>三、参考地址</h1><p><a href="http://blog.csdn.net/linghu_java/article/details/17123057" target="_blank" rel="external">http://blog.csdn.net/linghu_java/article/details/17123057</a></p>
<p><a href="http://www.cnblogs.com/xingele0917/p/4110634.html" target="_blank" rel="external">http://www.cnblogs.com/xingele0917/p/4110634.html</a></p>
<p><a href="http://guojuanjun.blog.51cto.com/277646/650981/" target="_blank" rel="external">http://guojuanjun.blog.51cto.com/277646/650981/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[面试题：三个线程循环打印ABC]]></title>
      <url>http://yoursite.com/2017/01/07/MultiThreading/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%BE%AA%E7%8E%AF%E6%89%93%E5%8D%B0ABC/</url>
      <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABCPrinter</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> cnt=<span class="number">1</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock=<span class="keyword">new</span> Object();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ABCPrinter</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.num=num;	</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">            <span class="keyword">synchronized</span>(lock)&#123;</div><div class="line">                <span class="keyword">while</span>(cnt%<span class="number">3</span>!=num)&#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        lock.wait();</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                System.out.println((<span class="keyword">char</span>)(<span class="string">'A'</span>+num));</div><div class="line">                cnt++;</div><div class="line">                lock.notifyAll();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line">     * await与notify</div><div class="line">     */</div><div class="line">    <span class="keyword">static</span> Lock lock2=<span class="keyword">new</span> ReentrantLock();</div><div class="line">    <span class="keyword">static</span> Condition[] conditions=<span class="keyword">new</span> Condition[]&#123;lock2.newCondition(), lock2.newCondition(), lock2.newCondition()&#125;;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</div><div class="line">        <span class="keyword">private</span> Condition[] conditions;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Printer</span><span class="params">(<span class="keyword">int</span> num, Condition[] conditions)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.num=num;</div><div class="line">            <span class="keyword">this</span>.conditions=conditions;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                lock2.lock();;</div><div class="line">                <span class="keyword">try</span>&#123;</div><div class="line">                    <span class="keyword">while</span>(cnt%<span class="number">3</span>!=num)&#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            conditions[num].await();</div><div class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                            e.printStackTrace();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    System.out.println((<span class="keyword">char</span>)(<span class="string">'A'</span>+num));</div><div class="line">                    cnt++;</div><div class="line">                    conditions[cnt%<span class="number">3</span>].signal();					</div><div class="line">                &#125;<span class="keyword">finally</span>&#123;</div><div class="line">                    lock2.unlock();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;		</div><div class="line">    &#125;	</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">//		new Thread(new ABCPrinter(0)).start();</span></div><div class="line"><span class="comment">//		new Thread(new ABCPrinter(1)).start();</span></div><div class="line"><span class="comment">//		new Thread(new ABCPrinter(2)).start();</span></div><div class="line">        <span class="comment">//方法二</span></div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Printer(<span class="number">0</span>, conditions)).start();</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Printer(<span class="number">1</span>, conditions)).start();</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Printer(<span class="number">2</span>, conditions)).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两种方法是自己想的，一个是用了wait-notify，第二种用了await-signal，主体思想都是一样的，构造线程的时候指定一个字母，让它只打印这个，再设置一个静态变量，不停的增长，然后每个线程都去检测，如果轮到自己了就打印，不是自己就继续等待，考察的就是线程间通信。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据库事务与隔离级别]]></title>
      <url>http://yoursite.com/2017/01/03/Database/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
      <content type="html"><![CDATA[<h1 id="一、数据库事务"><a href="#一、数据库事务" class="headerlink" title="一、数据库事务"></a>一、数据库事务</h1><p>事务是数据库中最常见的概念</p>
<h2 id="1、事务的特性"><a href="#1、事务的特性" class="headerlink" title="1、事务的特性"></a>1、事务的特性</h2><p>事务很经典的就是ACID四个特性：</p>
<ol>
<li><p>原子性Atomic：</p>
<p>原子性指组成一个事务的多个数据库操作是一个不可分割的原子单元，只有所有的操作执行成功，整个事务才提交，事务中任何一个数据库操作失败，已经执行的任何操作都必须撤销，让数据库返回到初始状态。</p>
</li>
<li><p>一致性Consistency：</p>
<p>事务操作成功后，数据库所处的状态和它的业务规则是一致的，即数据不会被破坏。</p>
<p>如从A账户转账100元到B账户，不管操作成功与否，A和B的存款总额是不变的。</p>
</li>
<li><p>隔离性Isolation：</p>
<p>在并发数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对对方产生干扰。</p>
<p>准确地说，并非要求做到完全无干扰，数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性越好，但并发性越弱。</p>
</li>
<li><p>持久性Durability：</p>
<p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
</li>
</ol>
<p>在这些事务特性中，数据“一致性”是最终目标，其他的特性都是为达到这个目标的措施、要求或手段。 </p>
<ul>
<li><p>对于原子性、一致性和持久性，数据库一般采用重执行日志来保证。</p>
<blockquote>
<p>重执行日志记录了数据库变化的每一个动作，数据库在一个事务中执行一部分操作后发生错误退出，数据库即可以根据重执行日志撤销已经执行的操作。此外，对于已经提交的事务，即使数据库崩溃，在重启数据库时也能够根据日志对尚未持久化的数据进行相应的重执行操作。 </p>
</blockquote>
</li>
<li><p>关于隔离性，则更为复杂一点，和Java程序采用锁机制进行线程同步相类似，数据库采用锁机制来保证事务的隔离性。</p>
<blockquote>
<p>当多个事务试图对相同的数据进行操作时，只有持有锁的事务才能操作数据，直到前一个事务完成后，后面的事务才有机会对数据进行操作。</p>
</blockquote>
</li>
</ul>
<h1 id="二、隔离性相关"><a href="#二、隔离性相关" class="headerlink" title="二、隔离性相关"></a>二、隔离性相关</h1><p>对应的，就像Java中有若干死锁等并发性问题，数据库也有类似的问题。</p>
<h2 id="1、数据库并发的问题"><a href="#1、数据库并发的问题" class="headerlink" title="1、数据库并发的问题"></a>1、数据库并发的问题</h2><p>一个数据库可能拥有多个访问客户端，这些客户端都可以并发方式访问数据库。数据库中的相同数据可能同时被多个事务访问，如果没有采取必要的隔离措施，就会导致各种并发问题，破坏数据的完整性。这些问题主要有两大类五种：</p>
<ul>
<li>数据读问题：<ol>
<li>脏读</li>
<li>不可重复读</li>
<li>幻读</li>
</ol>
</li>
<li>数据更新问题<ol>
<li>第一类丢失更新</li>
<li>第二类丢失更新</li>
</ol>
</li>
</ul>
<h3 id="1-1、脏读dirty-read"><a href="#1-1、脏读dirty-read" class="headerlink" title="1.1、脏读dirty read"></a>1.1、脏读dirty read</h3><p>脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/Database/1.png?raw=true" alt=""></p>
<h3 id="1-2、不可重复读unrepeatable-read"><a href="#1-2、不可重复读unrepeatable-read" class="headerlink" title="1.2、不可重复读unrepeatable read"></a>1.2、不可重复读unrepeatable read</h3><p>不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/Database/2.png?raw=true" alt=""></p>
<h3 id="1-3、幻读phantom-read"><a href="#1-3、幻读phantom-read" class="headerlink" title="1.3、幻读phantom read"></a>1.3、幻读phantom read</h3><p>A事务读取B事务提交的新增数据，这时A事务将出现幻象读的问题。幻象读一般发生在计算统计数据的事务中，举一个例子，假设银行系统在同一个事务中，两次统计存款账户的总金额，在两次统计过程中，刚好新增了一个存款账户，并存入100元，这时，两次统计的总金额将不一致： </p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/Database/3.png?raw=true" alt=""></p>
<h4 id="不可重复读与幻读"><a href="#不可重复读与幻读" class="headerlink" title="不可重复读与幻读"></a>不可重复读与幻读</h4><p>幻读和不可重复读都是读取了另一条已经提交的事务，但却是两个不同的概念：</p>
<ul>
<li>不可重复读查询的都是同一个数据项（被更改），避免这种情况只要添加行级锁即可。</li>
<li>而幻读针对的是一批数据整体（比如数据的个数），避免这种情况必须添加表级锁-将整个表锁定以防止新增数据。</li>
</ul>
<h3 id="1-4、第一类丢时更新"><a href="#1-4、第一类丢时更新" class="headerlink" title="1.4、第一类丢时更新"></a>1.4、第一类丢时更新</h3><p>A事务撤销时，把已经提交的B事务的更新数据覆盖了。这种错误可能造成很严重的问题，通过下面的账户取款转账就可以看出来：</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/Database/4.png?raw=true" alt=""></p>
<p>A事务在撤销时，“不小心”将B事务已经转入账户的金额给抹去了。 </p>
<h3 id="1-5、第二类丢时更新"><a href="#1-5、第二类丢时更新" class="headerlink" title="1.5、第二类丢时更新"></a>1.5、第二类丢时更新</h3><p>A事务覆盖B事务已经提交的数据，造成B事务所做操作丢失： </p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/Database/5.png?raw=true" alt=""></p>
<p>上面的例子里由于支票转账事务覆盖了取款事务对存款余额所做的更新，导致银行最后损失了100元，相反如果转账事务先提交，那么用户账户将损失100元。 </p>
<h2 id="2、数据库隔离级别"><a href="#2、数据库隔离级别" class="headerlink" title="2、数据库隔离级别"></a>2、数据库隔离级别</h2><p>尽管数据库为用户提供了锁的DML操作方式，但直接使用锁管理是非常麻烦的，因此数据库为用户提供了自动锁机制。只要用户指定会话的事务隔离级别，数据库就会分析事务中的SQL语句，然后自动为事务操作的数据资源添加上适合的锁。此外数据库还会维护这些锁，当一个资源上的锁数目太多时，自动进行锁升级以提高系统的运行性能，而这一过程对用户来说完全是透明的。 </p>
<p>ANSI/ISO SQL 92标准定义了4个等级的事务隔离级别:</p>
<ol>
<li>Read uncommited 读未提交：级别最低，主要提供非阻塞读能力</li>
<li>Read committed 读已提交</li>
<li>Repeatable read 可重复读，MYSQL中默认的隔离级别</li>
<li>Serializable 串行化：级别最高</li>
</ol>
<p>在相同数据环境下，使用相同的输入，执行相同的工作，根据不同的隔离级别，可以导致不同的结果。不同事务隔离级别能够解决的数据并发问题的能力是不同的：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
<th>第一类丢时更新</th>
<th>第二类丢失更新</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read uncommited</td>
<td>允许</td>
<td>允许</td>
<td>允许</td>
<td>不允许</td>
<td>允许</td>
</tr>
<tr>
<td>Read committed</td>
<td>不允许</td>
<td>允许</td>
<td>允许</td>
<td>不允许</td>
<td>允许</td>
</tr>
<tr>
<td>Repeatable read</td>
<td>不允许</td>
<td>不允许</td>
<td>允许</td>
<td>不允许</td>
<td>不允许</td>
</tr>
<tr>
<td>Serializable</td>
<td>不允许</td>
<td>不允许</td>
<td>不允许</td>
<td>不允许</td>
<td>不允许</td>
</tr>
</tbody>
</table>
<p>事务的隔离级别和数据库并发性是对立的，两者此增彼长。一般来说，使用READ UNCOMMITED隔离级别的数据库拥有最高的并发性和吞吐量，而使用SERIALIZABLE隔离级别的数据库并发性最低。 </p>
<h2 id="3、InnoDB引擎的锁机制"><a href="#3、InnoDB引擎的锁机制" class="headerlink" title="3、InnoDB引擎的锁机制"></a>3、InnoDB引擎的锁机制</h2><p>之所以以InnoDB为主介绍锁，是因为InnoDB支持事务，支持行锁和表锁用的比较多，Myisam不支持事务，只支持表锁</p>
<ul>
<li>共享锁(S)：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li>
<li>排他锁(X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</li>
<li>意向共享锁(IS)：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</li>
<li>意向排他锁(IX)：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</li>
</ul>
<p>说明：</p>
<ol>
<li>共享锁和排他锁都是行锁，意向锁都是表锁，应用中我们只会使用到共享锁和排他锁，意向锁是mysql内部使用的，不需要用户干预。</li>
<li>对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X）；对于普通SELECT语句，InnoDB不会加任何锁，事务可以通过以下语句显示给记录集加共享锁或排他锁：<ul>
<li>共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。</li>
<li>排他锁（X）：SELECT * FROM table_name WHERE … FOR UPDATE。</li>
</ul>
</li>
<li>InnoDB行锁是通过给索引上的索引项加锁来实现的，因此InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</li>
</ol>
<h1 id="三、参考地址"><a href="#三、参考地址" class="headerlink" title="三、参考地址"></a>三、参考地址</h1><p><a href="http://www.iteye.com/topic/1124043" target="_blank" rel="external">http://www.iteye.com/topic/1124043</a></p>
<p><a href="http://www.cnblogs.com/fjdingsd/p/5273008.html" target="_blank" rel="external">http://www.cnblogs.com/fjdingsd/p/5273008.html</a></p>
<p><a href="http://blog.csdn.net/pingnanlee/article/details/41824389" target="_blank" rel="external">http://blog.csdn.net/pingnanlee/article/details/41824389</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据库中的乐观锁与悲观锁]]></title>
      <url>http://yoursite.com/2017/01/03/Database/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81%E2%80%8B/</url>
      <content type="html"><![CDATA[<h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><p>好像没有找到很官方的关于乐观锁与悲观锁的定义</p>
<ul>
<li>悲观锁：顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</li>
<li>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。</li>
</ul>
<p>并发控制机制：</p>
<ul>
<li>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</li>
<li>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。<strong>乐观锁不能解决脏读的问题。</strong></li>
</ul>
<h2 id="2、乐观锁"><a href="#2、乐观锁" class="headerlink" title="2、乐观锁"></a>2、乐观锁</h2><p>乐观锁比较普遍的方法就是使用数据版本，这种方法不需要在数据库上增加额外的设置，只需要在表中增加一个字段，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。</p>
<p>当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</p>
<p> 具体的例子在<a href="http://www.javaweb1024.com/java/JavaWebzhongji/2015/09/06/847.html" target="_blank" rel="external">http://www.javaweb1024.com/java/JavaWebzhongji/2015/09/06/847.html</a></p>
<p>这篇博客介绍的很清楚</p>
<h2 id="3、悲观锁"><a href="#3、悲观锁" class="headerlink" title="3、悲观锁"></a>3、悲观锁</h2><p>悲观锁则是直接使用数据库的锁机制。比如SQL SERVER 的TABLOCKX（排它表锁） 此选项被选中时，SQL  Server  将在整个表上置排它锁直至该命令或事务结束。这将防止其他进程读取或修改表中的数据。</p>
<p>注意更新锁和共享锁是不冲突的,也就是其他用户还可以查询此表的内容,但是和更新锁和排它锁是冲突的.所以其他的更新用户就会阻塞.</p>
<h2 id="4、比较"><a href="#4、比较" class="headerlink" title="4、比较"></a>4、比较</h2><p>在实际应用中，如果并发量不大且不允许脏读，可以使用悲观锁解决并发问题；但如果系统的并发非常大的话,悲观锁定会带来非常大的性能问题,所以我们就要选择乐观锁定的方法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据库的索引]]></title>
      <url>http://yoursite.com/2017/01/03/Database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/</url>
      <content type="html"><![CDATA[<p>在了解索引之前，先了解一下MySQL的两种最常见的存储引擎。</p>
<h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="1、MYSQL存储引擎–MyISAM与InnoDB"><a href="#1、MYSQL存储引擎–MyISAM与InnoDB" class="headerlink" title="1、MYSQL存储引擎–MyISAM与InnoDB"></a>1、MYSQL存储引擎–MyISAM与InnoDB</h2><p>InnoDB和MyISAM是许多人在使用MySQL时最常用的两个表类型，这两个表类型各有优劣，视具体应用而定。</p>
<p>最常见的差别就是InnoDB支持<strong>事务处理</strong>和<strong>外键</strong>与<strong>行级锁</strong>。 MyISAM类型的表强调的是性能，其执行速度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持以及外部键等高级数据库功能。</p>
<p>其他方面也有一些差别：</p>
<ol>
<li><p>InnoDB不支持FULLTEXT类型的索引。</p>
</li>
<li><p>InnoDB 中不保存表的具体行数</p>
<p>也就是说，执行select count() from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含 where条件时，两种表的操作是一样的。</p>
</li>
<li><p>对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。</p>
</li>
<li><p>DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。</p>
</li>
<li><p>LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。</p>
</li>
<li><p>InnoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update table set num=1 where name like “%aaa%”</p>
<p>还有一种说法：</p>
<blockquote>
<p>InnoDB行锁是通过给索引上的索引项加锁来实现的，因此InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</p>
</blockquote>
</li>
<li><p>两者索引的实现方式也不同，下面会单独分析</p>
</li>
</ol>
<p>个人感觉，InnoDB更高级一点，支持事务外键和行级锁等特性，但是也牺牲了一定的性能作为代价，对于写入操作不是很频繁的，MyISAM可能更灵活一点。</p>
<p>参考的博客中给出了MyISAM的几点优势：</p>
<ol>
<li>平台上承载的大部分项目是读多写少的项目，而MyISAM的读性能是比Innodb强不少的。</li>
<li>MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。</li>
<li>从接触的应用逻辑来说，select count(*) 和order by 是最频繁的，大概能占了整个sql总语句的60%以上的操作，而这种操作Innodb其实也是会锁表的，很多人以为Innodb是行级锁，那个只是where对它主键是有效，非主键的都会锁全表的。</li>
</ol>
<h2 id="2、B-树与B-树"><a href="#2、B-树与B-树" class="headerlink" title="2、B-树与B+树"></a>2、B-树与B+树</h2><p>B-TREE就是B树，B+TREE就是B+树，后者是前者的变种。</p>
<p>B树的各种变种主要应用与操作系统中磁盘的读取，由于磁盘结构的特殊性，在读取数据时，磁头的定位到一页信息并读出的时间要比读出信息进行检查花的时间要多的多，所以应该尽量减少磁头的移动次数，而B树就是通过减少树的深度来做到这一点的。</p>
<h3 id="2-1、B-TREE"><a href="#2-1、B-TREE" class="headerlink" title="2.1、B-TREE"></a>2.1、B-TREE</h3><p>B树是一种多路搜索树（并不是二叉的），一棵m阶的B 树：</p>
<ol>
<li>定义任意非叶子结点最多只有M个儿子；且M&gt;2；</li>
<li>根结点的儿子数为[2, M]；</li>
<li>除根结点以外的非叶子结点的儿子数为[M/2, M]；</li>
<li>每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）</li>
<li>非叶子结点的关键字个数=指向儿子的指针个数-1；</li>
<li>非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</li>
<li>非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</li>
<li>所有叶子结点位于同一层；</li>
</ol>
<p>如：（M=3）</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/Database/6.png?raw=true" alt=""></p>
<p>B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；</p>
<p><strong>B-树的特点</strong>：</p>
<ol>
<li>关键字集合分布在整颗树中；</li>
<li>任何一个关键字出现且只出现在一个结点中；</li>
<li>搜索有可能在非叶子结点结束；</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找；</li>
<li>自动层次控制；</li>
</ol>
<p>由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率，其最低搜索性能为：</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/Database/7.png?raw=true" alt="img"></p>
<p>其中，M为设定的非叶子结点最多子树个数，N为关键字总数；</p>
<p>所以B树的性能总是等价于二分查找（与M值无关），也就没有B树平衡的问题；</p>
<p>由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并；</p>
<h3 id="2-2、B-TREE"><a href="#2-2、B-TREE" class="headerlink" title="2.2、B+TREE"></a>2.2、B+TREE</h3><p>B+树是B-树的变体，也是一种多路搜索树：其定义基本与B-树同，除了：</p>
<ol>
<li>非叶子结点的子树指针与关键字个数相同；</li>
<li>非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B树是开区间）；</li>
<li>为所有叶子结点增加一个链指针；</li>
<li>所有关键字都在叶子结点出现；</li>
</ol>
<p>如：（M=3）</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/Database/8.png?raw=true" alt=""></p>
<p>B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</p>
<p><strong>B+树的特点</strong>：</p>
<ol>
<li>所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</li>
<li>不可能在非叶子结点命中；</li>
<li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</li>
<li>更适合文件索引系统；</li>
</ol>
<p>还有一种叫B*树，没有遇见过。</p>
<h1 id="二、数据库索引"><a href="#二、数据库索引" class="headerlink" title="二、数据库索引"></a>二、数据库索引</h1><h2 id="1、索引的定义"><a href="#1、索引的定义" class="headerlink" title="1、索引的定义"></a>1、索引的定义</h2><p><strong>数据库索引</strong>，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。它是用于提高数据库表数据访问速度的数据库对象。</p>
<p>优点：</p>
<ol>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>
</ol>
<p>缺点：</p>
<ol>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
</ol>
<h2 id="2、索引的分类"><a href="#2、索引的分类" class="headerlink" title="2、索引的分类"></a>2、索引的分类</h2><p>从不同的角度，索引可以有很多种分类</p>
<h3 id="2-1、索引的种类"><a href="#2-1、索引的种类" class="headerlink" title="2.1、索引的种类"></a>2.1、索引的种类</h3><p>从使用上，索引可以分为普通索引，唯一索引，主键索引与组合索引</p>
<ol>
<li><p>普通索引：这是最基本的MySQL数据库索引，它没有任何限制</p>
<ul>
<li><p>创建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CREATE INDEX indexName ON mytable(username(length));</div></pre></td></tr></table></figure>
</li>
<li><p>删除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DROP INDEX [indexName] ON mytable;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>唯一索引：它与前面的普通索引类似，不同的就是：MySQL数据库索引列的值必须唯一，但允许有空值。</p>
<ul>
<li><p>创建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CREATE UNIQUE INDEX indexName ON mytable(username(length))</div></pre></td></tr></table></figure>
</li>
<li><p>创建表的时候直接指定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, UNIQUE [indexName] (username(length)) );</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
</li>
<li><p>主键索引：它是一种特殊的唯一索引，不允许有空值。</p>
<ul>
<li><p>一般是在建表的时候同时创建主键索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, PRIMARY KEY(ID) );</div></pre></td></tr></table></figure>
</li>
<li><p>查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SHOW INDEX FROM mytable;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>组合索引：</p>
<p>也叫复合索引：Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但<strong>只能是最左侧部分</strong>。例如索引是key index (a,b,c)。可以支持a | a, b |a, b, c 3种组合进行查找，但不支持b, c进行查找。当最左侧字段是常量引用时，索引就十分有效。</p>
<ul>
<li><p>创建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">create index idx1 on table1(col1,col2,col3)</div></pre></td></tr></table></figure>
</li>
<li><p>查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select * from table1 where col1= A and col2= B and col3 = C</div></pre></td></tr></table></figure>
<p>这时候查询优化器,不在扫描表了，而是直接的从索引中拿数据，因为索引中有这些数据，这叫覆盖式查询，这样的查询速度非常快。</p>
</li>
</ul>
</li>
</ol>
<p>利用索引中的附加列，可以缩小搜索的范围，但使用一个具有两列的索引不同于使用两个单独的索引。复合索引的结构与电话簿类似，它首先按姓氏对雇员进行排序，然后按名字对所有姓氏相同的雇员进行排序。如果您知道姓氏，电话簿将非常有用，如果您知道名字和姓氏，电话簿则更为有用，但如果只知道名字而不知道姓氏，电话簿将没有用处。</p>
<p>关于复合索引的注意事项：</p>
<ol>
<li><p>对于复合索引，在查询使用时，最好将条件顺序按找索引的顺序，这样效率最高：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select * from table1 where col1=A AND col2=B AND col3=D</div></pre></td></tr></table></figure>
<pre><code>如果使用` where col2=B AND col1=A` 或者 `where col2=B` 将不会使用索引
</code></pre></li>
<li><p>对一张表来说,如果有一个复合索引 on (col1,col2),就没有必要同时建立一个单索引 on col1;</p>
</li>
<li><p>如果查询条件需要,可以在已有单索引 on col1的情况下,添加复合索引on (col1,col2),对于效率有一定的提高</p>
</li>
<li><p>同时建立多字段(包含5、6个字段)的复合索引没有特别多的好处,相对而言,建立多个窄字段(仅包含一个,或顶多2个字段)的索引可以达到更好的效率和灵活性</p>
</li>
</ol>
<h3 id="2-2、索引的结构"><a href="#2-2、索引的结构" class="headerlink" title="2.2、索引的结构"></a>2.2、索引的结构</h3><p>按照索引的结构，可以分为聚集索引与非聚集索引：</p>
<ol>
<li>聚集索引，表数据按照索引的顺序来存储的。对于聚集索引，叶子结点即存储了真实的数据行，不再有另外单独的数据页。一个表只能包含一个聚集索引。</li>
<li>非聚集索引，表数据存储顺序与索引顺序无关。对于非聚集索引，叶结点包含索引字段值及指向数据页数据行的逻辑指针，该层紧邻数据页，其行数量与数据表行数据量一致。</li>
</ol>
<h3 id="2-3、索引的实现"><a href="#2-3、索引的实现" class="headerlink" title="2.3、索引的实现"></a>2.3、索引的实现</h3><p>从实现方式上，索引分为：</p>
<ol>
<li>B-Tree 索引 </li>
<li>Hash 索引</li>
<li>Fulltext 索引 </li>
<li>R-Tree 索引</li>
</ol>
<h1 id="三、索引的实现"><a href="#三、索引的实现" class="headerlink" title="三、索引的实现"></a>三、索引的实现</h1><p>在 MySQL 中，主要有四种类型的索引，分别为： <strong>B-Tree 索引， Hash 索引， Fulltext 索引和 R-Tree 索引</strong>。我们主要分析B-Tree 索引。</p>
<p>参考的博客中说了很多，但是并不是很赞同。按照我的理解，下面介绍的两个引擎的索引都是通过B+树实现的，因为每次查找都是到了叶子节点才找到最后的结果，区别只是在于叶子节点中到底有没有存放数据。</p>
<h2 id="1、MyISAM的索引实现"><a href="#1、MyISAM的索引实现" class="headerlink" title="1、MyISAM的索引实现"></a>1、MyISAM的索引实现</h2><p><strong>MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。</strong></p>
<h3 id="1-1、主键索引"><a href="#1-1、主键索引" class="headerlink" title="1.1、主键索引"></a>1.1、主键索引</h3><p>MyISAM引擎使用B+Tree作为索引结构，<strong>叶节点的data域存放的是数据记录的地址</strong>。下图是MyISAM主键索引的原理图：</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/Database/9.png?raw=true" alt=""></p>
<p>这里设表一共有三列，假设我们以Col1为主键，图myisam1是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。</p>
<h3 id="1-2、辅助索引"><a href="#1-2、辅助索引" class="headerlink" title="1.2、辅助索引"></a>1.2、辅助索引</h3><p>这个辅助索引我觉得就是上面说的普通索引。</p>
<p><strong>在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。</strong>如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/Database/10.png?raw=true" alt=""></p>
<p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，<strong>MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</strong></p>
<p>MyISAM的索引方式也叫做“<strong>非聚集</strong>”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p>
<h2 id="2、InnoDB的索引实现"><a href="#2、InnoDB的索引实现" class="headerlink" title="2、InnoDB的索引实现"></a>2、InnoDB的索引实现</h2><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同.</p>
<h3 id="2-1、主键索引"><a href="#2-1、主键索引" class="headerlink" title="2.1、主键索引"></a>2.1、主键索引</h3><p>MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而<strong>在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构</strong>，这棵树的叶节点data域保存了完整的数据记录。这个<strong>索引的key是数据表的主键</strong>，因此<strong>InnoDB表数据文件本身就是主索引</strong>。</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/Database/11.png?raw=true" alt=""></p>
<p>可以看到叶节点包含了完整的数据记录。这种索引叫做<strong>聚集索引</strong>。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
<h3 id="2-2、辅助索引"><a href="#2-2、辅助索引" class="headerlink" title="2.2、辅助索引"></a>2.2、辅助索引</h3><p>InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引：</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/Database/12.png?raw=true" alt=""></p>
<p>普通索引中不会保存行的物理位置，而是保存主键的值，所以通过”二级索引”进行查找是先找到主键，再找到行，要进行二次索引查找。</p>
<h2 id="3、对比"><a href="#3、对比" class="headerlink" title="3、对比"></a>3、对比</h2><p> <strong>InnoDB索引</strong>和<strong>MyISAM索引</strong>的区别：</p>
<ul>
<li>一是主索引的区别，InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。</li>
<li>二是辅助索引的区别：InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引没有多大区别。</li>
</ul>
<p><strong>InnoDB 表是基于聚簇索引建立的</strong>。因此InnoDB 的索引能提供一种非常快速的主键查找性能。不过，它的辅助索引（Secondary Index， 也就是非主键索引）也会包含主键列，所以，如果主键定义的比较大，其他索引也将很大。如果想在表上定义 、很多索引，则<strong>争取尽量把主键定义得小一些</strong>。InnoDB 不会压缩索引。</p>
<p>文字符的ASCII码作为比较准则。<strong>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</strong></p>
<p>不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白：</p>
<ol>
<li>为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。</li>
<li>用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一棵B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</li>
</ol>
<h1 id="四、什么时候创建索引"><a href="#四、什么时候创建索引" class="headerlink" title="四、什么时候创建索引"></a>四、什么时候创建索引</h1><p>小米和头条面试都问到了这个问题。</p>
<p>索引是建立在数据库表中的某些列的上面。因此，在创建索引的时候，应该仔细考虑在哪些列上可以创建索引，在哪些列上不能创建索引。</p>
<p>一般来说，应该在这些列上创建索引:</p>
<ul>
<li><p>在经常需要<strong>搜索、排序、WHERE</strong>的列上，可以加快对应操作的速度。</p>
</li>
<li><p>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的。</p>
</li>
<li><p>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度。</p>
</li>
<li><p>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构。</p>
<p>​</p>
</li>
</ul>
<p>同样，对于有些列不应该创建索引。一般来说，不应该创建索引的的这些列具有下列特点：</p>
<ul>
<li>对于那些在查询中很少使用或者参考的列不应该创建索引。</li>
<li>对于那些只有很少数据值的列也不应该增加索引。当数据量不大时，全表扫描也是可以接受的。</li>
<li>对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</li>
<li>当修改操作比大于检索操作更频繁时，不应该创建索引。因为需要频繁的维护索引结构。</li>
</ul>
<h1 id="五、参考地址"><a href="#五、参考地址" class="headerlink" title="五、参考地址"></a>五、参考地址</h1><p><a href="http://blog.csdn.net/xifeijian/article/details/20316775" target="_blank" rel="external">http://blog.csdn.net/xifeijian/article/details/20316775</a></p>
<p><a href="http://blog.csdn.net/v_JULY_v/article/details/6530142/" target="_blank" rel="external">http://blog.csdn.net/v_JULY_v/article/details/6530142/</a></p>
<p><a href="http://www.cnblogs.com/oldhorse/archive/2009/11/16/1604009.html" target="_blank" rel="external">http://www.cnblogs.com/oldhorse/archive/2009/11/16/1604009.html</a></p>
<p><a href="http://blog.csdn.net/kennyrose/article/details/7532032" target="_blank" rel="external">http://blog.csdn.net/kennyrose/article/details/7532032</a></p>
<p><a href="http://database.51cto.com/art/201005/202796.htm" target="_blank" rel="external">http://database.51cto.com/art/201005/202796.htm</a></p>
<p><a href="http://www.cnblogs.com/zlcxbb/p/5757245.html" target="_blank" rel="external">http://www.cnblogs.com/zlcxbb/p/5757245.html</a></p>
<p><a href="http://www.cnblogs.com/lovekingly/p/3962284.html" target="_blank" rel="external">http://www.cnblogs.com/lovekingly/p/3962284.html</a></p>
<p><a href="http://blog.itpub.net/24383181/viewspace-692973/" target="_blank" rel="external">http://blog.itpub.net/24383181/viewspace-692973/</a></p>
<p><a href="http://blog.csdn.net/u011534095/article/details/48552877" target="_blank" rel="external">http://blog.csdn.net/u011534095/article/details/48552877</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring源码分析（二）：依赖注入的实现]]></title>
      <url>http://yoursite.com/2017/01/02/spring/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(2)%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>了解了依赖注入的相关知识之后，来研究一下源码中具体的实现。</p>
<h1 id="一、依赖注入的实现"><a href="#一、依赖注入的实现" class="headerlink" title="一、依赖注入的实现"></a>一、依赖注入的实现</h1><p>依赖注入大体分以下几个步骤：</p>
<ol>
<li>AbstractBeanFactory中的getBean方法向IoC容器获取被管理的Bean</li>
<li>AbstractAutowireCapableBeanFactory的createBean方法创建Bean实例对象</li>
<li>createBeanInstance方法创建Bean的java实例对象</li>
<li>SimpleInstantiationStrategy类的instantiate方法使用默认的无参构造方法创建Bean实例化对象</li>
<li>populateBean方法对Bean属性的依赖注入</li>
<li>BeanDefinitionValueResolver解析属性值</li>
<li>BeanWrapperImpl对Bean属性的依赖注入</li>
</ol>
<h2 id="1、AbstractBeanFactory中的getBean方法"><a href="#1、AbstractBeanFactory中的getBean方法" class="headerlink" title="1、AbstractBeanFactory中的getBean方法"></a>1、AbstractBeanFactory中的getBean方法</h2><p>最开始就说过，getBean是在最基本的IOc容器BeanFactory接口中就定义的方法，它的默认实现类AbstractBeanFactory实现了这个方法，而更高级的ApplicationContext的实现类使用的都是DefaultListableBeanFactory，它也是继承自AbstractBeanFactory的，继承关系如下：</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/spring/9.png?raw=true" alt=""></p>
<p>看一下AbstractBeanFactory中的getBean方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取IoC容器中指定名称的Bean  </span></div><div class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;  </div><div class="line">       <span class="comment">//doGetBean才是真正向IoC容器获取被管理Bean的过程  </span></div><div class="line">       <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);  </div><div class="line">   &#125;  </div><div class="line">   <span class="comment">//获取IoC容器中指定名称和类型的Bean  </span></div><div class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;  </div><div class="line">       <span class="comment">//doGetBean才是真正向IoC容器获取被管理Bean的过程  </span></div><div class="line">       <span class="keyword">return</span> doGetBean(name, requiredType, <span class="keyword">null</span>, <span class="keyword">false</span>);  </div><div class="line">   &#125;  </div><div class="line">   <span class="comment">//获取IoC容器中指定名称和参数的Bean  </span></div><div class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;  </div><div class="line">       <span class="comment">//doGetBean才是真正向IoC容器获取被管理Bean的过程  </span></div><div class="line">       <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, args, <span class="keyword">false</span>);  </div><div class="line">   &#125;  </div><div class="line">   <span class="comment">//获取IoC容器中指定名称、类型和参数的Bean  </span></div><div class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;  </div><div class="line">   <span class="comment">//doGetBean才是真正向IoC容器获取被管理Bean的过程  </span></div><div class="line">       <span class="keyword">return</span> doGetBean(name, requiredType, args, <span class="keyword">false</span>);  </div><div class="line">   &#125;  </div><div class="line"></div><div class="line"></div><div class="line">   <span class="comment">//真正实现向IoC容器获取Bean的功能，也是触发依赖注入功能的地方  </span></div><div class="line">   <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)  </div><div class="line">   <span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(  </span></span></div><div class="line">           <span class="keyword">final</span> String name, <span class="keyword">final</span> Class&lt;T&gt; requiredType, <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)  </div><div class="line">           <span class="keyword">throws</span> BeansException &#123;  </div><div class="line">       <span class="comment">//根据指定的名称获取被管理Bean的名称，剥离指定名称中对容器的相关依赖  </span></div><div class="line">       <span class="comment">//如果指定的是别名，将别名转换为规范的Bean名称  </span></div><div class="line">       <span class="keyword">final</span> String beanName = transformedBeanName(name);  </div><div class="line">       Object bean;  </div><div class="line">       <span class="comment">//先从缓存中取是否已经有被创建过的单态类型的Bean，对于单态模式的Bean整  </span></div><div class="line">       <span class="comment">//个IoC容器中只创建一次，不需要重复创建  </span></div><div class="line">       Object sharedInstance = getSingleton(beanName);  </div><div class="line">       <span class="comment">//IoC容器创建单态模式Bean实例对象  </span></div><div class="line">       <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;  </div><div class="line">           <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </div><div class="line">               <span class="comment">//如果指定名称的Bean在容器中已有单态模式的Bean被创建，直接返回  </span></div><div class="line">               <span class="comment">//已经创建的Bean  </span></div><div class="line">               <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;  </div><div class="line">                   logger.debug(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +  </div><div class="line">                           <span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);  </div><div class="line">               &#125;  </div><div class="line">               <span class="keyword">else</span> &#123;  </div><div class="line">                   logger.debug(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);  </div><div class="line">               &#125;  </div><div class="line">           &#125;  </div><div class="line">           <span class="comment">//获取给定Bean的实例对象，主要是完成FactoryBean的相关处理  </span></div><div class="line">           <span class="comment">//注意：BeanFactory是管理容器中Bean的工厂，而FactoryBean是  </span></div><div class="line">           <span class="comment">//创建创建对象的工厂Bean，两者之间有区别  </span></div><div class="line">           bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);  </div><div class="line">       &#125;  </div><div class="line">       <span class="keyword">else</span> &#123;<span class="comment">//缓存没有正在创建的单态模式Bean  </span></div><div class="line">           <span class="comment">//缓存中已经有已经创建的原型模式Bean，但是由于循环引用的问题导致实  </span></div><div class="line">           <span class="comment">//例化对象失败  </span></div><div class="line">           <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;  </div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);  </div><div class="line">           &#125;  </div><div class="line">           <span class="comment">//对IoC容器中是否存在指定名称的BeanDefinition进行检查，首先检查是否  </span></div><div class="line">           <span class="comment">//能在当前的BeanFactory中获取的所需要的Bean，如果不能则委托当前容器  </span></div><div class="line">           <span class="comment">//的父级容器去查找，如果还是找不到则沿着容器的继承体系向父级容器查找  </span></div><div class="line">           BeanFactory parentBeanFactory = getParentBeanFactory();  </div><div class="line">           <span class="comment">//当前容器的父级容器存在，且当前容器中不存在指定名称的Bean  </span></div><div class="line">           <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;  </div><div class="line">               <span class="comment">//解析指定Bean名称的原始名称  </span></div><div class="line">               String nameToLookup = originalBeanName(name);  </div><div class="line">               <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;  </div><div class="line">                   <span class="comment">//委派父级容器根据指定名称和显式的参数查找  </span></div><div class="line">                   <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);  </div><div class="line">               &#125;  </div><div class="line">               <span class="keyword">else</span> &#123;  </div><div class="line">                   <span class="comment">//委派父级容器根据指定名称和类型查找  </span></div><div class="line">                   <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);  </div><div class="line">               &#125;  </div><div class="line">           &#125;  </div><div class="line">           <span class="comment">//创建的Bean是否需要进行类型验证，一般不需要  </span></div><div class="line">           <span class="keyword">if</span> (!typeCheckOnly) &#123;  </div><div class="line">               <span class="comment">//向容器标记指定的Bean已经被创建  </span></div><div class="line">               markBeanAsCreated(beanName);  </div><div class="line">           &#125;  </div><div class="line">            <span class="comment">//根据指定Bean名称获取其父级的Bean定义，主要解决Bean继承时子类合并父类公共属性问题  </span></div><div class="line">           <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);  </div><div class="line">           checkMergedBeanDefinition(mbd, beanName, args);  </div><div class="line">           <span class="comment">//获取当前Bean所有依赖Bean的名称  </span></div><div class="line">           String[] dependsOn = mbd.getDependsOn();  </div><div class="line">           <span class="comment">//如果当前Bean有依赖Bean  </span></div><div class="line">           <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;  </div><div class="line">               <span class="keyword">for</span> (String dependsOnBean : dependsOn) &#123;  </div><div class="line">                   <span class="comment">//递归调用getBean方法，获取当前Bean的依赖Bean  </span></div><div class="line">                   getBean(dependsOnBean);  </div><div class="line">                   <span class="comment">//把被依赖Bean注册给当前依赖的Bean  </span></div><div class="line">                   registerDependentBean(dependsOnBean, beanName);  </div><div class="line">               &#125;  </div><div class="line">           &#125;  </div><div class="line">           <span class="comment">//创建单态模式Bean的实例对象  </span></div><div class="line">           <span class="keyword">if</span> (mbd.isSingleton()) &#123;  </div><div class="line">           <span class="comment">//这里使用了一个匿名内部类，创建Bean实例对象，并且注册给所依赖的对象  </span></div><div class="line">               sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory() &#123;  </div><div class="line">                   <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;  </div><div class="line">                       <span class="keyword">try</span> &#123;  </div><div class="line">                           <span class="comment">//创建一个指定Bean实例对象，如果有父级继承，则合并子类和父类的定义  </span></div><div class="line">                           <span class="keyword">return</span> createBean(beanName, mbd, args);  </div><div class="line">                       &#125;  </div><div class="line">                       <span class="keyword">catch</span> (BeansException ex) &#123;  </div><div class="line">                           <span class="comment">//显式地从容器单态模式Bean缓存中清除实例对象  </span></div><div class="line">                           destroySingleton(beanName);  </div><div class="line">                           <span class="keyword">throw</span> ex;  </div><div class="line">                       &#125;  </div><div class="line">                   &#125;  </div><div class="line">               &#125;);  </div><div class="line">               <span class="comment">//获取给定Bean的实例对象  </span></div><div class="line">               bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);  </div><div class="line">           &#125;  </div><div class="line">           <span class="comment">//IoC容器创建原型模式Bean实例对象  </span></div><div class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;  </div><div class="line">               <span class="comment">//原型模式(Prototype)是每次都会创建一个新的对象  </span></div><div class="line">               Object prototypeInstance = <span class="keyword">null</span>;  </div><div class="line">               <span class="keyword">try</span> &#123;  </div><div class="line">                   <span class="comment">//回调beforePrototypeCreation方法，默认的功能是注册当前创建的原型对象  </span></div><div class="line">                   beforePrototypeCreation(beanName);  </div><div class="line">                   <span class="comment">//创建指定Bean对象实例  </span></div><div class="line">                   prototypeInstance = createBean(beanName, mbd, args);  </div><div class="line">               &#125;  </div><div class="line">               <span class="keyword">finally</span> &#123;  </div><div class="line">                   <span class="comment">//回调afterPrototypeCreation方法，默认的功能告诉IoC容器指定Bean的原型对象不再创建了  </span></div><div class="line">                   afterPrototypeCreation(beanName);  </div><div class="line">               &#125;  </div><div class="line">               <span class="comment">//获取给定Bean的实例对象  </span></div><div class="line">               bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);  </div><div class="line">           &#125;  </div><div class="line">           <span class="comment">//要创建的Bean既不是单态模式，也不是原型模式，则根据Bean定义资源中配置的生命周期范围，选择实例化Bean的合适方法，这种在Web应用程序中  </span></div><div class="line">         	<span class="comment">//比较常用，如：request、session、application等生命周期  </span></div><div class="line">           <span class="keyword">else</span> &#123;  </div><div class="line">               String scopeName = mbd.getScope();  </div><div class="line">               <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);  </div><div class="line">               <span class="comment">//Bean定义资源中没有配置生命周期范围，则Bean定义不合法  </span></div><div class="line">               <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;  </div><div class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope '"</span> + scopeName + <span class="string">"'"</span>);  </div><div class="line">               &#125;  </div><div class="line">               <span class="keyword">try</span> &#123;  </div><div class="line">                   <span class="comment">//这里又使用了一个匿名内部类，获取一个指定生命周期范围的实例  </span></div><div class="line">                   Object scopedInstance = scope.get(beanName, <span class="keyword">new</span> ObjectFactory() &#123;  </div><div class="line">                       <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;  </div><div class="line">                           beforePrototypeCreation(beanName);  </div><div class="line">                           <span class="keyword">try</span> &#123;  </div><div class="line">                               <span class="keyword">return</span> createBean(beanName, mbd, args);  </div><div class="line">                           &#125;  </div><div class="line">                           <span class="keyword">finally</span> &#123;  </div><div class="line">                               afterPrototypeCreation(beanName);  </div><div class="line">                           &#125;  </div><div class="line">                       &#125;  </div><div class="line">                   &#125;);  </div><div class="line">                   <span class="comment">//获取给定Bean的实例对象  </span></div><div class="line">                   bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);  </div><div class="line">               &#125;  </div><div class="line">               <span class="keyword">catch</span> (IllegalStateException ex) &#123;  </div><div class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,  </div><div class="line">                           <span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; "</span> +  </div><div class="line">                           <span class="string">"consider defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,  </div><div class="line">                           ex);  </div><div class="line">               &#125;  </div><div class="line">           &#125;  </div><div class="line">       &#125;  </div><div class="line">       <span class="comment">//对创建的Bean实例对象进行类型检查  </span></div><div class="line">       <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; bean != <span class="keyword">null</span> &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123;  </div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());  </div><div class="line">       &#125;  </div><div class="line">       <span class="keyword">return</span> (T) bean;  </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>可以看出</p>
<ol>
<li>如果bean设置的是singleton的，就先从缓存中查找，因为单例的只创建一个，如果不是，就开始创建</li>
<li>获取当前Bean所有依赖的Bean，递归调用getBean方法，直道取到一个没有任何依赖的Bean</li>
<li>判断Bean的属性<ul>
<li>singleton，单例模式的</li>
<li>prototype，原型模式的，每次都返回一个新的实例</li>
<li>其他，如：request、session、application</li>
</ul>
</li>
<li>不管是那种模式，都调用了createBean方法，来获取bean实例，不过返回的是Object对象</li>
<li>最后返回指定类型的bean实例</li>
</ol>
<p>createBean方法是在父类AbstractAutowireCapableBeanFactory中实现的</p>
<h2 id="2、AbstractAutowireCapableBeanFactory的createBean方法"><a href="#2、AbstractAutowireCapableBeanFactory的createBean方法" class="headerlink" title="2、AbstractAutowireCapableBeanFactory的createBean方法"></a>2、AbstractAutowireCapableBeanFactory的createBean方法</h2><p>createBean方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建Bean实例对象  </span></div><div class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span>  </span></div><div class="line">          <span class="keyword">throws</span> BeanCreationException &#123;  </div><div class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </div><div class="line">          logger.debug(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//判断需要创建的Bean是否可以实例化，即是否可以通过当前的类加载器加载  </span></div><div class="line">      resolveBeanClass(mbd, beanName);  </div><div class="line">      <span class="comment">//校验和准备Bean中的方法覆盖  </span></div><div class="line">      <span class="keyword">try</span> &#123;  </div><div class="line">          mbd.prepareMethodOverrides();  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;  </div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbd.getResourceDescription(),  </div><div class="line">                  beanName, <span class="string">"Validation of method overrides failed"</span>, ex);  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">try</span> &#123;  </div><div class="line">          <span class="comment">//如果Bean配置了初始化前和初始化后的处理器，则试图返回一个需要创建Bean的代理对象  </span></div><div class="line">          Object bean = resolveBeforeInstantiation(beanName, mbd);  </div><div class="line">          <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;  </div><div class="line">              <span class="keyword">return</span> bean;  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">catch</span> (Throwable ex) &#123;  </div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,  </div><div class="line">                  <span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//创建Bean的入口  </span></div><div class="line">      Object beanInstance = doCreateBean(beanName, mbd, args);  </div><div class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </div><div class="line">          logger.debug(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">return</span> beanInstance;  </div><div class="line">  &#125;  </div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">//真正创建Bean的方法  </span></div><div class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span> </span>&#123;  </div><div class="line">      <span class="comment">//BeanWrapper对象用来持有创建出来的Bean对象</span></div><div class="line">      BeanWrapper instanceWrapper = <span class="keyword">null</span>;  </div><div class="line">      <span class="keyword">if</span> (mbd.isSingleton())&#123;<span class="comment">//单例模式的Bean，先从容器中缓存中清除同名Bean  </span></div><div class="line">          instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;  </div><div class="line">          <span class="comment">//创建实例对象  </span></div><div class="line">          instanceWrapper = createBeanInstance(beanName, mbd, args);  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">final</span> Object bean = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="keyword">null</span>);  </div><div class="line">      <span class="comment">//获取实例化对象的类型  </span></div><div class="line">      Class beanType = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedClass() : <span class="keyword">null</span>);  </div><div class="line">      <span class="comment">//调用PostProcessor后置处理器  </span></div><div class="line">      <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;  </div><div class="line">          <span class="keyword">if</span> (!mbd.postProcessed) &#123;  </div><div class="line">              applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);  </div><div class="line">              mbd.postProcessed = <span class="keyword">true</span>;  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">// Eagerly cache singletons to be able to resolve circular references  </span></div><div class="line">      <span class="comment">//向容器中缓存单态模式的Bean对象，以防循环引用  </span></div><div class="line">      <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;  </div><div class="line">              isSingletonCurrentlyInCreation(beanName));  </div><div class="line">      <span class="keyword">if</span> (earlySingletonExposure) &#123;  </div><div class="line">          <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </div><div class="line">              logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +  </div><div class="line">                      <span class="string">"' to allow for resolving potential circular references"</span>);  </div><div class="line">          &#125;  </div><div class="line">          <span class="comment">//这里是一个匿名内部类，为了防止循环引用，尽早持有对象的引用  </span></div><div class="line">          addSingletonFactory(beanName, <span class="keyword">new</span> ObjectFactory() &#123;  </div><div class="line">              <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;  </div><div class="line">                  <span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);  </div><div class="line">              &#125;  </div><div class="line">          &#125;);  </div><div class="line">      &#125;  </div><div class="line">    </div><div class="line">    </div><div class="line">    </div><div class="line">      <span class="comment">//Bean对象的初始化，依赖注入在此触发  </span></div><div class="line">      <span class="comment">//这个exposedObject在初始化完成之后返回作为依赖注入完成后的Bean  </span></div><div class="line">      Object exposedObject = bean;  </div><div class="line">      <span class="keyword">try</span> &#123;  </div><div class="line">          <span class="comment">//将Bean实例对象封装，并且Bean定义中配置的属性值赋值给实例对象  </span></div><div class="line">          populateBean(beanName, mbd, instanceWrapper);  </div><div class="line">          <span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;  </div><div class="line">              <span class="comment">//初始化Bean对象  </span></div><div class="line">              exposedObject = initializeBean(beanName, exposedObject, mbd);  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">catch</span> (Throwable ex) &#123;  </div><div class="line">          <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;  </div><div class="line">              <span class="keyword">throw</span> (BeanCreationException) ex;  </div><div class="line">          &#125;  </div><div class="line">          <span class="keyword">else</span> &#123;  </div><div class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">if</span> (earlySingletonExposure) &#123;  </div><div class="line">          <span class="comment">//获取指定名称的已注册的单态模式Bean对象  </span></div><div class="line">          Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);  </div><div class="line">          <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;  </div><div class="line">              <span class="comment">//根据名称获取的以注册的Bean和正在实例化的Bean是同一个  </span></div><div class="line">              <span class="keyword">if</span> (exposedObject == bean) &#123;  </div><div class="line">                  <span class="comment">//当前实例化的Bean初始化完成  </span></div><div class="line">                  exposedObject = earlySingletonReference;  </div><div class="line">              &#125;  </div><div class="line">              <span class="comment">//当前Bean依赖其他Bean，并且当发生循环引用时不允许新创建实例对象  </span></div><div class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;  </div><div class="line">                  String[] dependentBeans = getDependentBeans(beanName);  </div><div class="line">                  Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(dependentBeans.length);  </div><div class="line">                  <span class="comment">//获取当前Bean所依赖的其他Bean  </span></div><div class="line">                  <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;  </div><div class="line">                      <span class="comment">//对依赖Bean进行类型检查  </span></div><div class="line">                      <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;  </div><div class="line">                          actualDependentBeans.add(dependentBean);  </div><div class="line">                      &#125;  </div><div class="line">                  &#125;  </div><div class="line">                  <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;  </div><div class="line">                      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,  </div><div class="line">                              <span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +  </div><div class="line">                              StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +  </div><div class="line">                              <span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +  </div><div class="line">                              <span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +  </div><div class="line">                              <span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +  </div><div class="line">                              <span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);  </div><div class="line">                  &#125;  </div><div class="line">              &#125;  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//注册完成依赖注入的Bean  </span></div><div class="line">      <span class="keyword">try</span> &#123;  </div><div class="line">          registerDisposableBeanIfNecessary(beanName, bean, mbd);  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;  </div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">return</span> exposedObject;  </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>创建容器指定的Bean实例对象，同时还对创建的Bean实例对象进行初始化处理比如init-method、后置处理器等。</p>
<p>关键步骤由以下两个方法实现：</p>
<ul>
<li>createBeanInstance：生成Bean所包含的Java对象实例。</li>
<li>populateBean ：对Bean属性的依赖注入进行处理。</li>
</ul>
<p>这两个方法也在这个类中，下面继续分析</p>
<h2 id="3、createBeanInstance方法"><a href="#3、createBeanInstance方法" class="headerlink" title="3、createBeanInstance方法"></a>3、createBeanInstance方法</h2><h3 id="3-1、createBeanInstance方法"><a href="#3-1、createBeanInstance方法" class="headerlink" title="3.1、createBeanInstance方法"></a>3.1、createBeanInstance方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建Bean的实例对象  </span></div><div class="line">  <span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> </span>&#123;  </div><div class="line">      <span class="comment">//检查确认Bean是可实例化的  </span></div><div class="line">      Class beanClass = resolveBeanClass(mbd, beanName);  </div><div class="line">      <span class="comment">//使用工厂方法对Bean进行实例化  </span></div><div class="line">      <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;  </div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,  </div><div class="line">                  <span class="string">"Bean class isn't public, and non-public access not allowed: "</span> + beanClass.getName());  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>)  &#123;  </div><div class="line">          <span class="comment">//调用工厂方法实例化  </span></div><div class="line">          <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//使用容器的自动装配方法进行实例化  </span></div><div class="line">      <span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;  </div><div class="line">      <span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;  </div><div class="line">      <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;  </div><div class="line">          <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;  </div><div class="line">              <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;  </div><div class="line">                  resolved = <span class="keyword">true</span>;  </div><div class="line">                  autowireNecessary = mbd.constructorArgumentsResolved;  </div><div class="line">              &#125;  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">if</span> (resolved) &#123;  </div><div class="line">          <span class="keyword">if</span> (autowireNecessary) &#123;  </div><div class="line">              <span class="comment">//配置了自动装配属性，使用容器的自动装配实例化容器的自动装配是根据参数类型匹配Bean的构造方法  </span></div><div class="line">              <span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);  </div><div class="line">          &#125;  </div><div class="line">          <span class="keyword">else</span> &#123;  </div><div class="line">              <span class="comment">//使用默认的无参构造方法实例化  </span></div><div class="line">              <span class="keyword">return</span> instantiateBean(beanName, mbd);  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">    </div><div class="line">    </div><div class="line">      <span class="comment">//使用Bean的构造方法进行实例化  </span></div><div class="line">      Constructor[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);  </div><div class="line">      <span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||  </div><div class="line">              mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||  </div><div class="line">              mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;  </div><div class="line">          <span class="comment">//使用容器的自动装配特性，调用匹配的构造方法实例化  </span></div><div class="line">          <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//使用默认的无参构造方法实例化  </span></div><div class="line">      <span class="keyword">return</span> instantiateBean(beanName, mbd);  </div><div class="line">  &#125;   </div><div class="line"></div><div class="line">  <span class="comment">//使用默认的无参构造方法实例化Bean对象  </span></div><div class="line">  <span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;  </div><div class="line">      <span class="keyword">try</span> &#123;  </div><div class="line">          Object beanInstance;  </div><div class="line">          <span class="keyword">final</span> BeanFactory parent = <span class="keyword">this</span>;  </div><div class="line">          <span class="comment">//获取系统的安全管理接口，JDK标准的安全管理API  </span></div><div class="line">          <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;  </div><div class="line">              <span class="comment">//这里是一个匿名内置类，根据实例化策略创建实例对象  </span></div><div class="line">              beanInstance = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;  </div><div class="line">                  <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">                      <span class="keyword">return</span> getInstantiationStrategy().instantiate(mbd, beanName, parent);  </div><div class="line">                  &#125;  </div><div class="line">              &#125;, getAccessControlContext());  </div><div class="line">          &#125;  </div><div class="line">          <span class="keyword">else</span> &#123;  </div><div class="line">              <span class="comment">//将实例化的对象封装起来  </span></div><div class="line">              beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);  </div><div class="line">          &#125;  </div><div class="line">          BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);  </div><div class="line">          initBeanWrapper(bw);  </div><div class="line">          <span class="keyword">return</span> bw;  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">catch</span> (Throwable ex) &#123;  </div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Instantiation of bean failed"</span>, ex);  </div><div class="line">      &#125;  </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>可以看出，bean的实例化分为很多种情况，</p>
<ul>
<li>对于使用工厂方法和自动装配特性的bean的实例化，则调用对应的工厂方法或者参数匹配的构造方法即可完成实例化对象的工作</li>
<li>对于最常使用的无参构造方法，则使用相应的初始化策略<ul>
<li>JDK的反射机制</li>
<li>或者CGLIB</li>
</ul>
</li>
</ul>
<p>关于Spring中Bean实例化的多种方式上面已经介绍过，下面主要看一下最常用的无参构造方法实例化bean的过程，这个方法在SimpleInstantiationStrategy类中的instantiate方法中实现。</p>
<h2 id="4、SimpleInstantiationStrategy的instantiate方法"><a href="#4、SimpleInstantiationStrategy的instantiate方法" class="headerlink" title="4、SimpleInstantiationStrategy的instantiate方法"></a>4、SimpleInstantiationStrategy的instantiate方法</h2><h3 id="4-1、instantiate方法"><a href="#4-1、instantiate方法" class="headerlink" title="4.1、instantiate方法"></a>4.1、instantiate方法</h3><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用初始化策略实例化Bean对象  </span></div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition beanDefinition, String beanName, BeanFactory owner)</span> </span>&#123;  </div><div class="line">      <span class="comment">//如果Bean定义中没有方法覆盖，则就不需要CGLIB父类类的方法  </span></div><div class="line">      <span class="keyword">if</span> (beanDefinition.getMethodOverrides().isEmpty()) &#123;  </div><div class="line">          Constructor&lt;?&gt; constructorToUse;  </div><div class="line">          <span class="keyword">synchronized</span> (beanDefinition.constructorArgumentLock) &#123;  </div><div class="line">              <span class="comment">//获取对象的构造方法或工厂方法  </span></div><div class="line">              constructorToUse = (Constructor&lt;?&gt;) beanDefinition.resolvedConstructorOrFactoryMethod;  </div><div class="line">              <span class="comment">//如果没有构造方法且没有工厂方法  </span></div><div class="line">              <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;  </div><div class="line">                  <span class="comment">//使用JDK的反射机制，判断要实例化的Bean是否是接口  </span></div><div class="line">                  <span class="keyword">final</span> Class clazz = beanDefinition.getBeanClass();  </div><div class="line">                  <span class="keyword">if</span> (clazz.isInterface()) &#123;  </div><div class="line">                      <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"Specified class is an interface"</span>);  </div><div class="line">                  &#125;  </div><div class="line">                  <span class="keyword">try</span> &#123;  </div><div class="line">                      <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;  </div><div class="line">                      <span class="comment">//这里是一个匿名内置类，使用反射机制获取Bean的构造方法  </span></div><div class="line">                          constructorToUse = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Constructor&gt;() &#123;  </div><div class="line">                              <span class="function"><span class="keyword">public</span> Constructor <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">                                  <span class="keyword">return</span> clazz.getDeclaredConstructor((Class[]) <span class="keyword">null</span>);  </div><div class="line">                              &#125;  </div><div class="line">                          &#125;);  </div><div class="line">                      &#125;  </div><div class="line">                      <span class="keyword">else</span> &#123;  </div><div class="line">                          constructorToUse =  clazz.getDeclaredConstructor((Class[]) <span class="keyword">null</span>);  </div><div class="line">                      &#125;  </div><div class="line">                      beanDefinition.resolvedConstructorOrFactoryMethod = constructorToUse;  </div><div class="line">                  &#125;  </div><div class="line">                  <span class="keyword">catch</span> (Exception ex) &#123;  </div><div class="line">                      <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"No default constructor found"</span>, ex);  </div><div class="line">                  &#125;  </div><div class="line">              &#125;  </div><div class="line">          &#125;  </div><div class="line">          <span class="comment">//使用BeanUtils实例化，通过反射机制调用”构造方法.newInstance(arg)”来进行实例化  </span></div><div class="line">          <span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse);  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">else</span> &#123;  </div><div class="line">          <span class="comment">//使用CGLIB来实例化对象  </span></div><div class="line">          <span class="keyword">return</span> instantiateWithMethodInjection(beanDefinition, beanName, owner);  </div><div class="line">      &#125;  </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这个Strategy是Spring中用来生成Bean对象的默认类，它提供了两种实例化Java对象的方法：</p>
<ul>
<li>一种是通过BeanUtils，使用JVM的反射机制</li>
<li>一种是通过CGLIB来生成。</li>
</ul>
<p>判断的条件就是Bean定义中有没有方法覆盖。</p>
<h3 id="4-2、反射还是CGLIB"><a href="#4-2、反射还是CGLIB" class="headerlink" title="4.2、反射还是CGLIB"></a>4.2、反射还是CGLIB</h3><p>关于这个条件，开始不是很明白，书上也没有解释为什么通过这个条件来判断，所以上网查了一些资料</p>
<blockquote>
<p>程序中首先判断如果beanDefinition.getMethodOverrides()为空，也就是用户没有使用replace或者lookup的配置方法，那么直接使用反射的方式，简单快捷，但如果使用了这两个特性，再直接使用反射的方式创建实例就不妥了，因为需要将这两个配置提供的功能切入进去，所以就必须要使用动态代理的方式将包含两个特性锁对应的逻辑的拦截增强器设置进去，这样才可以保证在调用方法的时候会被相应的拦截器增强，返回值为包含拦截器的代理实例。</p>
</blockquote>
<p>那么是什么条件才会触发这个MethodOverrides呢？<br>其实是Spring配置文件中的lookup-method和replace-method，这其实是两个方法级别的注入，和一般的属性(Property)注入是不一样的，它们注入的是方法(Method)。具体的介绍在依赖注入的基础部分已经介绍过了。</p>
<h3 id="4-3、CGLIB与instantiateWithMethodInjection方法"><a href="#4-3、CGLIB与instantiateWithMethodInjection方法" class="headerlink" title="4.3、CGLIB与instantiateWithMethodInjection方法"></a>4.3、CGLIB与instantiateWithMethodInjection方法</h3><p>instantiateWithMethodInjection方法在SimpleInstantiationStrategy的子类CglibSubclassingInstantiationStrategy中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用CGLIB进行Bean对象实例化  </span></div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(Constructor ctor, Object[] args)</span> </span>&#123;  </div><div class="line">          <span class="comment">//CGLIB中的类  </span></div><div class="line">          Enhancer enhancer = <span class="keyword">new</span> Enhancer();  </div><div class="line">          <span class="comment">//将Bean本身作为其基类  </span></div><div class="line">          enhancer.setSuperclass(<span class="keyword">this</span>.beanDefinition.getBeanClass());  </div><div class="line">          enhancer.setCallbackFilter(<span class="keyword">new</span> CallbackFilterImpl());  </div><div class="line">          enhancer.setCallbacks(<span class="keyword">new</span> Callback[] &#123;  </div><div class="line">                  NoOp.INSTANCE,  </div><div class="line">                  <span class="keyword">new</span> LookupOverrideMethodInterceptor(),  </div><div class="line">                  <span class="keyword">new</span> ReplaceOverrideMethodInterceptor()  </div><div class="line">          &#125;);  </div><div class="line">          <span class="comment">//使用CGLIB的create方法生成实例对象  </span></div><div class="line">          <span class="keyword">return</span> (ctor == <span class="keyword">null</span>) ?   </div><div class="line">                  enhancer.create() :   </div><div class="line">                  enhancer.create(ctor.getParameterTypes(), args);  </div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<p>CGLIB是一个常用的字节码生成器的类库，它提供了一系列API实现java字节码的生成和转换功能。我们在学习JDK的动态代理时都知道，JDK的动态代理只能针对接口，如果一个类没有实现任何接口，要对其进行动态代理只能使用CGLIB。</p>
<p>至此，Bean的Java对象就已经生成了，而生成之后，还需要对它进行依赖关系的设置，就是最后一步。</p>
<h2 id="5、populateBean方法"><a href="#5、populateBean方法" class="headerlink" title="5、populateBean方法"></a>5、populateBean方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将Bean属性设置到生成的实例对象上  </span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw)</span> </span>&#123;  </div><div class="line">      <span class="comment">//获取容器在解析Bean定义资源时为BeanDefiniton中设置的属性值  </span></div><div class="line">      PropertyValues pvs = mbd.getPropertyValues();  </div><div class="line">      <span class="comment">//实例对象为null  </span></div><div class="line">      <span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;  </div><div class="line">          <span class="comment">//属性值不为空  </span></div><div class="line">          <span class="keyword">if</span> (!pvs.isEmpty()) &#123;  </div><div class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(  </div><div class="line">                      mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);  </div><div class="line">          &#125;  </div><div class="line">          <span class="keyword">else</span> &#123;  </div><div class="line">              <span class="comment">//实例对象为null，属性值也为空，不需要设置属性值，直接返回  </span></div><div class="line">              <span class="keyword">return</span>;  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//在设置属性之前调用Bean的PostProcessor后置处理器  </span></div><div class="line">      <span class="keyword">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;  </div><div class="line">      <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;  </div><div class="line">          <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;  </div><div class="line">              <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;  </div><div class="line">                  InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;  </div><div class="line">                  <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;  </div><div class="line">                      continueWithPropertyPopulation = <span class="keyword">false</span>;  </div><div class="line">                      <span class="keyword">break</span>;  </div><div class="line">                  &#125;  </div><div class="line">              &#125;  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;  </div><div class="line">          <span class="keyword">return</span>;  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//依赖注入开始，首先处理autowire自动装配的注入  </span></div><div class="line">      <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||  </div><div class="line">              mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;  </div><div class="line">          MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);  </div><div class="line">          <span class="comment">//对autowire自动装配的处理，根据Bean名称自动装配注入  </span></div><div class="line">          <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;  </div><div class="line">              autowireByName(beanName, mbd, bw, newPvs);  </div><div class="line">          &#125;  </div><div class="line">          <span class="comment">//根据Bean类型自动装配注入  </span></div><div class="line">          <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;  </div><div class="line">              autowireByType(beanName, mbd, bw, newPvs);  </div><div class="line">          &#125;  </div><div class="line">          pvs = newPvs;  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//检查容器是否持有用于处理单态模式Bean关闭时的后置处理器  </span></div><div class="line">      <span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();  </div><div class="line">      <span class="comment">//Bean实例对象没有依赖，即没有继承基类  </span></div><div class="line">      <span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);  </div><div class="line">      <span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;  </div><div class="line">          <span class="comment">//从实例对象中提取属性描述符  </span></div><div class="line">          PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw);  </div><div class="line">          <span class="keyword">if</span> (hasInstAwareBpps) &#123;  </div><div class="line">              <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;  </div><div class="line">                  <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;  </div><div class="line">                      InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;  </div><div class="line">                      <span class="comment">//使用BeanPostProcessor处理器处理属性值  </span></div><div class="line">                      pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);  </div><div class="line">                      <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;  </div><div class="line">                          <span class="keyword">return</span>;  </div><div class="line">                      &#125;  </div><div class="line">                  &#125;  </div><div class="line">              &#125;  </div><div class="line">          &#125;  </div><div class="line">          <span class="keyword">if</span> (needsDepCheck) &#123;  </div><div class="line">              <span class="comment">//为要设置的属性进行依赖检查  </span></div><div class="line">              checkDependencies(beanName, mbd, filteredPds, pvs);  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//对属性进行注入  </span></div><div class="line">      applyPropertyValues(beanName, mbd, bw, pvs);  </div><div class="line">  &#125;  </div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">//解析并注入依赖属性的过程  </span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> </span>&#123;  </div><div class="line">      <span class="keyword">if</span> (pvs == <span class="keyword">null</span> || pvs.isEmpty()) &#123;  </div><div class="line">          <span class="keyword">return</span>;  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//封装属性值  </span></div><div class="line">      MutablePropertyValues mpvs = <span class="keyword">null</span>;  </div><div class="line">      List&lt;PropertyValue&gt; original;  </div><div class="line">      <span class="keyword">if</span> (System.getSecurityManager()!= <span class="keyword">null</span>) &#123;  </div><div class="line">          <span class="keyword">if</span> (bw <span class="keyword">instanceof</span> BeanWrapperImpl) &#123;  </div><div class="line">              <span class="comment">//设置安全上下文，JDK安全机制  </span></div><div class="line">              ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues) &#123;  </div><div class="line">          mpvs = (MutablePropertyValues) pvs;  </div><div class="line">          <span class="comment">//属性值已经转换  </span></div><div class="line">          <span class="keyword">if</span> (mpvs.isConverted()) &#123;  </div><div class="line">              <span class="keyword">try</span> &#123;  </div><div class="line">                  <span class="comment">//为实例化对象设置属性值  </span></div><div class="line">                  bw.setPropertyValues(mpvs);  </div><div class="line">                  <span class="keyword">return</span>;  </div><div class="line">              &#125;  </div><div class="line">              <span class="keyword">catch</span> (BeansException ex) &#123;  </div><div class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(  </div><div class="line">                          mbd.getResourceDescription(), beanName, <span class="string">"Error setting property values"</span>, ex);  </div><div class="line">              &#125;  </div><div class="line">          &#125;  </div><div class="line">          <span class="comment">//获取属性值对象的原始类型值  </span></div><div class="line">          original = mpvs.getPropertyValueList();  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">else</span> &#123;  </div><div class="line">          original = Arrays.asList(pvs.getPropertyValues());  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//获取用户自定义的类型转换  </span></div><div class="line">      TypeConverter converter = getCustomTypeConverter();  </div><div class="line">      <span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;  </div><div class="line">          converter = bw;  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//创建一个Bean定义属性值解析器，将Bean定义中的属性值解析为Bean实例对象的实际值  </span></div><div class="line">      BeanDefinitionValueResolver valueResolver = <span class="keyword">new</span> BeanDefinitionValueResolver(<span class="keyword">this</span>, beanName, mbd, converter);  </div><div class="line">      <span class="comment">//为属性的解析值创建一个拷贝，将拷贝的数据注入到实例对象中  </span></div><div class="line">      List&lt;PropertyValue&gt; deepCopy = <span class="keyword">new</span> ArrayList&lt;PropertyValue&gt;(original.size());  </div><div class="line">      <span class="keyword">boolean</span> resolveNecessary = <span class="keyword">false</span>;  </div><div class="line">      <span class="keyword">for</span> (PropertyValue pv : original) &#123;  </div><div class="line">          <span class="comment">//属性值不需要转换  </span></div><div class="line">          <span class="keyword">if</span> (pv.isConverted()) &#123;  </div><div class="line">              deepCopy.add(pv);  </div><div class="line">          &#125;  </div><div class="line">          <span class="comment">//属性值需要转换  </span></div><div class="line">          <span class="keyword">else</span> &#123;  </div><div class="line">              String propertyName = pv.getName();  </div><div class="line">              <span class="comment">//原始的属性值，即转换之前的属性值  </span></div><div class="line">              Object originalValue = pv.getValue();  </div><div class="line">              <span class="comment">//转换属性值，例如将引用转换为IoC容器中实例化对象引用  </span></div><div class="line">              Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);  </div><div class="line">              <span class="comment">//转换之后的属性值  </span></div><div class="line">              Object convertedValue = resolvedValue;  </div><div class="line">              <span class="comment">//属性值是否可以转换  </span></div><div class="line">              <span class="keyword">boolean</span> convertible = bw.isWritableProperty(propertyName) &amp;&amp;  </div><div class="line">                      !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);  </div><div class="line">              <span class="keyword">if</span> (convertible) &#123;  </div><div class="line">                  <span class="comment">//使用用户自定义的类型转换器转换属性值  </span></div><div class="line">                  convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);  </div><div class="line">              &#125;  </div><div class="line">              <span class="comment">//存储转换后的属性值，避免每次属性注入时的转换工作  </span></div><div class="line">              <span class="keyword">if</span> (resolvedValue == originalValue) &#123;  </div><div class="line">                  <span class="keyword">if</span> (convertible) &#123;  </div><div class="line">                      <span class="comment">//设置属性转换之后的值  </span></div><div class="line">                      pv.setConvertedValue(convertedValue);  </div><div class="line">                  &#125;  </div><div class="line">                  deepCopy.add(pv);  </div><div class="line">              &#125;  </div><div class="line">              <span class="comment">//属性是可转换的，且属性原始值是字符串类型，且属性的原始类型值不是动态生成的字符串，且属性的原始值不是集合或者数组类型  </span></div><div class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (convertible &amp;&amp; originalValue <span class="keyword">instanceof</span> TypedStringValue &amp;&amp;  </div><div class="line">                      !((TypedStringValue) originalValue).isDynamic() &amp;&amp;  </div><div class="line">                      !(convertedValue <span class="keyword">instanceof</span> Collection || ObjectUtils.isArray(convertedValue))) &#123;  </div><div class="line">                  pv.setConvertedValue(convertedValue);  </div><div class="line">                  deepCopy.add(pv);  </div><div class="line">              &#125;  </div><div class="line">              <span class="keyword">else</span> &#123;  </div><div class="line">                  resolveNecessary = <span class="keyword">true</span>;  </div><div class="line">                  <span class="comment">//重新封装属性的值  </span></div><div class="line">                  deepCopy.add(<span class="keyword">new</span> PropertyValue(pv, convertedValue));  </div><div class="line">              &#125;  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">if</span> (mpvs != <span class="keyword">null</span> &amp;&amp; !resolveNecessary) &#123;  </div><div class="line">          <span class="comment">//标记属性值已经转换过  </span></div><div class="line">          mpvs.setConverted();  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//进行属性依赖注入  </span></div><div class="line">      <span class="keyword">try</span> &#123;  </div><div class="line">          bw.setPropertyValues(<span class="keyword">new</span> MutablePropertyValues(deepCopy));  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;  </div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(  </div><div class="line">                  mbd.getResourceDescription(), beanName, <span class="string">"Error setting property values"</span>, ex);  </div><div class="line">      &#125;  </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>可以看出，该方法过程主要如下：</p>
<ol>
<li>对要注入的属性进行判断：<ul>
<li>属性值类型不需要转换时，不需要解析属性值，直接准备进行依赖注入。</li>
<li>属性值需要进行类型转换时，如对其他对象的引用等，首先需要解析属性值，然后对解析后的属性值进行依赖注入。解析时需要调用BeanDefinitionValueResolver类的resolveValueIfNecessary方法。</li>
</ul>
</li>
<li>BeanWrapperImpl中的bw.setPropertyValues来实现依赖注入</li>
</ol>
<p>下面分别看一下这两个方法</p>
<h2 id="6、BeanDefinitionValueResolver解析属性值"><a href="#6、BeanDefinitionValueResolver解析属性值" class="headerlink" title="6、BeanDefinitionValueResolver解析属性值"></a>6、BeanDefinitionValueResolver解析属性值</h2><p>当容器在对属性进行依赖注入时，如果发现属性值需要进行类型转换，如属性值是容器中另一个Bean实例对象的引用，则容器首先需要根据属性值解析出所引用的对象，然后才能将该引用对象注入到目标实例对象的属性上去，对属性进行解析的由resolveValueIfNecessary方法实现，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//解析属性值，对注入类型进行转换  </span></div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">resolveValueIfNecessary</span><span class="params">(Object argName, Object value)</span> </span>&#123;  </div><div class="line">      <span class="comment">//对引用类型的属性进行解析  </span></div><div class="line">      <span class="keyword">if</span> (value <span class="keyword">instanceof</span> RuntimeBeanReference) &#123;  </div><div class="line">          RuntimeBeanReference ref = (RuntimeBeanReference) value;  </div><div class="line">          <span class="comment">//调用引用类型属性的解析方法  </span></div><div class="line">          <span class="keyword">return</span> resolveReference(argName, ref);  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//对属性值是引用容器中另一个Bean名称的解析  </span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> RuntimeBeanNameReference) &#123;  </div><div class="line">          String refName = ((RuntimeBeanNameReference) value).getBeanName();  </div><div class="line">          refName = String.valueOf(evaluate(refName));  </div><div class="line">          <span class="comment">//从容器中获取指定名称的Bean  </span></div><div class="line">          <span class="keyword">if</span> (!<span class="keyword">this</span>.beanFactory.containsBean(refName)) &#123;  </div><div class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(  </div><div class="line">                      <span class="string">"Invalid bean name '"</span> + refName + <span class="string">"' in bean reference for "</span> + argName);  </div><div class="line">          &#125;  </div><div class="line">          <span class="keyword">return</span> refName;  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//对Bean类型属性的解析，主要是Bean中的内部类  </span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> BeanDefinitionHolder) &#123;  </div><div class="line">          BeanDefinitionHolder bdHolder = (BeanDefinitionHolder) value;  </div><div class="line">          <span class="keyword">return</span> resolveInnerBean(argName, bdHolder.getBeanName(), bdHolder.getBeanDefinition());  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> BeanDefinition) &#123;  </div><div class="line">          BeanDefinition bd = (BeanDefinition) value;  </div><div class="line">          <span class="keyword">return</span> resolveInnerBean(argName, <span class="string">"(inner bean)"</span>, bd);  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//对集合数组类型的属性解析  </span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ManagedArray) &#123;  </div><div class="line">          ManagedArray array = (ManagedArray) value;  </div><div class="line">          <span class="comment">//获取数组的类型  </span></div><div class="line">          Class elementType = array.resolvedElementType;  </div><div class="line">          <span class="keyword">if</span> (elementType == <span class="keyword">null</span>) &#123;  </div><div class="line">              <span class="comment">//获取数组元素的类型  </span></div><div class="line">              String elementTypeName = array.getElementTypeName();  </div><div class="line">              <span class="keyword">if</span> (StringUtils.hasText(elementTypeName)) &#123;  </div><div class="line">                  <span class="keyword">try</span> &#123;  </div><div class="line">                      <span class="comment">//使用反射机制创建指定类型的对象  </span></div><div class="line">                      elementType = ClassUtils.forName(elementTypeName, <span class="keyword">this</span>.beanFactory.getBeanClassLoader());  </div><div class="line">                      array.resolvedElementType = elementType;  </div><div class="line">                  &#125;  </div><div class="line">                  <span class="keyword">catch</span> (Throwable ex) &#123;  </div><div class="line">                      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(  </div><div class="line">                              <span class="keyword">this</span>.beanDefinition.getResourceDescription(), <span class="keyword">this</span>.beanName,  </div><div class="line">                              <span class="string">"Error resolving array type for "</span> + argName, ex);  </div><div class="line">                  &#125;  </div><div class="line">              &#125;  </div><div class="line">              <span class="comment">//没有获取到数组的类型，也没有获取到数组元素的类型，则直接设置数  </span></div><div class="line">              <span class="comment">//组的类型为Object  </span></div><div class="line">              <span class="keyword">else</span> &#123;  </div><div class="line">                  elementType = Object.class;  </div><div class="line">              &#125;  </div><div class="line">          &#125;  </div><div class="line">          <span class="comment">//创建指定类型的数组  </span></div><div class="line">          <span class="keyword">return</span> resolveManagedArray(argName, (List&lt;?&gt;) value, elementType);  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//解析list类型的属性值  </span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ManagedList) &#123;  </div><div class="line">          <span class="keyword">return</span> resolveManagedList(argName, (List&lt;?&gt;) value);  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//解析set类型的属性值  </span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ManagedSet) &#123;  </div><div class="line">          <span class="keyword">return</span> resolveManagedSet(argName, (Set&lt;?&gt;) value);  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//解析map类型的属性值  </span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ManagedMap) &#123;  </div><div class="line">          <span class="keyword">return</span> resolveManagedMap(argName, (Map&lt;?, ?&gt;) value);  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//解析props类型的属性值，props其实就是key和value均为字符串的map  </span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ManagedProperties) &#123;  </div><div class="line">          Properties original = (Properties) value;  </div><div class="line">          <span class="comment">//创建一个拷贝，用于作为解析后的返回值  </span></div><div class="line">          Properties copy = <span class="keyword">new</span> Properties();  </div><div class="line">          <span class="keyword">for</span> (Map.Entry propEntry : original.entrySet()) &#123;  </div><div class="line">              Object propKey = propEntry.getKey();  </div><div class="line">              Object propValue = propEntry.getValue();  </div><div class="line">              <span class="keyword">if</span> (propKey <span class="keyword">instanceof</span> TypedStringValue) &#123;  </div><div class="line">                  propKey = evaluate((TypedStringValue) propKey);  </div><div class="line">              &#125;  </div><div class="line">              <span class="keyword">if</span> (propValue <span class="keyword">instanceof</span> TypedStringValue) &#123;  </div><div class="line">                  propValue = evaluate((TypedStringValue) propValue);  </div><div class="line">              &#125;  </div><div class="line">              copy.put(propKey, propValue);  </div><div class="line">          &#125;  </div><div class="line">          <span class="keyword">return</span> copy;  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//解析字符串类型的属性值  </span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> TypedStringValue) &#123;  </div><div class="line">          TypedStringValue typedStringValue = (TypedStringValue) value;  </div><div class="line">          Object valueObject = evaluate(typedStringValue);  </div><div class="line">          <span class="keyword">try</span> &#123;  </div><div class="line">              <span class="comment">//获取属性的目标类型  </span></div><div class="line">              Class&lt;?&gt; resolvedTargetType = resolveTargetType(typedStringValue);  </div><div class="line">              <span class="keyword">if</span> (resolvedTargetType != <span class="keyword">null</span>) &#123;  </div><div class="line">                  <span class="comment">//对目标类型的属性进行解析，递归调用  </span></div><div class="line">                  <span class="keyword">return</span> <span class="keyword">this</span>.typeConverter.convertIfNecessary(valueObject, resolvedTargetType);  </div><div class="line">              &#125;  </div><div class="line">              <span class="comment">//没有获取到属性的目标对象，则按Object类型返回  </span></div><div class="line">              <span class="keyword">else</span> &#123;  </div><div class="line">                  <span class="keyword">return</span> valueObject;  </div><div class="line">              &#125;  </div><div class="line">          &#125;  </div><div class="line">          <span class="keyword">catch</span> (Throwable ex) &#123;  </div><div class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(  </div><div class="line">                      <span class="keyword">this</span>.beanDefinition.getResourceDescription(), <span class="keyword">this</span>.beanName,  </div><div class="line">                      <span class="string">"Error converting typed String value for "</span> + argName, ex);  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">else</span> &#123;  </div><div class="line">          <span class="keyword">return</span> evaluate(value);  </div><div class="line">      &#125;  </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>可以看出，对应不同类型的属性，调用不同的方法进行解析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//解析引用类型的属性值  </span></div><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">resolveReference</span><span class="params">(Object argName, RuntimeBeanReference ref)</span> </span>&#123;  </div><div class="line">    <span class="keyword">try</span> &#123;  </div><div class="line">        <span class="comment">//获取引用的Bean名称  </span></div><div class="line">        String refName = ref.getBeanName();  </div><div class="line">        refName = String.valueOf(evaluate(refName));  </div><div class="line">        <span class="comment">//如果引用的对象在父类容器中，则从父类容器中获取指定的引用对象  </span></div><div class="line">        <span class="keyword">if</span> (ref.isToParent()) &#123;  </div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.getParentBeanFactory() == <span class="keyword">null</span>) &#123;  </div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(  </div><div class="line">                        <span class="keyword">this</span>.beanDefinition.getResourceDescription(), <span class="keyword">this</span>.beanName,  </div><div class="line">                        <span class="string">"Can't resolve reference to bean '"</span> + refName +  </div><div class="line">                        <span class="string">"' in parent factory: no parent factory available"</span>);  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.beanFactory.getParentBeanFactory().getBean(refName);  </div><div class="line">        &#125;  </div><div class="line">        <span class="comment">//从当前的容器中获取指定的引用Bean对象，如果指定的Bean没有被实例化  </span></div><div class="line">        <span class="comment">//则会递归触发引用Bean的初始化和依赖注入  </span></div><div class="line">        <span class="keyword">else</span> &#123;  </div><div class="line">            Object bean = <span class="keyword">this</span>.beanFactory.getBean(refName);  </div><div class="line">            <span class="comment">//将当前实例化对象的依赖引用对象  </span></div><div class="line">            <span class="keyword">this</span>.beanFactory.registerDependentBean(refName, <span class="keyword">this</span>.beanName);  </div><div class="line">            <span class="keyword">return</span> bean;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(  </div><div class="line">                <span class="keyword">this</span>.beanDefinition.getResourceDescription(), <span class="keyword">this</span>.beanName,  </div><div class="line">                <span class="string">"Cannot resolve reference to bean '"</span> + ref.getBeanName() + <span class="string">"' while setting "</span> + argName, ex);  </div><div class="line">    &#125;  </div><div class="line">&#125;   </div><div class="line"><span class="comment">//解析array类型的属性  </span></div><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">resolveManagedArray</span><span class="params">(Object argName, List&lt;?&gt; ml, Class elementType)</span> </span>&#123;  </div><div class="line">    <span class="comment">//创建一个指定类型的数组，用于存放和返回解析后的数组  </span></div><div class="line">    Object resolved = Array.newInstance(elementType, ml.size());  </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ml.size(); i++) &#123;  </div><div class="line">    <span class="comment">//递归解析array的每一个元素，并将解析后的值设置到resolved数组中，索引为i  </span></div><div class="line">        Array.set(resolved, i,  </div><div class="line">            resolveValueIfNecessary(<span class="keyword">new</span> KeyedArgName(argName, i), ml.get(i)));  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> resolved;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">//解析list类型的属性  </span></div><div class="line"><span class="function"><span class="keyword">private</span> List <span class="title">resolveManagedList</span><span class="params">(Object argName, List&lt;?&gt; ml)</span> </span>&#123;  </div><div class="line">    List&lt;Object&gt; resolved = <span class="keyword">new</span> ArrayList&lt;Object&gt;(ml.size());  </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ml.size(); i++) &#123;  </div><div class="line">        <span class="comment">//递归解析list的每一个元素  </span></div><div class="line">        resolved.add(  </div><div class="line">            resolveValueIfNecessary(<span class="keyword">new</span> KeyedArgName(argName, i), ml.get(i)));  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> resolved;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">//解析set类型的属性  </span></div><div class="line"><span class="function"><span class="keyword">private</span> Set <span class="title">resolveManagedSet</span><span class="params">(Object argName, Set&lt;?&gt; ms)</span> </span>&#123;  </div><div class="line">    Set&lt;Object&gt; resolved = <span class="keyword">new</span> LinkedHashSet&lt;Object&gt;(ms.size());  </div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;  </div><div class="line">    <span class="comment">//递归解析set的每一个元素  </span></div><div class="line">    <span class="keyword">for</span> (Object m : ms) &#123;  </div><div class="line">        resolved.add(resolveValueIfNecessary(<span class="keyword">new</span> KeyedArgName(argName, i), m));  </div><div class="line">        i++;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> resolved;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">//解析map类型的属性  </span></div><div class="line"><span class="function"><span class="keyword">private</span> Map <span class="title">resolveManagedMap</span><span class="params">(Object argName, Map&lt;?, ?&gt; mm)</span> </span>&#123;  </div><div class="line">    Map&lt;Object, Object&gt; resolved = <span class="keyword">new</span> LinkedHashMap&lt;Object, Object&gt;(mm.size());  </div><div class="line">    <span class="comment">//递归解析map中每一个元素的key和value  </span></div><div class="line">    <span class="keyword">for</span> (Map.Entry entry : mm.entrySet()) &#123;  </div><div class="line">        Object resolvedKey = resolveValueIfNecessary(argName, entry.getKey());  </div><div class="line">        Object resolvedValue = resolveValueIfNecessary(  </div><div class="line">                <span class="keyword">new</span> KeyedArgName(argName, entry.getKey()), entry.getValue());  </div><div class="line">        resolved.put(resolvedKey, resolvedValue);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> resolved;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解析结束之后就是最后的注入过程了。</p>
<h2 id="7、BeanWrapperImpl对Bean属性的依赖注入"><a href="#7、BeanWrapperImpl对Bean属性的依赖注入" class="headerlink" title="7、BeanWrapperImpl对Bean属性的依赖注入"></a>7、BeanWrapperImpl对Bean属性的依赖注入</h2><p>BeanWrapperImpl类主要是对容器中完成初始化的Bean实例对象进行属性的依赖注入，即把Bean对象设置到它所依赖的另一个Bean的属性中去，依赖注入的相关源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//实现属性依赖注入功能  </span></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setPropertyValue</span><span class="params">(PropertyTokenHolder tokens, PropertyValue pv)</span> <span class="keyword">throws</span> BeansException </span>&#123;  </div><div class="line">      <span class="comment">//PropertyTokenHolder主要保存属性的名称、路径，以及集合的size等信息  </span></div><div class="line">      String propertyName = tokens.canonicalName;  </div><div class="line">      String actualName = tokens.actualName;  </div><div class="line">      <span class="comment">//keys是用来保存集合类型属性的size  </span></div><div class="line">      <span class="keyword">if</span> (tokens.keys != <span class="keyword">null</span>) &#123;  </div><div class="line">          <span class="comment">//将属性信息拷贝  </span></div><div class="line">          PropertyTokenHolder getterTokens = <span class="keyword">new</span> PropertyTokenHolder();  </div><div class="line">          getterTokens.canonicalName = tokens.canonicalName;  </div><div class="line">          getterTokens.actualName = tokens.actualName;  </div><div class="line">          getterTokens.keys = <span class="keyword">new</span> String[tokens.keys.length - <span class="number">1</span>];  </div><div class="line">          System.arraycopy(tokens.keys, <span class="number">0</span>, getterTokens.keys, <span class="number">0</span>, tokens.keys.length - <span class="number">1</span>);  </div><div class="line">          Object propValue;  </div><div class="line">          <span class="keyword">try</span> &#123;  </div><div class="line">              <span class="comment">//获取属性值，该方法内部使用JDK的内省( Introspector)机制，调用属性//的getter(readerMethod)方法，获取属性的值  </span></div><div class="line">              propValue = getPropertyValue(getterTokens);  </div><div class="line">          &#125;  </div><div class="line">          <span class="keyword">catch</span> (NotReadablePropertyException ex) &#123;  </div><div class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> NotWritablePropertyException(getRootClass(), <span class="keyword">this</span>.nestedPath + propertyName,  </div><div class="line">                      <span class="string">"Cannot access indexed value in property referenced "</span> +  </div><div class="line">                      <span class="string">"in indexed property path '"</span> + propertyName + <span class="string">"'"</span>, ex);  </div><div class="line">          &#125;  </div><div class="line">          <span class="comment">//获取集合类型属性的长度  </span></div><div class="line">          String key = tokens.keys[tokens.keys.length - <span class="number">1</span>];  </div><div class="line">          <span class="keyword">if</span> (propValue == <span class="keyword">null</span>) &#123;  </div><div class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> NullValueInNestedPathException(getRootClass(), <span class="keyword">this</span>.nestedPath + propertyName,  </div><div class="line">                      <span class="string">"Cannot access indexed value in property referenced "</span> +  </div><div class="line">                      <span class="string">"in indexed property path '"</span> + propertyName + <span class="string">"': returned null"</span>);  </div><div class="line">          &#125;  </div><div class="line">          <span class="comment">//注入array类型的属性值  </span></div><div class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (propValue.getClass().isArray()) &#123;  </div><div class="line">              <span class="comment">//获取属性的描述符  </span></div><div class="line">              PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);  </div><div class="line">              <span class="comment">//获取数组的类型  </span></div><div class="line">              Class requiredType = propValue.getClass().getComponentType();  </div><div class="line">              <span class="comment">//获取数组的长度  </span></div><div class="line">              <span class="keyword">int</span> arrayIndex = Integer.parseInt(key);  </div><div class="line">              Object oldValue = <span class="keyword">null</span>;  </div><div class="line">              <span class="keyword">try</span> &#123;  </div><div class="line">                  <span class="comment">//获取数组以前初始化的值  </span></div><div class="line">                  <span class="keyword">if</span> (isExtractOldValueForEditor()) &#123;  </div><div class="line">                      oldValue = Array.get(propValue, arrayIndex);  </div><div class="line">                  &#125;  </div><div class="line">                  <span class="comment">//将属性的值赋值给数组中的元素  </span></div><div class="line">                  Object convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,  </div><div class="line">                          <span class="keyword">new</span> PropertyTypeDescriptor(pd, <span class="keyword">new</span> MethodParameter(pd.getReadMethod(), -<span class="number">1</span>), requiredType));  </div><div class="line">                  Array.set(propValue, arrayIndex, convertedValue);  </div><div class="line">              &#125;  </div><div class="line">              <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;  </div><div class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> InvalidPropertyException(getRootClass(), <span class="keyword">this</span>.nestedPath + propertyName,  </div><div class="line">                          <span class="string">"Invalid array index in property path '"</span> + propertyName + <span class="string">"'"</span>, ex);  </div><div class="line">              &#125;  </div><div class="line">          &#125;  </div><div class="line">          <span class="comment">//注入list类型的属性值  </span></div><div class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (propValue <span class="keyword">instanceof</span> List) &#123;  </div><div class="line">              PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);  </div><div class="line">              <span class="comment">//获取list集合的类型  </span></div><div class="line">              Class requiredType = GenericCollectionTypeResolver.getCollectionReturnType(  </div><div class="line">                      pd.getReadMethod(), tokens.keys.length);  </div><div class="line">              List list = (List) propValue;  </div><div class="line">              <span class="comment">//获取list集合的size  </span></div><div class="line">              <span class="keyword">int</span> index = Integer.parseInt(key);  </div><div class="line">              Object oldValue = <span class="keyword">null</span>;  </div><div class="line">              <span class="keyword">if</span> (isExtractOldValueForEditor() &amp;&amp; index &lt; list.size()) &#123;  </div><div class="line">                  oldValue = list.get(index);  </div><div class="line">              &#125;  </div><div class="line">              <span class="comment">//获取list解析后的属性值  </span></div><div class="line">              Object convertedValue = convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType,  </div><div class="line">                      <span class="keyword">new</span> PropertyTypeDescriptor(pd, <span class="keyword">new</span> MethodParameter(pd.getReadMethod(), -<span class="number">1</span>), requiredType));  </div><div class="line">              <span class="keyword">if</span> (index &lt; list.size()) &#123;  </div><div class="line">                  <span class="comment">//为list属性赋值  </span></div><div class="line">                  list.set(index, convertedValue);  </div><div class="line">              &#125;  </div><div class="line">              <span class="comment">//如果list的长度大于属性值的长度，则多余的元素赋值为null  </span></div><div class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (index &gt;= list.size()) &#123;  </div><div class="line">                  <span class="keyword">for</span> (<span class="keyword">int</span> i = list.size(); i &lt; index; i++) &#123;  </div><div class="line">                      <span class="keyword">try</span> &#123;  </div><div class="line">                          list.add(<span class="keyword">null</span>);  </div><div class="line">                      &#125;  </div><div class="line">                      <span class="keyword">catch</span> (NullPointerException ex) &#123;  </div><div class="line">                          <span class="keyword">throw</span> <span class="keyword">new</span> InvalidPropertyException(getRootClass(), <span class="keyword">this</span>.nestedPath + propertyName,  </div><div class="line">                                  <span class="string">"Cannot set element with index "</span> + index + <span class="string">" in List of size "</span> +  </div><div class="line">                                  list.size() + <span class="string">", accessed using property path '"</span> + propertyName +  </div><div class="line">                                  <span class="string">"': List does not support filling up gaps with null elements"</span>);  </div><div class="line">                      &#125;  </div><div class="line">                  &#125;  </div><div class="line">                  list.add(convertedValue);  </div><div class="line">              &#125;  </div><div class="line">          &#125;  </div><div class="line">          <span class="comment">//注入map类型的属性值  </span></div><div class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (propValue <span class="keyword">instanceof</span> Map) &#123;  </div><div class="line">              PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);  </div><div class="line">              <span class="comment">//获取map集合key的类型  </span></div><div class="line">              Class mapKeyType = GenericCollectionTypeResolver.getMapKeyReturnType(  </div><div class="line">                      pd.getReadMethod(), tokens.keys.length);  </div><div class="line">              <span class="comment">//获取map集合value的类型  </span></div><div class="line">              Class mapValueType = GenericCollectionTypeResolver.getMapValueReturnType(  </div><div class="line">                      pd.getReadMethod(), tokens.keys.length);  </div><div class="line">              Map map = (Map) propValue;  </div><div class="line">              <span class="comment">//解析map类型属性key值  </span></div><div class="line">              Object convertedMapKey = convertIfNecessary(<span class="keyword">null</span>, <span class="keyword">null</span>, key, mapKeyType,  </div><div class="line">                      <span class="keyword">new</span> PropertyTypeDescriptor(pd, <span class="keyword">new</span> MethodParameter(pd.getReadMethod(), -<span class="number">1</span>), mapKeyType));  </div><div class="line">              Object oldValue = <span class="keyword">null</span>;  </div><div class="line">              <span class="keyword">if</span> (isExtractOldValueForEditor()) &#123;  </div><div class="line">                  oldValue = map.get(convertedMapKey);  </div><div class="line">              &#125;  </div><div class="line">              <span class="comment">//解析map类型属性value值  </span></div><div class="line">              Object convertedMapValue = convertIfNecessary(  </div><div class="line">                      propertyName, oldValue, pv.getValue(), mapValueType,  </div><div class="line">                      <span class="keyword">new</span> TypeDescriptor(<span class="keyword">new</span> MethodParameter(pd.getReadMethod(), -<span class="number">1</span>, tokens.keys.length + <span class="number">1</span>)));  </div><div class="line">              <span class="comment">//将解析后的key和value值赋值给map集合属性  </span></div><div class="line">              map.put(convertedMapKey, convertedMapValue);  </div><div class="line">          &#125;  </div><div class="line">          <span class="keyword">else</span> &#123;  </div><div class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> InvalidPropertyException(getRootClass(), <span class="keyword">this</span>.nestedPath + propertyName,  </div><div class="line">                      <span class="string">"Property referenced in indexed property path '"</span> + propertyName +  </div><div class="line">                      <span class="string">"' is neither an array nor a List nor a Map; returned value was ["</span> + pv.getValue() + <span class="string">"]"</span>);  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//对非集合类型的属性注入  </span></div><div class="line">      <span class="keyword">else</span> &#123;  </div><div class="line">          PropertyDescriptor pd = pv.resolvedDescriptor;  </div><div class="line">          <span class="keyword">if</span> (pd == <span class="keyword">null</span> || !pd.getWriteMethod().getDeclaringClass().isInstance(<span class="keyword">this</span>.object)) &#123;  </div><div class="line">              pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);  </div><div class="line">              <span class="comment">//无法获取到属性名或者属性没有提供setter(写方法)方法  </span></div><div class="line">              <span class="keyword">if</span> (pd == <span class="keyword">null</span> || pd.getWriteMethod() == <span class="keyword">null</span>) &#123;  </div><div class="line">                  <span class="comment">//如果属性值是可选的，即不是必须的，则忽略该属性值  </span></div><div class="line">                  <span class="keyword">if</span> (pv.isOptional()) &#123;  </div><div class="line">                      logger.debug(<span class="string">"Ignoring optional value for property '"</span> + actualName +  </div><div class="line">                              <span class="string">"' - property not found on bean class ["</span> + getRootClass().getName() + <span class="string">"]"</span>);  </div><div class="line">                      <span class="keyword">return</span>;  </div><div class="line">                  &#125;  </div><div class="line">                  <span class="comment">//如果属性值是必须的，则抛出无法给属性赋值，因为没有提供setter方法异常  </span></div><div class="line">                  <span class="keyword">else</span> &#123;  </div><div class="line">                      PropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass());  </div><div class="line">                      <span class="keyword">throw</span> <span class="keyword">new</span> NotWritablePropertyException(  </div><div class="line">                              getRootClass(), <span class="keyword">this</span>.nestedPath + propertyName,  </div><div class="line">                              matches.buildErrorMessage(), matches.getPossibleMatches());  </div><div class="line">                  &#125;  </div><div class="line">              &#125;  </div><div class="line">              pv.getOriginalPropertyValue().resolvedDescriptor = pd;  </div><div class="line">          &#125;  </div><div class="line">          Object oldValue = <span class="keyword">null</span>;  </div><div class="line">          <span class="keyword">try</span> &#123;  </div><div class="line">              Object originalValue = pv.getValue();  </div><div class="line">              Object valueToApply = originalValue;  </div><div class="line">              <span class="keyword">if</span> (!Boolean.FALSE.equals(pv.conversionNecessary)) &#123;  </div><div class="line">                  <span class="keyword">if</span> (pv.isConverted()) &#123;  </div><div class="line">                      valueToApply = pv.getConvertedValue();  </div><div class="line">                  &#125;  </div><div class="line">                  <span class="keyword">else</span> &#123;  </div><div class="line">                      <span class="keyword">if</span> (isExtractOldValueForEditor() &amp;&amp; pd.getReadMethod() != <span class="keyword">null</span>) &#123;  </div><div class="line">                          <span class="comment">//获取属性的getter方法(读方法)，JDK内省机制  </span></div><div class="line">                          <span class="keyword">final</span> Method readMethod = pd.getReadMethod();  </div><div class="line">                          <span class="comment">//如果属性的getter方法不是public访问控制权限的，即访问控制权限比较严格，  </span></div><div class="line">                          <span class="comment">//则使用JDK的反射机制强行访问非public的方法(暴力读取属性值)  </span></div><div class="line">                          <span class="keyword">if</span> (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) &amp;&amp;  </div><div class="line">                                  !readMethod.isAccessible()) &#123;  </div><div class="line">                              <span class="keyword">if</span> (System.getSecurityManager()!= <span class="keyword">null</span>) &#123;  </div><div class="line">                                  <span class="comment">//匿名内部类，根据权限修改属性的读取控制限制  </span></div><div class="line">                                  AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;  </div><div class="line">                                      <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">                                          readMethod.setAccessible(<span class="keyword">true</span>);  </div><div class="line">                                          <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">                                      &#125;  </div><div class="line">                                  &#125;);  </div><div class="line">                              &#125;  </div><div class="line">                              <span class="keyword">else</span> &#123;  </div><div class="line">                                  readMethod.setAccessible(<span class="keyword">true</span>);  </div><div class="line">                              &#125;  </div><div class="line">                          &#125;  </div><div class="line">                          <span class="keyword">try</span> &#123;  </div><div class="line">                              <span class="comment">//属性没有提供getter方法时，调用潜在的读取属性值的方法，获取属性值  </span></div><div class="line">                              <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;  </div><div class="line">                                  oldValue = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Object&gt;() &#123;  </div><div class="line">                                      <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">                                          <span class="keyword">return</span> readMethod.invoke(object);  </div><div class="line">                                      &#125;  </div><div class="line">                                  &#125;, acc);  </div><div class="line">                              &#125;  </div><div class="line">                              <span class="keyword">else</span> &#123;  </div><div class="line">                                  oldValue = readMethod.invoke(object);  </div><div class="line">                              &#125;  </div><div class="line">                          &#125;  </div><div class="line">                          <span class="keyword">catch</span> (Exception ex) &#123;  </div><div class="line">                              <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> PrivilegedActionException) &#123;  </div><div class="line">                                  ex = ((PrivilegedActionException) ex).getException();  </div><div class="line">                              &#125;  </div><div class="line">                              <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </div><div class="line">                                  logger.debug(<span class="string">"Could not read previous value of property '"</span> +  </div><div class="line">                                          <span class="keyword">this</span>.nestedPath + propertyName + <span class="string">"'"</span>, ex);  </div><div class="line">                              &#125;  </div><div class="line">                          &#125;  </div><div class="line">                      &#125;  </div><div class="line">                      <span class="comment">//设置属性的注入值  </span></div><div class="line">                      valueToApply = convertForProperty(propertyName, oldValue, originalValue, pd);  </div><div class="line">                  &#125;  </div><div class="line">                  pv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);  </div><div class="line">              &#125;  </div><div class="line">              <span class="comment">//根据JDK的内省机制，获取属性的setter(写方法)方法  </span></div><div class="line">              <span class="keyword">final</span> Method writeMethod = (pd <span class="keyword">instanceof</span> GenericTypeAwarePropertyDescriptor ?  </div><div class="line">                      ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() :  </div><div class="line">                      pd.getWriteMethod());  </div><div class="line">              <span class="comment">//如果属性的setter方法是非public，即访问控制权限比较严格，则使用JDK的反射机制，  </span></div><div class="line">              <span class="comment">//强行设置setter方法可访问(暴力为属性赋值)  </span></div><div class="line">              <span class="keyword">if</span> (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) &amp;&amp; !writeMethod.isAccessible()) &#123;  </div><div class="line">                  <span class="comment">//如果使用了JDK的安全机制，则需要权限验证  </span></div><div class="line">                  <span class="keyword">if</span> (System.getSecurityManager()!= <span class="keyword">null</span>) &#123;  </div><div class="line">                      AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;  </div><div class="line">                          <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">                              writeMethod.setAccessible(<span class="keyword">true</span>);  </div><div class="line">                              <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">                          &#125;  </div><div class="line">                      &#125;);  </div><div class="line">                  &#125;  </div><div class="line">                  <span class="keyword">else</span> &#123;  </div><div class="line">                      writeMethod.setAccessible(<span class="keyword">true</span>);  </div><div class="line">                  &#125;  </div><div class="line">              &#125;  </div><div class="line">              <span class="keyword">final</span> Object value = valueToApply;  </div><div class="line">              <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;  </div><div class="line">                  <span class="keyword">try</span> &#123;  </div><div class="line">                      <span class="comment">//将属性值设置到属性上去  </span></div><div class="line">                      AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Object&gt;() &#123;  </div><div class="line">                          <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">                              writeMethod.invoke(object, value);  </div><div class="line">                              <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">                          &#125;  </div><div class="line">                      &#125;, acc);  </div><div class="line">                  &#125;  </div><div class="line">                  <span class="keyword">catch</span> (PrivilegedActionException ex) &#123;  </div><div class="line">                      <span class="keyword">throw</span> ex.getException();  </div><div class="line">                  &#125;  </div><div class="line">              &#125;  </div><div class="line">              <span class="keyword">else</span> &#123;  </div><div class="line">                  writeMethod.invoke(<span class="keyword">this</span>.object, value);  </div><div class="line">              &#125;  </div><div class="line">          &#125;  </div><div class="line">          <span class="keyword">catch</span> (TypeMismatchException ex) &#123;  </div><div class="line">              <span class="keyword">throw</span> ex;  </div><div class="line">          &#125;  </div><div class="line">          <span class="keyword">catch</span> (InvocationTargetException ex) &#123;  </div><div class="line">              PropertyChangeEvent propertyChangeEvent =  </div><div class="line">                      <span class="keyword">new</span> PropertyChangeEvent(<span class="keyword">this</span>.rootObject, <span class="keyword">this</span>.nestedPath + propertyName, oldValue, pv.getValue());  </div><div class="line">              <span class="keyword">if</span> (ex.getTargetException() <span class="keyword">instanceof</span> ClassCastException) &#123;  </div><div class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());  </div><div class="line">              &#125;  </div><div class="line">              <span class="keyword">else</span> &#123;  </div><div class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> MethodInvocationException(propertyChangeEvent, ex.getTargetException());  </div><div class="line">              &#125;  </div><div class="line">          &#125;  </div><div class="line">          <span class="keyword">catch</span> (Exception ex) &#123;  </div><div class="line">              PropertyChangeEvent pce =  </div><div class="line">                      <span class="keyword">new</span> PropertyChangeEvent(<span class="keyword">this</span>.rootObject, <span class="keyword">this</span>.nestedPath + propertyName, oldValue, pv.getValue());  </div><div class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> MethodInvocationException(pce, ex);  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>通过对上面注入依赖代码的分析，我们已经明白了Spring IoC容器是如何将属性的值注入到Bean实例对象中去的：</p>
<ol>
<li>对于集合类型的属性，将其属性值解析为目标类型的集合后直接赋值给属性。</li>
<li>对于非集合类型的属性，大量使用了JDK的反射和内省机制，通过属性的getter方法(reader method)获取指定属性注入以前的值，同时调用属性的setter方法(writer method)为属性设置注入后的值。看到这里相信很多人都明白了Spring的setter注入原理。</li>
</ol>
<h1 id="二、总结"><a href="#二、总结" class="headerlink" title="二、总结"></a>二、总结</h1><p>再回顾一下整个依赖注入的过程：</p>
<ol>
<li><p>AbstractBeanFactory中的getBean方法来获取Bean：</p>
<p>在缓存中查找，如果存在则直接返回，否则开始下一步创建Bean</p>
</li>
<li><p>AbstractAutowireCapableBeanFactory类中创建Bean，这个类中有几个关键方法：</p>
<ol>
<li><p>createBean方法：创建容器指定的Bean实例对象的入口</p>
<p>同时还对创建的Bean实例对象进行初始化处理比如init-method、后置处理器等，然后调用下面的两个方法创建实例并注入依赖</p>
</li>
<li><p>createBeanInstance方法：创建Bean的Java实例对象，分两种情况</p>
<ul>
<li>对于使用工厂方法和自动装配特性的bean的实例化：则调用对应的工厂方法或者参数匹配的构造方法即可完成实例化对象的工作</li>
<li>否则调用默认的无参构造器进行实例化即SimpleInstantiationStrategy的instantiate方法，<ul>
<li>使用Java的反射技术</li>
<li>使用CGLIB</li>
</ul>
</li>
</ul>
</li>
<li><p>populateBean方法：实例化之后，根据属性类型决定是否需要解析，最后通过BeanWrapperImpl类完成对属性的注入，对属性的类型也要进行判断：</p>
<ul>
<li>属性值类型不需要转换时，不需要解析属性值，直接准备进行依赖注入</li>
<li>属性值需要进行类型转换时，如对其他对象的引用等，首先需要解析属性值，然后对解析后的属性值进行依赖注入。解析过程由BeanDefinitionValueResolver类的setPropertyValue方法完成</li>
</ul>
</li>
</ol>
</li>
<li><p>BeanWrapperImpl对Bean属性的依赖注入：</p>
<ul>
<li>对于集合类属性，将其属性值解析为目标类型的集合后直接赋值给属性。</li>
<li>对于非集合类型的属性，大量使用了JDK的反射和内省机制，通过属性的getter方法(reader method)获取指定属性注入以前的值，同时调用属性的setter方法(writer method)为属性设置注入后的值。</li>
</ul>
</li>
</ol>
<p>虽然上面分析了这么多，但核心过程就是上面的这几句话。</p>
<h1 id="三、参考地址"><a href="#三、参考地址" class="headerlink" title="三、参考地址"></a>三、参考地址</h1><p><a href="http://www.cnblogs.com/ITtangtang/p/3978349.html" target="_blank" rel="external">http://www.cnblogs.com/ITtangtang/p/3978349.html</a></p>
<p><a href="http://blog.csdn.net/u012291108/article/details/51881511" target="_blank" rel="external">http://blog.csdn.net/u012291108/article/details/51881511</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_4ada12a50100l3ap.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_4ada12a50100l3ap.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring基础知识（二）：依赖注入]]></title>
      <url>http://yoursite.com/2016/12/31/spring/Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(2)%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
      <content type="html"><![CDATA[<p>Spring最重要的两个特性就是依赖注入DI和面向切面编程AOP。</p>
<h1 id="一、依赖注入"><a href="#一、依赖注入" class="headerlink" title="一、依赖注入"></a>一、依赖注入</h1><h2 id="1、依赖注入与控制反转"><a href="#1、依赖注入与控制反转" class="headerlink" title="1、依赖注入与控制反转"></a>1、依赖注入与控制反转</h2><p>这两个概念经常被用来比较，个人理解应该是他们描述的角度的不同的。</p>
<h3 id="1-1、依赖注入"><a href="#1-1、依赖注入" class="headerlink" title="1.1、依赖注入"></a>1.1、依赖注入</h3><p>理解依赖注入，首先要知道这里说的依赖指的是什么</p>
<p>正常的程序中肯定是有很多个类一起协同工作的，比如一个A类要用到另一个B类的某个方法，那么则表示B类是A类的一个依赖。</p>
<p>那么A类可以自己new一个B类的实例出来，然后再需要的时候进行调用，但是这样做有很多问题，会导致<strong>高度耦合</strong>和<strong>难以测试</strong>。</p>
<p>而如果使用依赖注入的方式，则可以带来一个最明显的好处就是-<strong>松耦合</strong>。</p>
<blockquote>
<p>如果一个对象只通过接口（而不是具体实现或初始化过程）来表明依赖，你们这种依赖就能够在对象本身毫不知情的情况下，用不同的具体实现进行替换。</p>
</blockquote>
<h3 id="1-2、控制反转"><a href="#1-2、控制反转" class="headerlink" title="1.2、控制反转"></a>1.2、控制反转</h3><p>控制反转的意思我理解的就是，所有的依赖都统一交给Spring的容器去管理，</p>
<ul>
<li>控制的具体含义就是对依赖的注入</li>
<li>而反转是指，依赖的注入本来由自己控制的东西，交给了容器去控制，实现了主动权的反转。</li>
</ul>
<h2 id="2、依赖的注入方式"><a href="#2、依赖的注入方式" class="headerlink" title="2、依赖的注入方式"></a>2、依赖的注入方式</h2><p>说到依赖的注入方式还是离不开Spring的容器，Spring容器负责创建应用程序中的bean并通过DI来协调这些对象之间的关系。所以想要了解依赖的注入方式，就要先知道bean的装配方式</p>
<ul>
<li>在XML中进行显式配置</li>
<li>在Java代码中进行显式配置</li>
<li>隐式的bean发现机制和自动装配</li>
</ul>
<p>以XML配置的方式为例，依赖注入有四种方式：</p>
<ol>
<li>set注入</li>
<li>构造器注入</li>
<li>静态工厂方法注入</li>
<li>实例工厂方法注入</li>
</ol>
<h3 id="2-1、set注入"><a href="#2-1、set注入" class="headerlink" title="2.1、set注入"></a>2.1、set注入</h3><p>这是最简单的注入方式，假设有一个SpringAction，类中需要实例化一个SpringDao对象，那么就可以定义一个private的SpringDao成员变量，然后创建SpringDao的set方法（这是ioc的注入入口）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringAction</span> </span>&#123;  </div><div class="line">    <span class="comment">//注入对象springDao  </span></div><div class="line">    <span class="keyword">private</span> SpringDao springDao;  </div><div class="line">    </div><div class="line">    <span class="comment">//一定要写被注入对象的set方法  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSpringDao</span><span class="params">(SpringDao springDao)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.springDao = springDao;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ok</span><span class="params">()</span></span>&#123;  </div><div class="line">        springDao.ok();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>随后编写spring的xml文件，<code>&lt;bean&gt;</code>中的name属性是class属性的一个别名，class属性指类的全名，因为在SpringAction中有一个公共属性Springdao，所以要在<code>&lt;bean&gt;</code>标签中创建一个<code>&lt;property&gt;</code>标签指定SpringDao。<code>&lt;property&gt;</code>标签中的name就是SpringAction类中的SpringDao属性名，ref指下面<code>&lt;bean name=&quot;springDao&quot;...&gt;</code>，这样其实是spring将SpringDaoImpl对象实例化并且调用SpringAction的setSpringDao方法将SpringDao注入：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--配置bean,配置后该类由spring管理--&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"springAction"</span> <span class="attr">class</span>=<span class="string">"com.bless.springdemo.action.SpringAction"</span>&gt;</span>  </div><div class="line">    <span class="comment">&lt;!--(1)依赖注入,配置当前类中相应的属性--&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"springDao"</span> <span class="attr">ref</span>=<span class="string">"springDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"springDao"</span> <span class="attr">class</span>=<span class="string">"com.bless.springdemo.dao.impl.SpringDaoImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="2-2、构造器注入"><a href="#2-2、构造器注入" class="headerlink" title="2.2、构造器注入"></a>2.2、构造器注入</h3><p>这种方式的注入是指带有参数的构造函数注入，看下面的例子，我创建了两个成员变量SpringDao和User，但是并未设置对象的set方法，所以就不能支持第一种注入方式，这里的注入方式是在SpringAction的构造函数中注入，也就是说在创建SpringAction对象时要将SpringDao和User两个参数值传进来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringAction</span> </span>&#123;  </div><div class="line">    <span class="comment">//注入对象springDao  </span></div><div class="line">    <span class="keyword">private</span> SpringDao springDao;  </div><div class="line">    <span class="keyword">private</span> User user;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpringAction</span><span class="params">(SpringDao springDao,User user)</span></span>&#123;  </div><div class="line">        <span class="keyword">this</span>.springDao = springDao;  </div><div class="line">        <span class="keyword">this</span>.user = user;  </div><div class="line">        System.out.println(<span class="string">"构造方法调用springDao和user"</span>);  </div><div class="line">    &#125;  </div><div class="line">          </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123;  </div><div class="line">    	user.setName(<span class="string">"卡卡"</span>);  </div><div class="line">    	springDao.save(user);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在XML文件中同样不用<code>&lt;property&gt;</code>的形式，而是使用<code>&lt;constructor-arg&gt;</code>标签，ref属性同样指向其它<code>&lt;bean&gt;</code>标签的name属性：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--配置bean,配置后该类由spring管理--&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"springAction"</span> <span class="attr">class</span>=<span class="string">"com.bless.springdemo.action.SpringAction"</span>&gt;</span>  </div><div class="line">        <span class="comment">&lt;!--(2)创建构造器注入,如果主类有带参的构造方法则需添加此配置--&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"springDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"user"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"springDao"</span> <span class="attr">class</span>=<span class="string">"com.bless.springdemo.dao.impl.SpringDaoImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.bless.springdemo.vo.User"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>剩下的两种工厂方法的注入方式没有用过，不详细介绍了。</p>
<h3 id="2-3、自动装配"><a href="#2-3、自动装配" class="headerlink" title="2.3、自动装配"></a>2.3、自动装配</h3><p>除了xml的装配方式，实际使用中更多的是使用自动装配的方式。Spring从两个角度来实现自动化装配：</p>
<ul>
<li>组建扫描（component scanning）：Spring会自动发现应用上下文中锁创建的bean</li>
<li>自动装载（autowiring）：Spring自动满足bean之间的依赖</li>
</ul>
<p>这两个分别对应了注解@Component和@Autowiring</p>
<ul>
<li>@Component：这个注解表明该类会作为组件类，并告知Spring要为这个类创建bean</li>
<li>@AutoWiring：可以用在构造方法或set方法上，表明注入一个依赖</li>
</ul>
<p>比如，构造器注入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">aa</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</div><div class="line">    A a;</div><div class="line">    </div><div class="line">    <span class="meta">@AutoWiring</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(A a)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.a=a;</div><div class="line">    &#125; 	</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</div><div class="line">        a.fun();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>set注入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">   <span class="meta">@Component</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</div><div class="line">   	A a;</div><div class="line">    </div><div class="line">    <span class="meta">@AutoWiring</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(A a)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.a = a;</div><div class="line">       &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</div><div class="line">   		a.fun();</div><div class="line">   	&#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="2-4、set注入与构造器注入的区别"><a href="#2-4、set注入与构造器注入的区别" class="headerlink" title="2.4、set注入与构造器注入的区别"></a>2.4、set注入与构造器注入的区别</h3><p><a href="http://blog.sina.com.cn/s/blog_ad071a810101g9wx.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_ad071a810101g9wx.html</a></p>
<h3 id="Component-Service-Controller-Repository"><a href="#Component-Service-Controller-Repository" class="headerlink" title="@Component,@Service,@Controller,@Repository"></a>@Component,@Service,@Controller,@Repository</h3><p>Spring 2.5 中除了提供 @Component 注释外，还定义了几个拥有特殊语义的注释，它们分别是：</p>
<ul>
<li>@Repository</li>
<li>@Service</li>
<li>@Controller。</li>
</ul>
<p>在目前的 Spring 版本中，这 3 个注释和 @Component 是等效的，但是从注释类的命名上，很容易看出这 3 个注释分别和持久层、业务层和控制层（Web 层）相对应。</p>
<h2 id="3、Spring的特殊注入"><a href="#3、Spring的特殊注入" class="headerlink" title="3、Spring的特殊注入"></a>3、Spring的特殊注入</h2><p>Spring中还有两种比较特殊的注入方式：就是通过Spring配置文件中的lookup-method和replace-method，这其实是两个方法级别的注入，和一般的属性(Property)注入是不一样的，它们注入的是方法(Method)。</p>
<h3 id="3-1、lookup-method注入"><a href="#3-1、lookup-method注入" class="headerlink" title="3.1、lookup-method注入"></a>3.1、lookup-method注入</h3><p>lookup method注入是spring动态改变bean里方法的实现。方法执行返回的对象，使用spring内原有的这类对象替换，通过改变方法返回值来动态改变方法。内部实现为使用cglib方法，重新生成子类，重写配置的方法和返回对象，达到动态改变的效果。</p>
<p>有种说法这个也叫方法注入，它不同于set注入和构造注入，主要是使用场景不同:一个singleton的Bean需要引用一个prototype的Bean; 一个无状态的Bean需要引用一个有状态的Bean。容器创建之后就加载了所有的Bean. 而BeanA中需要引用的BeanB是状态个不确定的Bean. 那么我们需要在每次需要BeanB的时候都重新让容器加载一次吗? </p>
<p>cglib为我们动态的构造BeanB的子类, 当我们的BeanA需要BeanB的时候, cglib把这个子类对象给BeanA. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object commandState)</span> </span>&#123;</div><div class="line">        <span class="comment">// grab a new instance of the appropriate Command interface</span></div><div class="line">        Command command = createCommand();</div><div class="line">        <span class="comment">// set the state on the (hopefully brand new) Command instance</span></div><div class="line">        command.setState(commandState);</div><div class="line">        <span class="keyword">return</span> command.execute();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">// okay... but where is the implementation of this method?</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title">createCommand</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"command"</span> <span class="attr">class</span>=<span class="string">"fiona.apple.AsyncCommand"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"> </div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"commandManager"</span> <span class="attr">class</span>=<span class="string">"fiona.apple.CommandManager"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">"createCommand"</span> <span class="attr">bean</span>=<span class="string">"command"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>注意：由于采用cglib生成之类的方式，所以需要用来动态注入的类，不能是final修饰的；需要动态注入的方法，也不能是final修饰的。</p>
<p>同时，还得注意command的scope的配置，如果scope配置为singleton，则每次调用方法createCommand，返回的对象都是相同的；如果scope配置为prototype，则每次调用，返回都不同。</p>
<h3 id="3-2、replaced-method注入"><a href="#3-2、replaced-method注入" class="headerlink" title="3.2、replaced-method注入"></a>3.2、replaced-method注入</h3><p>replaced method注入是spring动态改变bean里方法的实现。需要改变的方法，使用spring内原有其他类（需要继承接口org.springframework.beans.factory.support.MethodReplacer）的逻辑，替换这个方法。通过改变方法执行逻辑来动态改变方法。内部实现为使用cglib方法，重新生成子类，重写配置的方法和返回对象，达到动态改变的效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyValueCalculator</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">computeValue</span><span class="params">(String input)</span> </span>&#123;</div><div class="line">        <span class="comment">// some real code...</span></div><div class="line">    &#125; </div><div class="line">    <span class="comment">// some other methods... </span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/**</span></div><div class="line"> * meant to be used to override the existing computeValue(String)</div><div class="line"> * implementation in MyValueCalculator</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplacementComputeValue</span> <span class="keyword">implements</span> <span class="title">MethodReplacer</span> </span>&#123; </div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">reimplement</span><span class="params">(Object o, Method m, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="comment">// get the input value, work with it, and return a computed result</span></div><div class="line">        String input = (String) args[<span class="number">0</span>];</div><div class="line">        ...</div><div class="line">        <span class="keyword">return</span> ...;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myValueCalculator"</span> <span class="attr">class</span>=<span class="string">"x.y.z.MyValueCalculator"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- arbitrary method replacement --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">replaced-method</span> <span class="attr">name</span>=<span class="string">"computeValue"</span> <span class="attr">replacer</span>=<span class="string">"replacementComputeValue"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">arg-type</span>&gt;</span>String<span class="tag">&lt;/<span class="name">arg-type</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">replaced-method</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"> </div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"replacementComputeValue"</span> <span class="attr">class</span>=<span class="string">"a.b.c.ReplacementComputeValue"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>注意：由于采用cglib生成之类的方式，所以需要用来动态注入的类，不能是final修饰的；需要动态注入的方法，也不能是final修饰的。</p>
<h3 id="3-3、二者的区别"><a href="#3-3、二者的区别" class="headerlink" title="3.3、二者的区别"></a>3.3、二者的区别</h3><p>两者的差别是这样的</p>
<ol>
<li>如果需要替换的方法没有返回值，那么只能使用replace-method来替换，而不能用lookup-method来替换。</li>
<li>replace-method必须实现MethodReplacer接口的Bean才能替换，而lookup-method则由BeanFactory自动为我们处理了。</li>
</ol>
<h1 id="二、依赖注入的时机"><a href="#二、依赖注入的时机" class="headerlink" title="二、依赖注入的时机"></a>二、依赖注入的时机</h1><p>在IOC容器中依赖注入的触发有两种情况</p>
<ul>
<li>用户第一次调用getBean方法时触发</li>
<li>通过设置lazy-init属性设置让容器在初始化阶段完成预实例化</li>
</ul>
<p>在第一篇中已经分析过，Spring中bean的作用域有五种，通过scope属性来设置，比较常见的就是singleton和prototype，前者就是单例模式。下面分析的lazy-init时机，基本都是针对singleton的bean的。</p>
<p>关于lazy-init，很多地方都遇见过，大概就是等需要这个东西的时候再将它实例化。</p>
<h2 id="1、spring的default-lazy-init参数"><a href="#1、spring的default-lazy-init参数" class="headerlink" title="1、spring的default-lazy-init参数"></a>1、spring的default-lazy-init参数</h2><p>ApplicationContext实现的默认行为就是在启动服务器时将所有singleton bean提前进行实例化(也就是依赖注入)。提前实例化意味着作为初始化过程的一部分，ApplicationContext实例会创建并配置所有的singleton bean。</p>
<p>这样可以减少web服务器在运行时的负担，但是同时也会增加Spring的启动时间。 </p>
<p>所以在Spring中有一个属性可以来配置是否开启lazy-init，就是在<code>&lt;beans&gt;</code>元素上使用<code>default-lazy-init</code>属性。按照上面的说法，Spring启动的时候没有lazy-init，所以这个属性默认的肯定是false的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt; <span class="attr">beans</span>  <span class="attr">default-lazy-init</span>=<span class="string">"true"</span> &gt;</span>   </div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>设置这个属性以后，就可以实现lazy-init，从而大大减少Spring的启动时间。</p>
<h2 id="2、Spring的lazy-init"><a href="#2、Spring的lazy-init" class="headerlink" title="2、Spring的lazy-init"></a>2、Spring的lazy-init</h2><h3 id="2-1、lazy-init"><a href="#2-1、lazy-init" class="headerlink" title="2.1、lazy-init"></a>2.1、lazy-init</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span> </div><div class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"service1"</span> <span class="attr">type</span>=<span class="string">"bean路径"</span> <span class="attr">lazy-init</span>=<span class="string">"true"</span>/&gt;</span> </div><div class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"service2"</span> <span class="attr">type</span>=<span class="string">"bean路径"</span> <span class="attr">lazy-init</span>=<span class="string">"false"</span>&gt;</span> </div><div class="line">             <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"service1"</span> <span class="attr">ref</span>=<span class="string">"service1"</span>/&gt;</span> </div><div class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>当 IoC容器启动时，service2会实例化，而service1则不会；但是但容器实例化service2时，service1也被实例化了，为什么呢，因为service2需要它。也就是说lazy-init=”true”的bean，IoC容器启动时不会实例化该bean，只有当容器需要用到时才实例化它。lazy-init有利于容器效率，对于不需要的bean可以先不管。 </p>
<h3 id="2-2、-lt-beans-gt-与-lt-bean-gt-的优先级"><a href="#2-2、-lt-beans-gt-与-lt-bean-gt-的优先级" class="headerlink" title="2.2、&lt; beans&gt;与&lt; bean&gt;的优先级"></a>2.2、&lt; beans&gt;与&lt; bean&gt;的优先级</h3><p><strong>在同一个文件中<code>&lt;bean/&gt;</code>里面设置的优先级大于<code>&lt;beans/&gt;</code>里设置的优先级</strong></p>
<h2 id="3、Spring的abstract"><a href="#3、Spring的abstract" class="headerlink" title="3、Spring的abstract"></a>3、Spring的abstract</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baseTxService"</span>  <span class="attr">class</span>=<span class="string">"org.springframework.transaction.interceptor.TransactionProxyFactoryBean"</span>  <span class="attr">abstract</span>=<span class="string">"true"</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>bean abstract=”true”时，该bean不会被实例化，上面的bean是个模板 </p>
<h2 id="4、非单例bean的实例化"><a href="#4、非单例bean的实例化" class="headerlink" title="4、非单例bean的实例化"></a>4、非单例bean的实例化</h2><p>以上说的都是bean为singleton的情况。如果一个bean的scope属性为scope=”pototype”时，即使设置了lazy-init=”false”,容器启动时不实例化bean，而是调用getBean方法实例化的</p>
<p>通过上面的分析可以知道，</p>
<ul>
<li>如果一个bean被设置为lazy-init</li>
<li>在其他bean实例化的时候没有依赖它</li>
<li>或者bean的属性不是singleton</li>
</ul>
<p>那么它在容器初始化阶段并不会实例化，而是第一次getBean的时候实例化，下面详细分析一下getBean的源码。</p>
<h1 id="三、Bean实例化的三种方式"><a href="#三、Bean实例化的三种方式" class="headerlink" title="三、Bean实例化的三种方式"></a>三、Bean实例化的三种方式</h1><p>在Spring中bean的实例化有三种方式</p>
<ol>
<li>使用构造器实例化</li>
<li>使用静态工厂方法实例化</li>
<li>使用实例化工厂方法实例化</li>
</ol>
<h2 id="1、使用构造器实例化"><a href="#1、使用构造器实例化" class="headerlink" title="1、使用构造器实例化"></a>1、使用构造器实例化</h2><p>这种实例化的方式可能在我们平时的开发中用到的是最多的，因为在xml文件中配置简单并且也不需要额外的工厂类来实现。</p>
<p>默认无参构造方法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--applicationContext.xml配置：--&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"personService"</span> <span class="attr">class</span>=<span class="string">"cn.mytest.service.impl.PersonServiceBean"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果有参数，有多重参数匹配的方式</p>
<ol>
<li>按照参数的顺序和个数来注入</li>
<li>按照参数类型匹配注入</li>
<li>按照参数索引顺序注入</li>
<li>通过参数名称注入 Spring3以上</li>
<li>通过annotation注入<code>@ConstructorProperties</code>   Spring3以上</li>
<li>用简化的c namespace来进行构造函数注入  spring3.1以上</li>
</ol>
<h3 id="1-1、按照参数的顺序和个数来注入"><a href="#1-1、按照参数的顺序和个数来注入" class="headerlink" title="1.1、按照参数的顺序和个数来注入"></a>1.1、按照参数的顺序和个数来注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;  </div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">(Bar bar, Baz baz)</span> </span>&#123;  </div><div class="line">      <span class="comment">// ...  </span></div><div class="line">  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span>  </div><div class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"x.y.Foo"</span>&gt;</span>  </div><div class="line">      <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"bar"</span>/&gt;</span>  </div><div class="line">      <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"baz"</span>/&gt;</span>  </div><div class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </div><div class="line">  </div><div class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bar"</span> <span class="attr">class</span>=<span class="string">"x.y.Bar"</span>/&gt;</span>  </div><div class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baz"</span> <span class="attr">class</span>=<span class="string">"x.y.Baz"</span>/&gt;</span>  </div><div class="line">  </div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>下面几种注入方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;  </div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> years;  </div><div class="line">  <span class="keyword">private</span> String ultimateAnswer;    </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ExampleBean</span><span class="params">(<span class="keyword">int</span> years, String ultimateAnswer)</span> </span>&#123;  </div><div class="line">      <span class="keyword">this</span>.years = years;  </div><div class="line">      <span class="keyword">this</span>.ultimateAnswer = ultimateAnswer;  </div><div class="line">  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1-2、按照参数类型匹配注入"><a href="#1-2、按照参数类型匹配注入" class="headerlink" title="1.2、按照参数类型匹配注入"></a>1.2、按照参数类型匹配注入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>=<span class="string">"7500000"</span>/&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"42"</span>/&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="1-3、按照参数索引顺序注入"><a href="#1-3、按照参数索引顺序注入" class="headerlink" title="1.3、按照参数索引顺序注入"></a>1.3、按照参数索引顺序注入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"7500000"</span>/&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"42"</span>/&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="1-4、spring3以上还可以通过参数名称进行注入"><a href="#1-4、spring3以上还可以通过参数名称进行注入" class="headerlink" title="1.4、spring3以上还可以通过参数名称进行注入"></a>1.4、spring3以上还可以通过参数名称进行注入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"years"</span> <span class="attr">value</span>=<span class="string">"7500000"</span>/&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"ultimateanswer"</span> <span class="attr">value</span>=<span class="string">"42"</span>/&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="1-5、spring3以上通过annotation注入-ConstructorProperties"><a href="#1-5、spring3以上通过annotation注入-ConstructorProperties" class="headerlink" title="1.5、spring3以上通过annotation注入 @ConstructorProperties"></a>1.5、spring3以上通过annotation注入 <code>@ConstructorProperties</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> examples;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;  </div><div class="line">  <span class="meta">@ConstructorProperties</span>(&#123;<span class="string">"years"</span>, <span class="string">"ultimateAnswer"</span>&#125;)  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ExampleBean</span><span class="params">(<span class="keyword">int</span> years, String ultimateAnswer)</span> </span>&#123;  </div><div class="line">      <span class="keyword">this</span>.years = years;  </div><div class="line">      <span class="keyword">this</span>.ultimateAnswer = ultimateAnswer;  </div><div class="line">  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2、使用静态工厂方法实例化"><a href="#2、使用静态工厂方法实例化" class="headerlink" title="2、使用静态工厂方法实例化"></a>2、使用静态工厂方法实例化</h2><p>根据这个中实例化方法的名称就可以知道要想通过这种方式进行实例化就要具备两个条件：</p>
<ol>
<li>要有工厂类及其工厂方法</li>
<li>工厂方法是静态的</li>
</ol>
<p>首先创建工程类及其静态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cn.mytest.service.impl;  </div><div class="line">  </div><div class="line"><span class="comment">/** </span></div><div class="line">*创建工厂类 </div><div class="line">* </div><div class="line">*/  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceFactory</span> </span>&#123;  </div><div class="line">    <span class="comment">//创建静态方法  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PersonServiceBean <span class="title">createPersonServiceBean</span><span class="params">()</span></span>&#123;  </div><div class="line">         <span class="comment">//返回实例化的类的对象  </span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PersonServiceBean();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后再去配置spring配置文件，配置的方法和上面有点不同，这里也是关键所在</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--applicationContext.xml配置：--&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"personService1"</span> <span class="attr">class</span>=<span class="string">"cn.mytest.service.impl.PersonServiceFactory"</span> <span class="attr">factory-method</span>=<span class="string">"createPersonServiceBean"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="3、使用实例化工厂方法实例化"><a href="#3、使用实例化工厂方法实例化" class="headerlink" title="3、使用实例化工厂方法实例化"></a>3、使用实例化工厂方法实例化</h2><p>这个方法和上面的方法不同之处在与使用该实例化方式工厂方法不需要是静态的，但是在spring的配置文件中需要配置更多的内容</p>
<p>首先创建工厂类及工厂方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cn.mytest.service.impl;  </div><div class="line">  </div><div class="line"><span class="comment">/** </span></div><div class="line">*创建工厂类 </div><div class="line">*/  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceFactory</span> </span>&#123;  </div><div class="line">    <span class="comment">//创建静态方法  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> PersonServiceBean <span class="title">createPersonServiceBean1</span><span class="params">()</span></span>&#123;  </div><div class="line">         <span class="comment">//返回实例化的类的对象  </span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PersonServiceBean();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后再去配置spring配置文件，配置的方法和上面有点不同，这里也是关键所在</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--applicationContext.xml配置：--&gt;</span>  </div><div class="line">  </div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"personServiceFactory"</span> <span class="attr">class</span>=<span class="string">"cn.mytest.service.impl.PersonServiceFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </div><div class="line">  </div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"personService2"</span> <span class="attr">factory-bean</span>=<span class="string">"personServiceFactory"</span> <span class="attr">factory-method</span>=<span class="string">"createPersonServiceBean1"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这里需要配置两个bean，第一个bean使用的构造器方法实例化工厂类，第二个bean中的id是实例化对象的名称，factory-bean对应的被实例化的工厂类的对象名称，也就是第一个bean的id，factory-method是非静态工厂方法。</p>
<h1 id="四、参考地址"><a href="#四、参考地址" class="headerlink" title="四、参考地址"></a>四、参考地址</h1><p><a href="http://blessht.iteye.com/blog/1162131" target="_blank" rel="external">http://blessht.iteye.com/blog/1162131</a></p>
<p><a href="http://rooock.iteye.com/blog/338847" target="_blank" rel="external">http://rooock.iteye.com/blog/338847</a></p>
<p><a href="http://www.cnblogs.com/atwanli/articles/6154920.html" target="_blank" rel="external">http://www.cnblogs.com/atwanli/articles/6154920.html</a></p>
<p><a href="http://www.cnblogs.com/wcyBlog/p/3756624.html" target="_blank" rel="external">http://www.cnblogs.com/wcyBlog/p/3756624.html</a></p>
<p><a href="http://blog.csdn.net/dracotianlong/article/details/8989874" target="_blank" rel="external">http://blog.csdn.net/dracotianlong/article/details/8989874</a></p>
<p><a href="http://javatea.iteye.com/blog/1337706" target="_blank" rel="external">http://javatea.iteye.com/blog/1337706</a></p>
<p><a href="http://glzaction.iteye.com/blog/1286325" target="_blank" rel="external">http://glzaction.iteye.com/blog/1286325</a></p>
<p><a href="http://blog.csdn.net/zhongweijian/article/details/8482131" target="_blank" rel="external">http://blog.csdn.net/zhongweijian/article/details/8482131</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中XML的解析方式]]></title>
      <url>http://yoursite.com/2016/12/30/Java/Java%E4%B8%ADXML%E7%9A%84%E8%A7%A3%E6%9E%90%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>XML是一种通用的数据交换格式,它的平台无关性、语言无关性、系统无关性、给数据集成与交互带来了极大的方便。XML在不同的语言环境中解析方式都是一样的,只不过实现的语法不同而已。</p>
<p>XML的解析有四种方式：</p>
<ol>
<li>DOM解析</li>
<li>SAX解析</li>
<li>JDOM解析</li>
<li>DOM4J解析</li>
</ol>
<p>其中前两种属于基础方法，是官方提供的平台无关的解析方式；后两种属于扩展方法，它们是在基础的方法上扩展出来的，只适用于Java平台。</p>
<p>以一个xml文件为例</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">"1"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>冰与火之歌<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>乔治马丁<span class="tag">&lt;/<span class="name">author</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2014<span class="tag">&lt;/<span class="name">year</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>89<span class="tag">&lt;/<span class="name">price</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">"2"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>安徒生童话<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2004<span class="tag">&lt;/<span class="name">year</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>77<span class="tag">&lt;/<span class="name">price</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">language</span>&gt;</span>English<span class="tag">&lt;/<span class="name">language</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span>    </div><div class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></div></pre></td></tr></table></figure>
<h1 id="一、DOM解析"><a href="#一、DOM解析" class="headerlink" title="一、DOM解析"></a>一、DOM解析</h1><p>DOM的全称是Document Object Model，也即文档对象模型。</p>
<p>在应用程序中，基于DOM的XML分析器将一个XML文档转换成一个对象模型的集合（通常称DOM树），应用程序正是通过对这个对象模型的操作，来实现对XML文档数据的操作。通过DOM接口，应用程序可以在任何时候访问XML文档中的任何一部分数据，因此，这种利用DOM接口的机制也被称作随机访问机制。</p>
<ul>
<li>优点：<ol>
<li>形成了树结构，有助于更好的理解、掌握，且代码容易编写。</li>
<li>解析过程中，树结构保存在内存中，方便修改。</li>
</ol>
</li>
<li>缺点：<ol>
<li>由于文件是一次性读取，所以对内存的耗费比较大。</li>
<li>如果XML文件比较大，容易影响解析性能且可能会造成内存溢出。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilder;</div><div class="line"><span class="keyword">import</span> javax.xml.parsers.DocumentBuilderFactory;</div><div class="line"><span class="keyword">import</span> javax.xml.parsers.ParserConfigurationException;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.w3c.dom.Document;</div><div class="line"><span class="keyword">import</span> org.w3c.dom.NamedNodeMap;</div><div class="line"><span class="keyword">import</span> org.w3c.dom.Node;</div><div class="line"><span class="keyword">import</span> org.w3c.dom.NodeList;</div><div class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DOMTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            <span class="comment">//创建DocumentBuilder对象</span></div><div class="line">            DocumentBuilder db = dbf.newDocumentBuilder();</div><div class="line">          	<span class="comment">//通过DocumentBuilder对象的parser方法加载books.xml文件到当前项目下</span></div><div class="line">            Document document = db.parse(<span class="string">"books.xml"</span>);</div><div class="line">            <span class="comment">//获取所有book节点的集合</span></div><div class="line">            NodeList bookList = document.getElementsByTagName(<span class="string">"book"</span>);</div><div class="line">            <span class="comment">//通过nodelist的getLength()方法可以获取bookList的长度</span></div><div class="line">            System.out.println(<span class="string">"一共有"</span> + bookList.getLength() + <span class="string">"本书"</span>);</div><div class="line">            <span class="comment">//遍历每一个book节点</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bookList.getLength(); i++) &#123;</div><div class="line">                System.out.println(<span class="string">"=================下面开始遍历第"</span> + (i + <span class="number">1</span>) + <span class="string">"本书的内容================="</span>);</div><div class="line">                <span class="comment">//通过 item(i)方法 获取一个book节点，nodelist的索引值从0开始</span></div><div class="line">                Node book = bookList.item(i);</div><div class="line">                <span class="comment">//获取book节点的所有属性集合</span></div><div class="line">                NamedNodeMap attrs = book.getAttributes();</div><div class="line">                System.out.println(<span class="string">"第 "</span> + (i + <span class="number">1</span>) + <span class="string">"本书共有"</span> + attrs.getLength() + <span class="string">"个属性"</span>);</div><div class="line">                <span class="comment">//遍历book的属性</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; attrs.getLength(); j++) &#123;</div><div class="line">                    <span class="comment">//通过item(index)方法获取book节点的某一个属性</span></div><div class="line">                    Node attr = attrs.item(j);</div><div class="line">                    <span class="comment">//获取属性名</span></div><div class="line">                    System.out.print(<span class="string">"属性名："</span> + attr.getNodeName());</div><div class="line">                    <span class="comment">//获取属性值</span></div><div class="line">                    System.out.println(<span class="string">"--属性值"</span> + attr.getNodeValue());</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//解析book节点的子节点</span></div><div class="line">                NodeList childNodes = book.getChildNodes();</div><div class="line">                <span class="comment">//遍历childNodes获取每个节点的节点名和节点值</span></div><div class="line">                System.out.println(<span class="string">"第"</span> + (i+<span class="number">1</span>) + <span class="string">"本书共有"</span> + </div><div class="line">                childNodes.getLength() + <span class="string">"个子节点"</span>);</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; childNodes.getLength(); k++) &#123;</div><div class="line">                    <span class="comment">//区分出text类型的node以及element类型的node</span></div><div class="line">                    <span class="keyword">if</span> (childNodes.item(k).getNodeType() == Node.ELEMENT_NODE) &#123;</div><div class="line">                        <span class="comment">//获取了element类型节点的节点名</span></div><div class="line">                        System.out.print(<span class="string">"第"</span> + (k + <span class="number">1</span>) + <span class="string">"个节点的节点名："</span> </div><div class="line">                        + childNodes.item(k).getNodeName());</div><div class="line">                        <span class="comment">//获取了element类型节点的节点值</span></div><div class="line">                        System.out.println(<span class="string">"--节点值是："</span> + childNodes.item(k).getFirstChild().getNodeValue());</div><div class="line">                        <span class="comment">//System.out.println("--节点值是：" + childNodes.item(k).getTextContent());</span></div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                System.out.println(<span class="string">"======================结束遍历第"</span> + (i + <span class="number">1</span>) + <span class="string">"本书的内容================="</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">catch</span> (ParserConfigurationException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (SAXException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;  </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DOM树所提供的随机访问方式给应用程序的开发带来了很大的灵活性，它可以任意地控制整个XML文档中的内容。然而，由于DOM分析器把整个XML文档转化成DOM树放在了内存中，因此，当文档比较大或者结构比较复杂时，对内存的需求就比较高。而且，对于结构复杂的树的遍历也是一项耗时的操作。所以，DOM分析器对机器性能的要求比较高，实现效率不十分理想。不过，由于DOM分析器所采用的树结构的思想与XML文档的结构相吻合，同时鉴于随机访问所带来的方便，因此，DOM分析器还是有很广泛的使用价值的。</p>
<h1 id="二、SAX解析"><a href="#二、SAX解析" class="headerlink" title="二、SAX解析"></a>二、SAX解析</h1><p>SAX的全称是Simple APIs for XML，也即XML简单应用程序接口。与DOM不同，SAX提供的访问模式是一种顺序模式，这是一种快速读写XML数据的方式。当使用SAX分析器对XML文档进行分析时，会触发一系列事件，并激活相应的事件处理函数，应用程序通过这些事件处理函数实现对XML文档的访问，因而SAX接口也被称作<strong>事件驱动接口</strong>。</p>
<ul>
<li>优点<ol>
<li>采用事件驱动模式，对内存耗费比较小。</li>
<li>适用于只处理XML文件中的数据</li>
</ol>
</li>
<li>缺点<ol>
<li>编码比较麻烦</li>
<li>很难同时访问XML文件中的多处不同数据</li>
</ol>
</li>
</ul>
<p>SAX不用将整个文档加载到内存，基于事件驱动的API(Observer模式)，用户只需要注册自己感兴趣的事件即可。SAX提供EntityResolver, DTDHandler, ContentHandler, ErrorHandler接口，分别用于监听解析实体事件、DTD处理事件、正文处理事件和处理出错事件，与AWT类似，SAX还提供了一个对这4个接口默认的类DefaultHandler（这里的默认实现，其实就是一个空方法），一般只要继承DefaultHandler，重写自己感兴趣的事件即可。<br>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.xml.parsers.ParserConfigurationException;</div><div class="line"><span class="keyword">import</span> javax.xml.parsers.SAXParser;</div><div class="line"><span class="keyword">import</span> javax.xml.parsers.SAXParserFactory;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.xml.sax.Attributes;</div><div class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</div><div class="line"><span class="keyword">import</span> org.xml.sax.helpers.DefaultHandler;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SAXTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;</div><div class="line">        String id;</div><div class="line">        String name;</div><div class="line">        String author;</div><div class="line">        String price;</div><div class="line">        String language;</div><div class="line">        String year;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> id;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.id = id;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> name;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getAuthor</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> author;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthor</span><span class="params">(String author)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.author = author;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> price;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(String price)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.price = price;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getLanguage</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> language;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLanguage</span><span class="params">(String language)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.language = language;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getYear</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> year;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setYear</span><span class="params">(String year)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.year = year;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 重写对自己感兴趣的事件处理方法   </span></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SAXParserHandler</span> <span class="keyword">extends</span> <span class="title">DefaultHandler</span> </span>&#123;</div><div class="line">        String value = <span class="keyword">null</span>;</div><div class="line">        Book book = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">private</span> ArrayList&lt;Book&gt; bookList = <span class="keyword">new</span> ArrayList&lt;Book&gt;();</div><div class="line">        <span class="function"><span class="keyword">public</span> ArrayList&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> bookList;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> bookIndex = <span class="number">0</span>;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 用来标识解析开始</div><div class="line">         */</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDocument</span><span class="params">()</span> <span class="keyword">throws</span> SAXException </span>&#123;</div><div class="line">            <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">            <span class="keyword">super</span>.startDocument();</div><div class="line">            System.out.println(<span class="string">"SAX解析开始"</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 用来标识解析结束</div><div class="line">         */</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endDocument</span><span class="params">()</span> <span class="keyword">throws</span> SAXException </span>&#123;</div><div class="line">            <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">            <span class="keyword">super</span>.endDocument();</div><div class="line">            System.out.println(<span class="string">"SAX解析结束"</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 解析xml元素</div><div class="line">         */</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startElement</span><span class="params">(String uri, String localName, String qName,</span></span></div><div class="line">                Attributes attributes) <span class="keyword">throws</span> SAXException &#123;</div><div class="line">            <span class="comment">//调用DefaultHandler类的startElement方法</span></div><div class="line">            <span class="keyword">super</span>.startElement(uri, localName, qName, attributes);</div><div class="line">            <span class="keyword">if</span> (qName.equals(<span class="string">"book"</span>)) &#123;</div><div class="line">                bookIndex++;</div><div class="line">                <span class="comment">//创建一个book对象</span></div><div class="line">                book = <span class="keyword">new</span> Book();</div><div class="line">                <span class="comment">//开始解析book元素的属性</span></div><div class="line">                System.out.println(<span class="string">"======================开始遍历某一本书的内容================="</span>);</div><div class="line">                <span class="comment">//不知道book元素下属性的名称以及个数，如何获取属性名以及属性值</span></div><div class="line">                <span class="keyword">int</span> num = attributes.getLength();</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</div><div class="line">                    System.out.print(<span class="string">"book元素的第"</span> + (i + <span class="number">1</span>) +  <span class="string">"个属性名是："</span></div><div class="line">                            + attributes.getQName(i));</div><div class="line">                    System.out.println(<span class="string">"---属性值是："</span> + attributes.getValue(i));</div><div class="line">                    <span class="keyword">if</span> (attributes.getQName(i).equals(<span class="string">"id"</span>)) &#123;</div><div class="line">                        book.setId(attributes.getValue(i));</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!qName.equals(<span class="string">"name"</span>) &amp;&amp; !qName.equals(<span class="string">"bookstore"</span>)) &#123;</div><div class="line">                System.out.print(<span class="string">"节点名是："</span> + qName + <span class="string">"---"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endElement</span><span class="params">(String uri, String localName, String qName)</span></span></div><div class="line">                <span class="keyword">throws</span> SAXException &#123;</div><div class="line">            <span class="comment">//调用DefaultHandler类的endElement方法</span></div><div class="line">            <span class="keyword">super</span>.endElement(uri, localName, qName);</div><div class="line">            <span class="comment">//判断是否针对一本书已经遍历结束</span></div><div class="line">            <span class="keyword">if</span> (qName.equals(<span class="string">"book"</span>)) &#123;</div><div class="line">                bookList.add(book);</div><div class="line">                book = <span class="keyword">null</span>;</div><div class="line">                System.out.println(<span class="string">"======================结束遍历某一本书的内容================="</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (qName.equals(<span class="string">"name"</span>)) &#123;</div><div class="line">                book.setName(value);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (qName.equals(<span class="string">"author"</span>)) &#123;</div><div class="line">                book.setAuthor(value);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (qName.equals(<span class="string">"year"</span>)) &#123;</div><div class="line">                book.setYear(value);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (qName.equals(<span class="string">"price"</span>)) &#123;</div><div class="line">                book.setPrice(value);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (qName.equals(<span class="string">"language"</span>)) &#123;</div><div class="line">                book.setLanguage(value);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">characters</span><span class="params">(<span class="keyword">char</span>[] ch, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span></span></div><div class="line">                <span class="keyword">throws</span> SAXException &#123;</div><div class="line">            <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">            <span class="keyword">super</span>.characters(ch, start, length);</div><div class="line">            value = <span class="keyword">new</span> String(ch, start, length);</div><div class="line">            <span class="keyword">if</span> (!value.trim().equals(<span class="string">""</span>)) &#123;</div><div class="line">                System.out.println(<span class="string">"节点值是："</span> + value);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SAXParserFactory factory = SAXParserFactory.newInstance();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//创建SAXParserHandler对象</span></div><div class="line">            SAXParser parser = factory.newSAXParser();</div><div class="line">            <span class="comment">//创建SAXParserHandler对象</span></div><div class="line">            SAXParserHandler handler = <span class="keyword">new</span> SAXParserHandler();</div><div class="line">            parser.parse(<span class="string">"books.xml"</span>, handler);</div><div class="line">            System.out.println(<span class="string">"~！~！~！共有"</span> + handler.getBookList().size()</div><div class="line">                    + <span class="string">"本书"</span>);</div><div class="line">            <span class="keyword">for</span> (Book book : handler.getBookList()) &#123;</div><div class="line">                System.out.println(book.getId());</div><div class="line">                System.out.println(book.getName());</div><div class="line">                System.out.println(book.getAuthor());</div><div class="line">                System.out.println(book.getYear());</div><div class="line">                System.out.println(book.getPrice());</div><div class="line">                System.out.println(book.getLanguage());</div><div class="line">                System.out.println(<span class="string">"----finish----"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (ParserConfigurationException e) &#123;</div><div class="line">            <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (SAXException e) &#123;</div><div class="line">            <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="三、JDOM解析"><a href="#三、JDOM解析" class="headerlink" title="三、JDOM解析"></a>三、JDOM解析</h1><p>JDOM与DOM非常类似，它是处理XML的纯JAVA API，API大量使用了Collections类，且JDOM仅使用具体类而不使用接口。　JDOM 它自身不包含解析器。它通常使用 SAX2 解析器来解析和验证输入 XML 文档（尽管它还可以将以前构造的 DOM 表示作为输入）。它包含一些转换器以将 JDOM 表示输出成 SAX2 事件流、DOM 模型或 XML 文本文档</p>
<p>特点</p>
<ol>
<li>使用具体类，而不是接口，使用时必须下载jar包</li>
<li>API大量使用了Collections类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.InputStream;</div><div class="line"><span class="keyword">import</span> java.io.InputStreamReader;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.jdom2.Attribute;</div><div class="line"><span class="keyword">import</span> org.jdom2.Document;</div><div class="line"><span class="keyword">import</span> org.jdom2.Element;</div><div class="line"><span class="keyword">import</span> org.jdom2.JDOMException;</div><div class="line"><span class="keyword">import</span> org.jdom2.input.SAXBuilder;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDOMTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Book&gt; booksList = <span class="keyword">new</span> ArrayList&lt;Book&gt;();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 进行对books.xml文件的JDOM解析</span></div><div class="line">        <span class="comment">// 准备工作</span></div><div class="line">        <span class="comment">// 1.创建一个SAXBuilder的对象</span></div><div class="line">        SAXBuilder saxBuilder = <span class="keyword">new</span> SAXBuilder();</div><div class="line">        InputStream in;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 2.创建一个输入流，将xml文件加载到输入流中</span></div><div class="line">            in = <span class="keyword">new</span> FileInputStream(<span class="string">"books.xml"</span>);</div><div class="line">            InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(in, <span class="string">"UTF-8"</span>);</div><div class="line">            <span class="comment">// 3.通过saxBuilder的build方法，将输入流加载到saxBuilder中</span></div><div class="line">            Document document = saxBuilder.build(isr);</div><div class="line">            <span class="comment">// 4.通过document对象获取xml文件的根节点</span></div><div class="line">            Element rootElement = document.getRootElement();</div><div class="line">            <span class="comment">// 5.获取根节点下的子节点的List集合</span></div><div class="line">            List&lt;Element&gt; bookList = rootElement.getChildren();</div><div class="line">            <span class="comment">// 继续进行解析</span></div><div class="line">            <span class="keyword">for</span> (Element book : bookList) &#123;</div><div class="line">                Book bookEntity = <span class="keyword">new</span> Book();</div><div class="line">                System.out.println(<span class="string">"======开始解析第"</span> + (bookList.indexOf(book) + <span class="number">1</span>)</div><div class="line">                        + <span class="string">"书======"</span>);</div><div class="line">                <span class="comment">// 解析book的属性集合</span></div><div class="line">                List&lt;Attribute&gt; attrList = book.getAttributes();</div><div class="line">                <span class="comment">// //知道节点下属性名称时，获取节点值</span></div><div class="line">                <span class="comment">// book.getAttributeValue("id");</span></div><div class="line">                <span class="comment">// 遍历attrList(针对不清楚book节点下属性的名字及数量)</span></div><div class="line">                <span class="keyword">for</span> (Attribute attr : attrList) &#123;</div><div class="line">                    <span class="comment">// 获取属性名</span></div><div class="line">                    String attrName = attr.getName();</div><div class="line">                    <span class="comment">// 获取属性值</span></div><div class="line">                    String attrValue = attr.getValue();</div><div class="line">                    System.out.println(<span class="string">"属性名："</span> + attrName + <span class="string">"----属性值："</span></div><div class="line">                            + attrValue);</div><div class="line">                    <span class="keyword">if</span> (attrName.equals(<span class="string">"id"</span>)) &#123;</div><div class="line">                        bookEntity.setId(attrValue);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 对book节点的子节点的节点名以及节点值的遍历</span></div><div class="line">                List&lt;Element&gt; bookChilds = book.getChildren();</div><div class="line">                <span class="keyword">for</span> (Element child : bookChilds) &#123;</div><div class="line">                    System.out.println(<span class="string">"节点名："</span> + child.getName() + <span class="string">"----节点值："</span></div><div class="line">                            + child.getValue());</div><div class="line">                    <span class="keyword">if</span> (child.getName().equals(<span class="string">"name"</span>)) &#123;</div><div class="line">                        bookEntity.setName(child.getValue());</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (child.getName().equals(<span class="string">"author"</span>)) &#123;</div><div class="line">                        bookEntity.setAuthor(child.getValue());</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (child.getName().equals(<span class="string">"year"</span>)) &#123;</div><div class="line">                        bookEntity.setYear(child.getValue());</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (child.getName().equals(<span class="string">"price"</span>)) &#123;</div><div class="line">                        bookEntity.setPrice(child.getValue());</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (child.getName().equals(<span class="string">"language"</span>)) &#123;</div><div class="line">                        bookEntity.setLanguage(child.getValue());</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                System.out.println(<span class="string">"======结束解析第"</span> + (bookList.indexOf(book) + <span class="number">1</span>)</div><div class="line">                        + <span class="string">"书======"</span>);</div><div class="line">                booksList.add(bookEntity);</div><div class="line">                bookEntity = <span class="keyword">null</span>;</div><div class="line">                System.out.println(booksList.size());</div><div class="line">                System.out.println(booksList.get(<span class="number">0</span>).getId());</div><div class="line">                System.out.println(booksList.get(<span class="number">0</span>).getName());</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (JDOMException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="四、DOM4J解析"><a href="#四、DOM4J解析" class="headerlink" title="四、DOM4J解析"></a>四、DOM4J解析</h1><p>dom4j是目前在xml解析方面是最优秀的(Hibernate、Sun的JAXM也都使用dom4j来解析XML)，它合并了许多超出基本 XML 文档表示的功能，包括集成的 XPath 支持、XML Schema 支持以及用于大文档或流化文档的基于事件的处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.dom4j.Attribute;</div><div class="line"><span class="keyword">import</span> org.dom4j.Document;</div><div class="line"><span class="keyword">import</span> org.dom4j.DocumentException;</div><div class="line"><span class="keyword">import</span> org.dom4j.Element;</div><div class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DOM4JTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Book&gt; bookList = <span class="keyword">new</span> ArrayList&lt;Book&gt;();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 解析books.xml文件</span></div><div class="line">        <span class="comment">// 创建SAXReader的对象reader</span></div><div class="line">        SAXReader reader = <span class="keyword">new</span> SAXReader();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 通过reader对象的read方法加载books.xml文件,获取docuemnt对象。</span></div><div class="line">            Document document = reader.read(<span class="keyword">new</span> File(<span class="string">"books.xml"</span>));</div><div class="line">            <span class="comment">// 通过document对象获取根节点bookstore</span></div><div class="line">            Element bookStore = document.getRootElement();</div><div class="line">            <span class="comment">// 通过element对象的elementIterator方法获取迭代器</span></div><div class="line">            Iterator it = bookStore.elementIterator();</div><div class="line">            </div><div class="line">            </div><div class="line">            <span class="comment">// 遍历迭代器，获取根节点中的信息（书籍）</span></div><div class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">                System.out.println(<span class="string">"=====开始遍历某一本书====="</span>);</div><div class="line">                Element book = (Element) it.next();</div><div class="line">                <span class="comment">// 获取book的属性名以及 属性值</span></div><div class="line">                List&lt;Attribute&gt; bookAttrs = book.attributes();</div><div class="line">                <span class="keyword">for</span> (Attribute attr : bookAttrs) &#123;</div><div class="line">                    System.out.println(<span class="string">"属性名："</span> + attr.getName() + <span class="string">"--属性值："</span></div><div class="line">                            + attr.getValue());</div><div class="line">                &#125;</div><div class="line">                Iterator itt = book.elementIterator();</div><div class="line">                <span class="keyword">while</span> (itt.hasNext()) &#123;</div><div class="line">                    Element bookChild = (Element) itt.next();</div><div class="line">                    System.out.println(<span class="string">"节点名："</span> + bookChild.getName() + <span class="string">"--节点值："</span> + bookChild.getStringValue());</div><div class="line">                &#125;</div><div class="line">                System.out.println(<span class="string">"=====结束遍历某一本书====="</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (DocumentException e) &#123;</div><div class="line">            <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>在学习Spring的时候还看见一种解析方法叫jaxp，这些概念容易混淆，所以一定要明白他们之间的关系。</p>
<p>首先，SAX和DOM一个是两种XML文件解析的机制，它们是在JAVA中定义的接口</p>
<p>而JAXP、JDOM和DOM4J都是基于这两大核心API衍生出来的。</p>
<h2 id="1、SAX与DOM"><a href="#1、SAX与DOM" class="headerlink" title="1、SAX与DOM"></a>1、SAX与DOM</h2><p>SAX与DOM都是底层API，它们在JDK中的路径分别是org.xml.sax与org.w3c.dom。</p>
<p>它们两个主要就是两种不同的解析方式，并没有具体的实现类。如果光有他们，你是完成不了对xml文档的处理的</p>
<h2 id="2、JAXP"><a href="#2、JAXP" class="headerlink" title="2、JAXP"></a>2、JAXP</h2><p>JAXP:(Java API for XML Processing)开发包是JavaSE的一部分，它由以下几个包及其子包组成：</p>
<ul>
<li>org.w3c.dom:提供DOM方式解析XML的标准接口</li>
<li>org.xml.sax:提供SAX方式解析XML的标准接口</li>
<li>javax.xml:提供了解析XML文档的类</li>
</ul>
<p>我理解的，它是Java中自带的一个实现类，DOM或SAX都可以通过这个包来实现。比如最上面两个DOM和SAX的解析例子中，都用到了javax.xml包中的实现类。</p>
<h2 id="3、JDOM与DOM4J"><a href="#3、JDOM与DOM4J" class="headerlink" title="3、JDOM与DOM4J"></a>3、JDOM与DOM4J</h2><p>这两个包在使用的时候需要导入JAR包，说明是其他人开发出来的，也实现了SAX和DOM两种接口。</p>
<h1 id="六、参考地址"><a href="#六、参考地址" class="headerlink" title="六、参考地址"></a>六、参考地址</h1><p><a href="http://www.cnblogs.com/longqingyang/p/5577937.html" target="_blank" rel="external">http://www.cnblogs.com/longqingyang/p/5577937.html</a></p>
<p><a href="http://www.cnblogs.com/cayman/p/5529301.html" target="_blank" rel="external">http://www.cnblogs.com/cayman/p/5529301.html</a></p>
<p><a href="http://www.tuicool.com/articles/zUVNV3" target="_blank" rel="external">http://www.tuicool.com/articles/zUVNV3</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring源码分析（一）：IOC容器的初始化过程]]></title>
      <url>http://yoursite.com/2016/12/29/spring/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(1)IOC%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>Spring的容器就是bean容器也是IOC容器，它的初始化过程非常复杂，设计到复杂的类继承关系，在此简单分析一下关键的类和步骤。</p>
<h1 id="一、核心数据结构"><a href="#一、核心数据结构" class="headerlink" title="一、核心数据结构"></a>一、核心数据结构</h1><h2 id="1、Resource"><a href="#1、Resource" class="headerlink" title="1、Resource"></a>1、Resource</h2><p>在Spring内部，针对于资源文件有一个统一的接口Resource表示。其主要实现类有ClassPathResource、FileSystemResource、UrlResource、ByteArrayResource、ServletContextResource和InputStreamResource。Resource接口中主要定义有以下方法：</p>
<ul>
<li>exists()：用于判断对应的资源是否真的存在。</li>
<li>isReadable()：用于判断对应资源的内容是否可读。需要注意的是当其结果为true的时候，其内容未必真的可读，但如果返回false，则其内容必定不可读。</li>
<li>isOpen()：用于判断当前资源是否代表一个已打开的输入流，如果结果为true，则表示当前资源的输入流不可多次读取，而且在读取以后需要对它进行关闭，以防止内存泄露。该方法主要针对于InputStreamResource，实现类中只有它的返回结果为true，其他都为false。</li>
<li>getURL()：返回当前资源对应的URL。如果当前资源不能解析为一个URL则会抛出异常。如ByteArrayResource就不能解析为一个URL。</li>
<li>getFile()：返回当前资源对应的File。如果当前资源不能以绝对路径解析为一个File则会抛出异常。如ByteArrayResource就不能解析为一个File。</li>
<li><strong>getInputStream()：获取当前资源代表的输入流。除了InputStreamResource以外，其它Resource实现类每次调用getInputStream()方法都将返回一个全新的InputStream。</strong> </li>
</ul>
<p>实现类：</p>
<ul>
<li><strong>ClassPathResource</strong>可用来获取类路径下的资源文件。假设我们有一个资源文件test.txt在类路径下，我们就可以通过给定对应资源文件在类路径下的路径path来获取它，new ClassPathResource(“test.txt”)。</li>
<li><strong>FileSystemResource</strong>可用来获取文件系统里面的资源。我们可以通过对应资源文件的文件路径来构建一个FileSystemResource。FileSystemResource还可以往对应的资源文件里面写内容，当然前提是当前资源文件是可写的，这可以通过其isWritable()方法来判断。FileSystemResource对外开放了对应资源文件的输出流，可以通过getOutputStream()方法获取到。</li>
<li><strong>UrlResource</strong>可用来代表URL对应的资源，它对URL做了一个简单的封装。通过给定一个URL地址，我们就能构建一个UrlResource。</li>
<li><strong>ByteArrayResource</strong>是针对于字节数组封装的资源，它的构建需要一个字节数组。</li>
<li><strong>ServletContextResource</strong>是针对于ServletContext封装的资源，用于访问ServletContext环境下的资源。ServletContextResource持有一个ServletContext的引用，其底层是通过ServletContext的getResource()方法和getResourceAsStream()方法来获取资源的。</li>
<li><strong>InputStreamResource</strong>是针对于输入流封装的资源，它的构建需要一个输入流。</li>
</ul>
<h2 id="2、ResourceLoader"><a href="#2、ResourceLoader" class="headerlink" title="2、ResourceLoader"></a>2、ResourceLoader</h2><p>通过上面介绍的Resource接口的实现类，我们就可以使用它们各自的构造函数创建符合需求的Resource实例。但是在Spring中提供了ResourceLoader接口，用于实现不同的Resource加载策略，即将不同Resource实例的创建交给ResourceLoader来加载，这也是ApplicationContext等高级容器中使用的策略。</p>
<p>接口中有两个主要的方法：</p>
<ul>
<li>getResource()：在ResourceLoader接口中，主要定义了一个方法：getResource()，它通过提供的资源location参数获取Resource实例，该实例可以是ClasPathResource、FileSystemResource、UrlResource等，但是该方法返回的Resource实例并不保证该Resource一定是存在的，需要调用exists方法判断。</li>
<li>getResourceByPath：这个方法被声明为protected，所以在它的子类中基本都重写了这个方法。</li>
</ul>
<h3 id="2-1、实现类"><a href="#2-1、实现类" class="headerlink" title="2.1、实现类"></a>2.1、实现类</h3><p>DefaultResourceLoader是ResourceLoader的默认实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</div><div class="line">        Assert.notNull(location, <span class="string">"Location must not be null"</span>);</div><div class="line">        <span class="keyword">if</span> (location.startsWith(<span class="string">"/"</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> getResourceByPath(location);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//处理带有classPath标识的Resource</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//处理URL资源</span></div><div class="line">                URL url = <span class="keyword">new</span> URL(location);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> UrlResource(url);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">catch</span> (MalformedURLException ex) &#123;</div><div class="line">                <span class="keyword">return</span> getResourceByPath(location);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>其最主要的逻辑实现在getResource方法中：</p>
<ul>
<li>该方法首先判断传入的location是否以”classpath:”开头，如果是，则创建ClassPathResource（移除”classpath:”前缀）</li>
<li>否则尝试创建UrlResource</li>
<li>如果当前location没有定义URL的协议（即以”file:”、”zip:”等开头，比如使用相对路径”resources/META-INF/MENIFEST.MF），则创建UrlResource会抛出MalformedURLException，此时调用getResourceByPath()方法获取Resource实例</li>
<li>getResourceByPath()方法默认返回ClassPathContextResource实例，在FileSystemResourceLoader中有不同实现。</li>
</ul>
<p>它有一个重要的子类就是AbstractApplicationContext，因为后面要介绍的ApplicationContext的几个实现类都继承自它，也就是说，比如FileSystemXMLApplicationContext这个类因为继承自DefaultResourceLoader，所以具备了它的getResource方法，在最后定位资源的时候都调用了这个方法来获取Resource。</p>
<h2 id="3、BeanDefinition"><a href="#3、BeanDefinition" class="headerlink" title="3、BeanDefinition"></a>3、BeanDefinition</h2><p>一个BeanDefinition描述了一个bean的实例，包括属性值，构造方法参数值和继承自它的类的更多信息。</p>
<p>作用：持有bean数据结构，是注入的bean在IoC容器中的抽象，方法列表如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">getBeanClassName;  </div><div class="line">getFactoryBeanName;  </div><div class="line">getScope;  </div><div class="line">isLazyInit;  </div><div class="line">isSingleton;  </div><div class="line">isPrototype;  </div><div class="line">isAbstract;  </div><div class="line">isPrimary;  </div><div class="line">isAutowireCandidate;  </div><div class="line">getDescription;</div></pre></td></tr></table></figure>
<p>相关的类与接口：</p>
<ul>
<li>AbstractBeanDefinition：是BeanDefinition的一个完整实现</li>
<li>BeanDefinitionReader：用于读取bean的信息的接口。AbstractBeanDefinitionReader实现了该接口，XmlBeanDefinitionReader继承了AbstractBeanDefinitionReader。</li>
</ul>
<h2 id="4、ApplicationContext"><a href="#4、ApplicationContext" class="headerlink" title="4、ApplicationContext"></a>4、ApplicationContext</h2><p>高级IoC容器，除了基本的IoC容器功能外，支持不同信息源、访问资源、支持事件发布等功能。</p>
<p>继承了以下接口：</p>
<ul>
<li>ListableBeanFactory：继承自BeanFactory，在此基础上，添加了containsBeanDefinition、getBeanDefinitionCount、getBeanDefinitionNames等方法。</li>
<li>HierarchicalBeanFactory：继承自BeanFactory，在此基础之上，添加了getParentBeanFactory、containsLocalBean这两个方法。</li>
<li>AutoWireCapableBeanFactory：继承自BeanFactory</li>
<li>MessageSource：用于获取国际化信息</li>
<li>ApplicationEventPublisher：因为ApplicationContext实现了该接口，因此spring的ApplicationContext实例具有发布事件的功能。</li>
</ul>
<h1 id="二、容器的初始化过程"><a href="#二、容器的初始化过程" class="headerlink" title="二、容器的初始化过程"></a>二、容器的初始化过程</h1><p>IOC容器的初始化过程就是含有BeanDefinition的信息的Resource的定位、载入、解析、注册的四个过程，最终配置的bean以BeanDefinition的数据与结构存在于IOC容器之中，这个过程不涉及bean的依赖注入，也不产生任何bean。</p>
<p>以FileSystemXmlApplicationContext为例分析一下它的初始化过程。</p>
<p>先看一下它的类继承关系</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/spring/7.png?raw=true" alt=""></p>
<h2 id="1、Resource的定位过程"><a href="#1、Resource的定位过程" class="headerlink" title="1、Resource的定位过程"></a>1、Resource的定位过程</h2><h3 id="1-1、FileSystemXmlApplicationContext-类"><a href="#1-1、FileSystemXmlApplicationContext-类" class="headerlink" title="1.1、FileSystemXmlApplicationContext 类"></a>1.1、FileSystemXmlApplicationContext 类</h3><p>一般当构造的时候调用使用new来创建实例，配置文件的的地址作为参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ApplicationContext ctx1=<span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"c:/bean.xml"</span>);</div></pre></td></tr></table></figure>
<p>先来看一下最下面的实现类FileSystemXmlApplicationContext源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.context.support;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</div><div class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</div><div class="line"><span class="keyword">import</span> org.springframework.core.io.FileSystemResource;</div><div class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractXmlApplicationContext</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemXmlApplicationContext</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemXmlApplicationContext</span><span class="params">(ApplicationContext parent)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(parent);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemXmlApplicationContext</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> String[] &#123;configLocation&#125;, <span class="keyword">true</span>, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemXmlApplicationContext</span><span class="params">(String... configLocations)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="keyword">this</span>(configLocations, <span class="keyword">true</span>, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemXmlApplicationContext</span><span class="params">(String[] configLocations, ApplicationContext parent)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="keyword">this</span>(configLocations, <span class="keyword">true</span>, parent);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="keyword">this</span>(configLocations, refresh, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">  	<span class="comment">//核心构造器</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, ApplicationContext parent)</span></span></div><div class="line">            <span class="keyword">throws</span> BeansException &#123;</div><div class="line"></div><div class="line">        <span class="keyword">super</span>(parent);</div><div class="line">        setConfigLocations(configLocations);</div><div class="line">        <span class="keyword">if</span> (refresh) &#123;</div><div class="line">            refresh();<span class="comment">//Ioc容器的refresh()过程，是个非常复杂的过程，但不同的容器实现这里都是相似的，因此基类中就将他们封装好了</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//通过构造一个FileSystemResource对象来得到一个在文件系统中定位的BeanDefinition</span></div><div class="line">    <span class="comment">//采用模板方法设计模式，具体的实现用子类来完成</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Resource <span class="title">getResourceByPath</span><span class="params">(String path)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (path != <span class="keyword">null</span> &amp;&amp; path.startsWith(<span class="string">"/"</span>)) &#123;</div><div class="line">            path = path.substring(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FileSystemResource(path);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有三部分</p>
<ul>
<li>继承自AbstractXmlApplicationContext，而它最终的父类是DefaultResourceLoader，所以它具备了Resource定义的BeanDefinition的能力</li>
<li>调用refresh方法，这个方法在父类AbstractApplicationContext中已经封装好了。它详细描述了整个ApplicationContext的初始化过程，比如BeanFactory的更新、MessageSource和PostProcessor的注册等。这里看起来像是对ApplicationContext进行初始化的模版或执行提纲，这个执行过程为Bean的生命周期管理提供了条件。</li>
</ul>
<ul>
<li>重写了getResourceByPath方法，该方法是一个模版方法，通过构造一个FileSystemResource对象来得到一个在文件系统中定位的BeanDefinition。</li>
</ul>
<p>它的调用关系</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/spring/8.png?raw=true" alt=""></p>
<p>refresh为初始化IoC容器的入口，但是具体的资源定位还是在XmlBeanDefinitionReader读入BeanDefinition时完成，loadBeanDefinitions() 加载BeanDefinition的载入。</p>
<h3 id="1-2、AbstractRefreshableApplicationContext"><a href="#1-2、AbstractRefreshableApplicationContext" class="headerlink" title="1.2、AbstractRefreshableApplicationContext"></a>1.2、AbstractRefreshableApplicationContext</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="comment">//判断是否已经创建了BeanFactory，如果创建了则销毁关闭该BeanFactory</span></div><div class="line">        <span class="keyword">if</span> (hasBeanFactory()) &#123;</div><div class="line">            destroyBeans();</div><div class="line">            closeBeanFactory();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//创建DefaultListableBeanFactory实例对象</span></div><div class="line">            DefaultListableBeanFactory beanFactory = createBeanFactory();</div><div class="line">            beanFactory.setSerializationId(getId());</div><div class="line">            customizeBeanFactory(beanFactory);</div><div class="line">            <span class="comment">//加载BeanDefinition信息</span></div><div class="line">            loadBeanDefinitions(beanFactory);</div><div class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</div><div class="line">                <span class="keyword">this</span>.beanFactory = beanFactory;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span></span></div><div class="line">            <span class="keyword">throws</span> BeansException, IOException;</div></pre></td></tr></table></figure>
<p>通过loadBeanDefinitions(beanFactory);加载BeanDefinition信息，BeanDefinition就是在这里定义的。</p>
<p>AbstractRefreshableApplicationContext对loadBeanDefinitions仅仅只是定义了一个抽象的方法，真正的实现是在子类AbstractXmlApplicationContext中的。</p>
<h3 id="1-3、AbstractXmlApplicationContext"><a href="#1-3、AbstractXmlApplicationContext" class="headerlink" title="1.3、AbstractXmlApplicationContext"></a>1.3、AbstractXmlApplicationContext</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</div><div class="line">        <span class="comment">//创建bean的读取器(Reader)，即XmlBeanDefinitionReader,并通过回调设置到容器中</span></div><div class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</div><div class="line"></div><div class="line">        beanDefinitionReader.setEnvironment(getEnvironment());</div><div class="line">        <span class="comment">//为Bean读取器设置Spring资源加载器</span></div><div class="line">        beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</div><div class="line">        <span class="comment">//为Bean读取器设置xml解析器</span></div><div class="line">        beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</div><div class="line"></div><div class="line">        initBeanDefinitionReader(beanDefinitionReader);</div><div class="line">        <span class="comment">//Bean读取器真正实现的地方</span></div><div class="line">        loadBeanDefinitions(beanDefinitionReader);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</div><div class="line">        <span class="comment">//获取Bean定义资源的定位</span></div><div class="line">        Resource[] configResources = getConfigResources();</div><div class="line">        <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;<span class="comment">//因为我们分析的FileSystemXmlApplicationContext没有重写下面的												getConfigResources方法，所以返回为空，这里不会执行</span></div><div class="line">          	<span class="comment">//Xml Bean读取器调用其父类AbstractBeanDefinitionReader读取定位的Bean定义资源   </span></div><div class="line">            reader.loadBeanDefinitions(configResources);</div><div class="line">        &#125;</div><div class="line">  </div><div class="line">  </div><div class="line">        <span class="comment">//如果子类中获取的Bean定义资源定位为空，则获取FileSystemXmlApplicationContext构造方法中setConfigLocations方法设置的资源  </span></div><div class="line">        String[] configLocations = getConfigLocations();</div><div class="line">        <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</div><div class="line">            reader.loadBeanDefinitions(configLocations);</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//调用子类的获取Bean定义资源定位的方法  </span></div><div class="line"><span class="comment">//该方法在ClassPathXmlApplicationContext中进行实现，对于我们  </span></div><div class="line"><span class="comment">//举例分析源码的FileSystemXmlApplicationContext没有使用该方法  </span></div><div class="line"><span class="keyword">protected</span> Resource[] getConfigResources() &#123;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出：</p>
<ul>
<li>首先创建一个BeanDefinitionReader</li>
<li>调用本类中的loadBeanDefinitions(XmlBeanDefinitionReader reader)</li>
<li>在loadBeanDefinitions(XmlBeanDefinitionReader reader)中，先获取资源的定位，然后将资源的位置作为参数，调用reader的reader.loadBeanDefinitions(configLocations)。这个方法在AbstractBeanDefinitionReader类里面实现</li>
</ul>
<p>注意这个方法中的两个loadBeanDefinitions的参数是不一样的，一个是Resource数组，而另一个是String数组，数组里是bean资源定位的路径</p>
<h3 id="1-4、AbstractBeanDefinitionReader"><a href="#1-4、AbstractBeanDefinitionReader" class="headerlink" title="1.4、AbstractBeanDefinitionReader"></a>1.4、AbstractBeanDefinitionReader</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</div><div class="line">        Assert.notNull(locations, <span class="string">"Location array must not be null"</span>);</div><div class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (String location : locations) &#123;</div><div class="line">            counter += loadBeanDefinitions(location);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> counter;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</div><div class="line">        <span class="keyword">return</span> loadBeanDefinitions(location, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, Set&lt;Resource&gt; actualResources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</div><div class="line">        <span class="comment">//获取ResourceLoader资源加载器</span></div><div class="line">        ResourceLoader resourceLoader = getResourceLoader();</div><div class="line">        <span class="keyword">if</span> (resourceLoader == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</div><div class="line">                    <span class="string">"Cannot import bean definitions from location ["</span> + location + <span class="string">"]: no ResourceLoader available"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//</span></div><div class="line">        <span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//调用DefaultResourceLoader的getResourceByPath完成具体的Resource定位</span></div><div class="line">                Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</div><div class="line">                <span class="keyword">int</span> loadCount = loadBeanDefinitions(resources);</div><div class="line">                <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">for</span> (Resource resource : resources) &#123;</div><div class="line">                        actualResources.add(resource);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">                    logger.debug(<span class="string">"Loaded "</span> + loadCount + <span class="string">" bean definitions from location pattern ["</span> + location + <span class="string">"]"</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> loadCount;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</div><div class="line">                        <span class="string">"Could not resolve bean definition resource pattern ["</span> + location + <span class="string">"]"</span>, ex);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//调用DefaultResourceLoader的getResourceByPath完成具体的Resource定位</span></div><div class="line">            Resource resource = resourceLoader.getResource(location);</div><div class="line">            <span class="keyword">int</span> loadCount = loadBeanDefinitions(resource);</div><div class="line">            <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</div><div class="line">                actualResources.add(resource);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">                logger.debug(<span class="string">"Loaded "</span> + loadCount + <span class="string">" bean definitions from location ["</span> + location + <span class="string">"]"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> loadCount;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>终于到了真正的定位方法了，可以看出，</p>
<ul>
<li>首先获取了ResourceLoader，</li>
<li>然后调用resourceLoader.getResource(location)，这样就完成了从String到Recourse的过程。</li>
<li>resourceLoader.getResource(location)在最上面介绍的DefaultResourceLoader类中实现。</li>
</ul>
<h3 id="1-5、总结"><a href="#1-5、总结" class="headerlink" title="1.5、总结"></a>1.5、总结</h3><p>至此，Resource的定位过程就完全完成了。</p>
<p>从最开始的FileSystemXmlApplicationContext类中重写的getResourceByPath方法的调用，可以看出它完整的过程。</p>
<ul>
<li>从构造函数开始调用各个父类的方法</li>
<li>而各个父类方法在getResourceByPath方法时使用了模版方法，需要子类自己实现</li>
<li>所以，随后又调用到自己重写的这个getResourceByPath方法，完成Resource的定位。</li>
</ul>
<p>可以感觉到，虽然各个类的继承关系特别复杂，一时间难以理清，但是理解之后发现这种面向对象的编程思想：父类定义整个流程，而具体的实现细节通过模版模式由子类具体实现，这样子类在实现的时候有着很大的灵活性，扩展起来极其方便。</p>
<p> <img src="https://github.com/paine1690/HelloWorld/blob/master/pic/spring/10.jpg?raw=true" alt=""></p>
<p>这个图是最标准的方法调用过程。</p>
<h2 id="2、BeanDefinition的载入"><a href="#2、BeanDefinition的载入" class="headerlink" title="2、BeanDefinition的载入"></a>2、BeanDefinition的载入</h2><p>关于载入过程，要再次回到AbstractXmlApplicationContext的loadBeanDefinitions方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</div><div class="line">        <span class="comment">//获取Bean定义资源的定位</span></div><div class="line">        Resource[] configResources = getConfigResources();</div><div class="line">        <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</div><div class="line">          	<span class="comment">//Xml Bean读取器调用其父类AbstractBeanDefinitionReader读取定位的Bean定义资源   </span></div><div class="line">            reader.loadBeanDefinitions(configResources);</div><div class="line">        &#125;</div><div class="line">  </div><div class="line">  </div><div class="line">        <span class="comment">//如果子类中获取的Bean定义资源定位为空，则获取FileSystemXmlApplicationContext构造方法中setConfigLocations方法设置的资源  </span></div><div class="line">        String[] configLocations = getConfigLocations();</div><div class="line">        <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</div><div class="line">            reader.loadBeanDefinitions(configLocations);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>本来上面分析的是Resource[] configResources = getConfigResources();为空，所以不会执行但是不知道为什么都说是从这里开始执行加载过程的，虽然从逻辑上来看，确实是获取到Resource后开始载入过程。</p>
<h3 id="2-1、XmlBeanDefinitionReader"><a href="#2-1、XmlBeanDefinitionReader" class="headerlink" title="2.1、XmlBeanDefinitionReader"></a>2.1、XmlBeanDefinitionReader</h3><p>首先看一下XmlBeanDefinitionReader中loadBeanDefinitions(Resource …)方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//XmlBeanDefinitionReader加载资源的入口方法  </span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;  </div><div class="line">      <span class="comment">//将读入的XML资源进行特殊编码处理  </span></div><div class="line">      <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));  </div><div class="line">  &#125; </div><div class="line">    <span class="comment">//这里是载入XML形式Bean定义资源文件方法</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;    </div><div class="line">  .......    </div><div class="line">  <span class="keyword">try</span> &#123;    </div><div class="line">       <span class="comment">//将资源文件转为InputStream的IO流 </span></div><div class="line">      InputStream inputStream = encodedResource.getResource().getInputStream();    </div><div class="line">      <span class="keyword">try</span> &#123;    </div><div class="line">         <span class="comment">//从InputStream中得到XML的解析源    </span></div><div class="line">          InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);    </div><div class="line">          <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;    </div><div class="line">              inputSource.setEncoding(encodedResource.getEncoding());    </div><div class="line">          &#125;    </div><div class="line">          <span class="comment">//这里是具体的读取过程    </span></div><div class="line">          <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());    </div><div class="line">      &#125;    </div><div class="line">      <span class="keyword">finally</span> &#123;    </div><div class="line">          <span class="comment">//关闭从Resource中得到的IO流    </span></div><div class="line">          inputStream.close();    </div><div class="line">      &#125;    </div><div class="line">  &#125;    </div><div class="line">     .........    </div><div class="line"> &#125;    </div><div class="line">  <span class="comment">//从特定XML文件中实际载入Bean定义资源的方法 </span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span>    </span></div><div class="line">      <span class="keyword">throws</span> BeanDefinitionStoreException &#123;    </div><div class="line">  <span class="keyword">try</span> &#123;    </div><div class="line">      <span class="keyword">int</span> validationMode = getValidationModeForResource(resource);    </div><div class="line">      <span class="comment">//将XML文件转换为DOM对象，解析过程由documentLoader实现    </span></div><div class="line">      Document doc = <span class="keyword">this</span>.documentLoader.loadDocument(    </div><div class="line">              inputSource, <span class="keyword">this</span>.entityResolver, <span class="keyword">this</span>.errorHandler, validationMode, <span class="keyword">this</span>.namespaceAware);    </div><div class="line">      <span class="comment">//这里是启动对Bean定义解析的详细过程，该解析过程会用到Spring的Bean配置规则</span></div><div class="line">      <span class="keyword">return</span> registerBeanDefinitions(doc, resource);    </div><div class="line">    &#125;    </div><div class="line">    .......    </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看出，载入过程相对没有那么复杂，</p>
<ul>
<li>先获取Resource的流 </li>
<li>将流中的XML文件解析为Document对象，这个过程由documentLoader完成。</li>
</ul>
<p>DocumentLoader将Bean定义资源转换成Document对象的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用标准的JAXP将载入的Bean定义资源转换成document对象  </span></div><div class="line">  <span class="function"><span class="keyword">public</span> Document <span class="title">loadDocument</span><span class="params">(InputSource inputSource, EntityResolver entityResolver,  </span></span></div><div class="line">          ErrorHandler errorHandler, <span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware) <span class="keyword">throws</span> Exception &#123;  </div><div class="line">      <span class="comment">//创建文件解析器工厂  </span></div><div class="line">      DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);  </div><div class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </div><div class="line">          logger.debug(<span class="string">"Using JAXP provider ["</span> + factory.getClass().getName() + <span class="string">"]"</span>);  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//创建文档解析器  </span></div><div class="line">      DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);  </div><div class="line">      <span class="comment">//解析Spring的Bean定义资源  </span></div><div class="line">      <span class="keyword">return</span> builder.parse(inputSource);  </div><div class="line">  &#125;  </div><div class="line">  <span class="function"><span class="keyword">protected</span> DocumentBuilderFactory <span class="title">createDocumentBuilderFactory</span><span class="params">(<span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware)</span>  </span></div><div class="line">          <span class="keyword">throws</span> ParserConfigurationException &#123;  </div><div class="line">      <span class="comment">//创建文档解析工厂  </span></div><div class="line">      DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();  </div><div class="line">      factory.setNamespaceAware(namespaceAware);  </div><div class="line">      <span class="comment">//设置解析XML的校验  </span></div><div class="line">      <span class="keyword">if</span> (validationMode != XmlValidationModeDetector.VALIDATION_NONE) &#123;  </div><div class="line">          factory.setValidating(<span class="keyword">true</span>);  </div><div class="line">          <span class="keyword">if</span> (validationMode == XmlValidationModeDetector.VALIDATION_XSD) &#123;  </div><div class="line">              factory.setNamespaceAware(<span class="keyword">true</span>);  </div><div class="line">              <span class="keyword">try</span> &#123;  </div><div class="line">                  factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);  </div><div class="line">              &#125;  </div><div class="line">              <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;  </div><div class="line">                  ParserConfigurationException pcex = <span class="keyword">new</span> ParserConfigurationException(  </div><div class="line">                          <span class="string">"Unable to validate using XSD: Your JAXP provider ["</span> + factory +  </div><div class="line">                          <span class="string">"] does not support XML Schema. Are you running on Java 1.4 with Apache Crimson? "</span> +  </div><div class="line">                          <span class="string">"Upgrade to Apache Xerces (or Java 1.5) for full XSD support."</span>);  </div><div class="line">                  pcex.initCause(ex);  </div><div class="line">                  <span class="keyword">throw</span> pcex;  </div><div class="line">              &#125;  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">return</span> factory;  </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>该解析过程调用JavaEE标准的JAXP标准进行处理。至此Spring IoC容器根据定位的Bean定义资源文件，将其加载读入并转换成为Document对象过程完成。</p>
<p>注意这个只是XML文件的解析，而不是BeanDefinition的解析。对BeanDefinition的解析是下一步，在registerBeanDefinitions(doc, resource);   中完成</p>
<h3 id="2-2、总结"><a href="#2-2、总结" class="headerlink" title="2.2、总结"></a>2.2、总结</h3><p>可以看出，载入过程实际上就是Resource对象转换成Document对象的过程，也就是一个XML文件解析的过程，Spring中使用的是JAXP解析，生成的Document文件就是org.w3c.dom.Document中的Document文件。</p>
<h2 id="3、BeanDefinition的解析"><a href="#3、BeanDefinition的解析" class="headerlink" title="3、BeanDefinition的解析"></a>3、BeanDefinition的解析</h2><p>在上面的XmlBeanDefinitionReader类中完成载入工作后，得到了Document对象，接下来调用registerBeanDefinitions(doc, resource)启动Spring IoC容器对Bean定义的解析过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//按照Spring的Bean语义要求将Bean定义资源解析并转换为容器内部数据结构  </span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;  </div><div class="line">      <span class="comment">//得到BeanDefinitionDocumentReader来对xml格式的BeanDefinition解析  </span></div><div class="line">      BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();  </div><div class="line">      <span class="comment">//获得容器中注册的Bean数量  </span></div><div class="line">      <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();  </div><div class="line">      <span class="comment">//解析过程入口，这里使用了委派模式，BeanDefinitionDocumentReader只是个接口，//具体的解析实现过程有实现类DefaultBeanDefinitionDocumentReader完成  </span></div><div class="line">      documentReader.registerBeanDefinitions(doc, createReaderContext(resource));  </div><div class="line">      <span class="comment">//统计解析的Bean数量  </span></div><div class="line">      <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;  </div><div class="line">  &#125;  </div><div class="line">  </div><div class="line"><span class="comment">//创建BeanDefinitionDocumentReader对象，解析Document对象  </span></div><div class="line">  <span class="function"><span class="keyword">protected</span> BeanDefinitionDocumentReader <span class="title">createBeanDefinitionDocumentReader</span><span class="params">()</span> </span>&#123;  </div><div class="line">      <span class="keyword">return</span> BeanDefinitionDocumentReader.class.cast(BeanUtils.instantiateClass(<span class="keyword">this</span>.documentReaderClass));  </div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>该方法先获得一个BeanDefinitionDocumentReader，然后调用documentReader.registerBeanDefinitions(doc, createReaderContext(resource))方法，这个方法是在DefaultBeanDefinitionDocumentReader类中实现的。</p>
<h3 id="3-1、DefaultBeanDefinitionDocumentReader"><a href="#3-1、DefaultBeanDefinitionDocumentReader" class="headerlink" title="3.1、DefaultBeanDefinitionDocumentReader"></a>3.1、DefaultBeanDefinitionDocumentReader</h3><p>BeanDefinitionDocumentReader接口通过registerBeanDefinitions方法调用其实现类DefaultBeanDefinitionDocumentReader对Document对象进行解析，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//根据Spring DTD对Bean的定义规则解析Bean定义Document对象  </span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;  </div><div class="line">       <span class="comment">//获得XML描述符  </span></div><div class="line">       <span class="keyword">this</span>.readerContext = readerContext;  </div><div class="line">       logger.debug(<span class="string">"Loading bean definitions"</span>);  </div><div class="line">       <span class="comment">//获得Document的根元素  </span></div><div class="line">       Element root = doc.getDocumentElement();  </div><div class="line">       <span class="comment">//具体的解析过程由BeanDefinitionParserDelegate实现，  </span></div><div class="line">       <span class="comment">//BeanDefinitionParserDelegate中定义了Spring Bean定义XML文件的各种元素  </span></div><div class="line">      BeanDefinitionParserDelegate delegate = createHelper(readerContext, root);  </div><div class="line">      <span class="comment">//在解析Bean定义之前，进行自定义的解析，增强解析过程的可扩展性  </span></div><div class="line">      preProcessXml(root);  </div><div class="line">      <span class="comment">//从Document的根元素开始进行Bean定义的Document对象  </span></div><div class="line">      parseBeanDefinitions(root, delegate);  </div><div class="line">      <span class="comment">//在解析Bean定义之后，进行自定义的解析，增加解析过程的可扩展性  </span></div><div class="line">      postProcessXml(root);  </div><div class="line">  &#125;  </div><div class="line">  <span class="comment">//创建BeanDefinitionParserDelegate，用于完成真正的解析过程  </span></div><div class="line">  <span class="function"><span class="keyword">protected</span> BeanDefinitionParserDelegate <span class="title">createHelper</span><span class="params">(XmlReaderContext readerContext, Element root)</span> </span>&#123;  </div><div class="line">      BeanDefinitionParserDelegate delegate = <span class="keyword">new</span> BeanDefinitionParserDelegate(readerContext);  </div><div class="line">      <span class="comment">//BeanDefinitionParserDelegate初始化Document根元素  </span></div><div class="line">      delegate.initDefaults(root);  </div><div class="line">      <span class="keyword">return</span> delegate;  </div><div class="line">  &#125;  </div><div class="line">  <span class="comment">//使用Spring的Bean规则从Document的根元素开始进行Bean定义的Document对象  </span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;  </div><div class="line">      <span class="comment">//Bean定义的Document对象使用了Spring默认的XML命名空间  </span></div><div class="line">      <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;  </div><div class="line">          <span class="comment">//获取Bean定义的Document对象根元素的所有子节点  </span></div><div class="line">          NodeList nl = root.getChildNodes();  </div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;  </div><div class="line">              Node node = nl.item(i);  </div><div class="line">              <span class="comment">//获得Document节点是XML元素节点  </span></div><div class="line">              <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;  </div><div class="line">                  Element ele = (Element) node;  </div><div class="line">              		<span class="comment">//Bean定义的Document的元素节点使用的是Spring默认的XML命名空间  </span></div><div class="line">                  <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;  </div><div class="line">                      <span class="comment">//使用Spring的Bean规则解析元素节点  </span></div><div class="line">                      parseDefaultElement(ele, delegate);  </div><div class="line">                  &#125;  </div><div class="line">                  <span class="keyword">else</span> &#123;  </div><div class="line">                      <span class="comment">//没有使用Spring默认的XML命名空间，则使用用户自定义的解//析规则解析元素节点  </span></div><div class="line">                      delegate.parseCustomElement(ele);  </div><div class="line">                  &#125;  </div><div class="line">              &#125;  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">else</span> &#123;  </div><div class="line">          <span class="comment">//Document的根节点没有使用Spring默认的命名空间，则使用用户自定义的  </span></div><div class="line">          <span class="comment">//解析规则解析Document根节点  </span></div><div class="line">          delegate.parseCustomElement(root);  </div><div class="line">      &#125;  </div><div class="line">  &#125;  </div><div class="line">  <span class="comment">//使用Spring的Bean规则解析Document元素节点  </span></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;  </div><div class="line">      <span class="comment">//如果元素节点是&lt;Import&gt;导入元素，进行导入解析  </span></div><div class="line">      <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;  </div><div class="line">          importBeanDefinitionResource(ele);  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//如果元素节点是&lt;Alias&gt;别名元素，进行别名解析  </span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;  </div><div class="line">          processAliasRegistration(ele);  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//元素节点既不是导入元素，也不是别名元素，即普通的&lt;Bean&gt;元素，  </span></div><div class="line">      <span class="comment">//按照Spring的Bean规则解析元素  </span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;  </div><div class="line">          processBeanDefinition(ele, delegate);  </div><div class="line">      &#125;  </div><div class="line">  &#125;  </div><div class="line">  <span class="comment">//解析&lt;Import&gt;导入元素，从给定的导入路径加载Bean定义资源到Spring IoC容器中  </span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">importBeanDefinitionResource</span><span class="params">(Element ele)</span> </span>&#123;  </div><div class="line">      <span class="comment">//获取给定的导入元素的location属性  </span></div><div class="line">      String location = ele.getAttribute(RESOURCE_ATTRIBUTE);  </div><div class="line">      <span class="comment">//如果导入元素的location属性值为空，则没有导入任何资源，直接返回  </span></div><div class="line">      <span class="keyword">if</span> (!StringUtils.hasText(location)) &#123;  </div><div class="line">          getReaderContext().error(<span class="string">"Resource location must not be empty"</span>, ele);  </div><div class="line">          <span class="keyword">return</span>;  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//使用系统变量值解析location属性值  </span></div><div class="line">      location = SystemPropertyUtils.resolvePlaceholders(location);  </div><div class="line">      Set&lt;Resource&gt; actualResources = <span class="keyword">new</span> LinkedHashSet&lt;Resource&gt;(<span class="number">4</span>);  </div><div class="line">      <span class="comment">//标识给定的导入元素的location是否是绝对路径  </span></div><div class="line">      <span class="keyword">boolean</span> absoluteLocation = <span class="keyword">false</span>;  </div><div class="line">      <span class="keyword">try</span> &#123;  </div><div class="line">          absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">catch</span> (URISyntaxException ex) &#123;  </div><div class="line">          <span class="comment">//给定的导入元素的location不是绝对路径  </span></div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//给定的导入元素的location是绝对路径  </span></div><div class="line">      <span class="keyword">if</span> (absoluteLocation) &#123;  </div><div class="line">          <span class="keyword">try</span> &#123;  </div><div class="line">              <span class="comment">//使用资源读入器加载给定路径的Bean定义资源  </span></div><div class="line">              <span class="keyword">int</span> importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources);  </div><div class="line">              <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </div><div class="line">                  logger.debug(<span class="string">"Imported "</span> + importCount + <span class="string">" bean definitions from URL location ["</span> + location + <span class="string">"]"</span>);  </div><div class="line">              &#125;  </div><div class="line">          &#125;  </div><div class="line">          <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;  </div><div class="line">              getReaderContext().error(  </div><div class="line">                      <span class="string">"Failed to import bean definitions from URL location ["</span> + location + <span class="string">"]"</span>, ele, ex);  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">else</span> &#123;  </div><div class="line">          <span class="comment">//给定的导入元素的location是相对路径  </span></div><div class="line">          <span class="keyword">try</span> &#123;  </div><div class="line">              <span class="keyword">int</span> importCount;  </div><div class="line">              <span class="comment">//将给定导入元素的location封装为相对路径资源  </span></div><div class="line">              Resource relativeResource = getReaderContext().getResource().createRelative(location);  </div><div class="line">              <span class="comment">//封装的相对路径资源存在  </span></div><div class="line">              <span class="keyword">if</span> (relativeResource.exists()) &#123;  </div><div class="line">                  <span class="comment">//使用资源读入器加载Bean定义资源  </span></div><div class="line">                  importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);  </div><div class="line">                  actualResources.add(relativeResource);  </div><div class="line">              &#125;  </div><div class="line">              <span class="comment">//封装的相对路径资源不存在  </span></div><div class="line">              <span class="keyword">else</span> &#123;  </div><div class="line">                  <span class="comment">//获取Spring IoC容器资源读入器的基本路径  </span></div><div class="line">                  String baseLocation = getReaderContext().getResource().getURL().toString();  </div><div class="line">                  <span class="comment">//根据Spring IoC容器资源读入器的基本路径加载给定导入  </span></div><div class="line">                  <span class="comment">//路径的资源  </span></div><div class="line">                  importCount = getReaderContext().getReader().loadBeanDefinitions(  </div><div class="line">                          StringUtils.applyRelativePath(baseLocation, location), actualResources);  </div><div class="line">              &#125;  </div><div class="line">              <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </div><div class="line">                  logger.debug(<span class="string">"Imported "</span> + importCount + <span class="string">" bean definitions from relative location ["</span> + location + <span class="string">"]"</span>);  </div><div class="line">              &#125;  </div><div class="line">          &#125;  </div><div class="line">          <span class="keyword">catch</span> (IOException ex) &#123;  </div><div class="line">              getReaderContext().error(<span class="string">"Failed to resolve current resource location"</span>, ele, ex);  </div><div class="line">          &#125;  </div><div class="line">          <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;  </div><div class="line">              getReaderContext().error(<span class="string">"Failed to import bean definitions from relative location ["</span> + location + <span class="string">"]"</span>,  </div><div class="line">                      ele, ex);  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">      Resource[] actResArray = actualResources.toArray(<span class="keyword">new</span> Resource[actualResources.size()]);  </div><div class="line">      <span class="comment">//在解析完&lt;Import&gt;元素之后，发送容器导入其他资源处理完成事件  </span></div><div class="line">      getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));  </div><div class="line">  &#125;  </div><div class="line">  <span class="comment">//解析&lt;Alias&gt;别名元素，为Bean向Spring IoC容器注册别名  </span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAliasRegistration</span><span class="params">(Element ele)</span> </span>&#123;  </div><div class="line">      <span class="comment">//获取&lt;Alias&gt;别名元素中name的属性值  </span></div><div class="line">      String name = ele.getAttribute(NAME_ATTRIBUTE);  </div><div class="line">      <span class="comment">//获取&lt;Alias&gt;别名元素中alias的属性值  </span></div><div class="line">      String alias = ele.getAttribute(ALIAS_ATTRIBUTE);  </div><div class="line">      <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;  </div><div class="line">      <span class="comment">//&lt;alias&gt;别名元素的name属性值为空  </span></div><div class="line">      <span class="keyword">if</span> (!StringUtils.hasText(name)) &#123;  </div><div class="line">          getReaderContext().error(<span class="string">"Name must not be empty"</span>, ele);  </div><div class="line">          valid = <span class="keyword">false</span>;  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//&lt;alias&gt;别名元素的alias属性值为空  </span></div><div class="line">      <span class="keyword">if</span> (!StringUtils.hasText(alias)) &#123;  </div><div class="line">          getReaderContext().error(<span class="string">"Alias must not be empty"</span>, ele);  </div><div class="line">          valid = <span class="keyword">false</span>;  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">if</span> (valid) &#123;  </div><div class="line">          <span class="keyword">try</span> &#123;  </div><div class="line">              <span class="comment">//向容器的资源读入器注册别名  </span></div><div class="line">              getReaderContext().getRegistry().registerAlias(name, alias);  </div><div class="line">          &#125;  </div><div class="line">          <span class="keyword">catch</span> (Exception ex) &#123;  </div><div class="line">              getReaderContext().error(<span class="string">"Failed to register alias '"</span> + alias +  </div><div class="line">                      <span class="string">"' for bean with name '"</span> + name + <span class="string">"'"</span>, ele, ex);  </div><div class="line">          &#125;  </div><div class="line">          <span class="comment">//在解析完&lt;Alias&gt;元素之后，发送容器别名处理完成事件  </span></div><div class="line">          getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));  </div><div class="line">      &#125;  </div><div class="line">  &#125;  </div><div class="line">  <span class="comment">//解析Bean定义资源Document对象的普通元素  </span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;  </div><div class="line">      <span class="comment">// BeanDefinitionHolder是对BeanDefinition的封装，即Bean定义的封装类  </span></div><div class="line">      <span class="comment">//对Document对象中&lt;Bean&gt;元素的解析由BeanDefinitionParserDelegate实现  </span></div><div class="line">    	BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);  </div><div class="line">      <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;  </div><div class="line">          bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);  </div><div class="line">          <span class="keyword">try</span> &#123;  </div><div class="line">             		<span class="comment">//向Spring IoC容器注册解析得到的Bean定义，这是Bean定义向IoC容器注册的入口            </span></div><div class="line">                 BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());  </div><div class="line">          &#125;  </div><div class="line">          <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;  </div><div class="line">              getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +  </div><div class="line">                      bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);  </div><div class="line">          &#125;  </div><div class="line">          <span class="comment">//在完成向Spring IoC容器注册解析得到的Bean定义之后，发送注册事件  </span></div><div class="line">          getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));  </div><div class="line">      &#125;  </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>可以看出，Spring采用DOM方式解析xml文件，</p>
<ol>
<li>从根节点开始逐个获得子节点Element，然后判断是不是根据Spring命名空间的<ul>
<li>如果是，那么调用parseDefaultElement(ele, delegate);  使用Spring的Bean规则解析元素节点 </li>
<li>如果不是，那么调用delegate.parseCustomElement(ele);  则使用用户自定义的解析规则解析元素节点 </li>
</ul>
</li>
<li>在Spring的Bean规则解析Document元素节点方法parseDefaultElement中：<ul>
<li>如果元素节点是<code>&lt;Import&gt;</code>导入元素，调用importBeanDefinitionResource(ele)方法进行导入解析  </li>
<li>如果元素节点是<code>&lt;Alias&gt;</code>别名元素，调用processAliasRegistration(ele)方法进行别名解析  </li>
<li>对于既不是<code>&lt;Import&gt;</code>元素，又不是<code>&lt;Alias&gt;</code>元素的元素，即Spring配置文件中普通的<code>&lt;Bean&gt;</code>元素的解析，那么调用processBeanDefinition(ele, delegate)方法</li>
</ul>
</li>
<li>在processBeanDefinition方法中，定义了一个BeanDefinitionHolder对象，用来持有对bean属性的处理结果，这个处理过程则由BeanDefinitionParserDelegate类中的parseBeanDefinitionElement方法来实现。</li>
<li>解析完成之后，就会将这个BeanDefinitionHolder对象作为参数调用BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry())方法，来启动注册的过程。</li>
</ol>
<p>关于import和ailas书中没有具体分析，主要是介绍了BeanDefinitionParserDelegate中的parseBeanDefinitionElement方法来解析Bean定义资源文件中的<code>&lt;Bean&gt;</code>元素的过程</p>
<h3 id="3-2、BeanDefinitionParserDelegate"><a href="#3-2、BeanDefinitionParserDelegate" class="headerlink" title="3.2、BeanDefinitionParserDelegate"></a>3.2、BeanDefinitionParserDelegate</h3><h4 id="1、id、name、alias属性的解析"><a href="#1、id、name、alias属性的解析" class="headerlink" title="1、id、name、alias属性的解析"></a>1、id、name、alias属性的解析</h4><p>processBeanDefinitionfang方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//解析Bean定义资源文件中的&lt;Bean&gt;元素，这个方法中主要处理&lt;Bean&gt;元素的id，name  </span></div><div class="line"><span class="comment">//和别名属性  </span></div><div class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, BeanDefinition containingBean)</span> </span>&#123;  </div><div class="line">    <span class="comment">//获取&lt;Bean&gt;元素中的id属性值  </span></div><div class="line">    String id = ele.getAttribute(ID_ATTRIBUTE);  </div><div class="line">    <span class="comment">//获取&lt;Bean&gt;元素中的name属性值  </span></div><div class="line">    String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);  </div><div class="line">    <span class="comment">//获取&lt;Bean&gt;元素中的alias属性值  </span></div><div class="line">    List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;String&gt;();  </div><div class="line">    <span class="comment">//将&lt;Bean&gt;元素中的所有name属性值存放到别名中  </span></div><div class="line">    <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;  </div><div class="line">        String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, BEAN_NAME_DELIMITERS);  </div><div class="line">        aliases.addAll(Arrays.asList(nameArr));  </div><div class="line">    &#125;  </div><div class="line">    String beanName = id;  </div><div class="line">    <span class="comment">//如果&lt;Bean&gt;元素中没有配置id属性时，将别名中的第一个值赋值给beanName  </span></div><div class="line">    <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;  </div><div class="line">        beanName = aliases.remove(<span class="number">0</span>);  </div><div class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </div><div class="line">            logger.debug(<span class="string">"No XML 'id' specified - using '"</span> + beanName +  </div><div class="line">                    <span class="string">"' as bean name and "</span> + aliases + <span class="string">" as aliases"</span>);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">//检查&lt;Bean&gt;元素所配置的id或者name的唯一性，containingBean标识&lt;Bean&gt;  </span></div><div class="line">    <span class="comment">//元素中是否包含子&lt;Bean&gt;元素  </span></div><div class="line">    <span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;  </div><div class="line">        <span class="comment">//检查&lt;Bean&gt;元素所配置的id、name或者别名是否重复  </span></div><div class="line">        checkNameUniqueness(beanName, aliases, ele);  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">//详细对&lt;Bean&gt;元素中配置的Bean定义进行解析的地方，这个beanDefinition终于定义出来了</span></div><div class="line">    AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);  </div><div class="line">    <span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;  </div><div class="line">        <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;  </div><div class="line">            <span class="keyword">try</span> &#123;  </div><div class="line">                <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;  </div><div class="line">                    <span class="comment">//如果&lt;Bean&gt;元素中没有配置id、别名或者name，且没有包含子//&lt;Bean&gt;元素，为解析的Bean生成一个唯一beanName并注册  </span></div><div class="line">                    beanName = BeanDefinitionReaderUtils.generateBeanName(  </div><div class="line">                            beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);  </div><div class="line">                &#125;  </div><div class="line">                <span class="keyword">else</span> &#123;  </div><div class="line">                    <span class="comment">//如果&lt;Bean&gt;元素中没有配置id、别名或者name，且包含了子//&lt;Bean&gt;元素，为解析的Bean使用别名向IoC容器注册  </span></div><div class="line">                    beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);  </div><div class="line">                    <span class="comment">//为解析的Bean使用别名注册时，为了向后兼容Spring1.2/2.0，给别名添加类名后缀  </span></div><div class="line">                    String beanClassName = beanDefinition.getBeanClassName();  </div><div class="line">                    <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;  </div><div class="line">                            beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;  </div><div class="line">                            !<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;  </div><div class="line">                        aliases.add(beanClassName);  </div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;  </div><div class="line">                    logger.debug(<span class="string">"Neither XML 'id' nor 'name' specified - "</span> +  </div><div class="line">                            <span class="string">"using generated bean name ["</span> + beanName + <span class="string">"]"</span>);  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">catch</span> (Exception ex) &#123;  </div><div class="line">                error(ex.getMessage(), ele);  </div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        String[] aliasesArray = StringUtils.toStringArray(aliases);  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">//当解析出错时，返回null  </span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到了这里，在IOC容器中存在的数据结构AbstractBeanDefinition beanDefinition终于被定义出来了。</p>
<blockquote>
<p>AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); </p>
</blockquote>
<h4 id="2、其他属性的解析"><a href="#2、其他属性的解析" class="headerlink" title="2、其他属性的解析"></a>2、其他属性的解析</h4><p>parseBeanDefinitionElement方法是生成这个AbstractBeanDefinition 的地方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//详细对&lt;Bean&gt;元素中配置的Bean定义其他属性进行解析，由于上面的方法中已经对Bean的id、name和别名等属性进行了处理，该方法中主要处理除这三个以外的其他属性数据  </span></div><div class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(  </span></span></div><div class="line">        Element ele, String beanName, BeanDefinition containingBean) &#123;  </div><div class="line">    <span class="comment">//记录解析的&lt;Bean&gt;  </span></div><div class="line">    <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> BeanEntry(beanName));  </div><div class="line">    <span class="comment">//这里只读取&lt;Bean&gt;元素中配置的class名字，然后载入到BeanDefinition中去  </span></div><div class="line">    <span class="comment">//只是记录配置的class名字，不做实例化，对象的实例化在依赖注入时完成  </span></div><div class="line">    String className = <span class="keyword">null</span>;  </div><div class="line">    <span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;  </div><div class="line">        className = ele.getAttribute(CLASS_ATTRIBUTE).trim();  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">try</span> &#123;  </div><div class="line">        String parent = <span class="keyword">null</span>;  </div><div class="line">        <span class="comment">//如果&lt;Bean&gt;元素中配置了parent属性，则获取parent属性的值  </span></div><div class="line">        <span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;  </div><div class="line">            parent = ele.getAttribute(PARENT_ATTRIBUTE);  </div><div class="line">        &#125;  </div><div class="line">        <span class="comment">//根据&lt;Bean&gt;元素配置的class名称和parent属性值创建BeanDefinition  </span></div><div class="line">        <span class="comment">//为载入Bean定义信息做准备  </span></div><div class="line">        AbstractBeanDefinition bd = createBeanDefinition(className, parent);  </div><div class="line">        <span class="comment">//对当前的&lt;Bean&gt;元素中配置的一些属性进行解析和设置，如配置的单态(singleton)属性等  </span></div><div class="line">        parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);  </div><div class="line">        <span class="comment">//为&lt;Bean&gt;元素解析的Bean设置description信息 bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));  </span></div><div class="line">        <span class="comment">//对&lt;Bean&gt;元素的meta(元信息)属性解析  </span></div><div class="line">        parseMetaElements(ele, bd);  </div><div class="line">        <span class="comment">//对&lt;Bean&gt;元素的lookup-method属性解析  </span></div><div class="line">        parseLookupOverrideSubElements(ele, bd.getMethodOverrides());  </div><div class="line">        <span class="comment">//对&lt;Bean&gt;元素的replaced-method属性解析  </span></div><div class="line">        parseReplacedMethodSubElements(ele, bd.getMethodOverrides());  </div><div class="line">        <span class="comment">//解析&lt;Bean&gt;元素的构造方法设置  </span></div><div class="line">        parseConstructorArgElements(ele, bd);  </div><div class="line">        <span class="comment">//解析&lt;Bean&gt;元素的&lt;property&gt;设置  </span></div><div class="line">        parsePropertyElements(ele, bd);  </div><div class="line">        <span class="comment">//解析&lt;Bean&gt;元素的qualifier属性  </span></div><div class="line">        parseQualifierElements(ele, bd);  </div><div class="line">        <span class="comment">//为当前解析的Bean设置所需的资源和依赖对象  </span></div><div class="line">        bd.setResource(<span class="keyword">this</span>.readerContext.getResource());  </div><div class="line">        bd.setSource(extractSource(ele));  </div><div class="line">        <span class="keyword">return</span> bd;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;  </div><div class="line">        error(<span class="string">"Bean class ["</span> + className + <span class="string">"] not found"</span>, ele, ex);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">catch</span> (NoClassDefFoundError err) &#123;  </div><div class="line">        error(<span class="string">"Class that bean class ["</span> + className + <span class="string">"] depends on not found"</span>, ele, err);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;  </div><div class="line">        error(<span class="string">"Unexpected failure during bean definition parsing"</span>, ele, ex);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">finally</span> &#123;  </div><div class="line">        <span class="keyword">this</span>.parseState.pop();  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">//解析&lt;Bean&gt;元素出错时，返回null  </span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里是BeanDefinition生成的地方，大部分属性都被解析出来，下面再次以<code>&lt;property&gt;</code>属性为例，分析一下这个属性的解析过程。</p>
<h4 id="3、property元素的解析"><a href="#3、property元素的解析" class="headerlink" title="3、property元素的解析"></a>3、property元素的解析</h4><p>在解析过程中，这些属性值会被封装成PropertyValue对象并设置到BeanDefinition中去，源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//解析&lt;Bean&gt;元素中的&lt;property&gt;子元素  </span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parsePropertyElements</span><span class="params">(Element beanEle, BeanDefinition bd)</span> </span>&#123;  </div><div class="line">      <span class="comment">//获取&lt;Bean&gt;元素中所有的子元素  </span></div><div class="line">      NodeList nl = beanEle.getChildNodes();  </div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;  </div><div class="line">          Node node = nl.item(i);  </div><div class="line">          <span class="comment">//如果子元素是&lt;property&gt;子元素，则调用解析&lt;property&gt;子元素方法解析  </span></div><div class="line">          <span class="keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) &#123;  </div><div class="line">              parsePropertyElement((Element) node, bd);  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">  &#125;  </div><div class="line"></div><div class="line">  <span class="comment">//解析&lt;property&gt;元素  </span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parsePropertyElement</span><span class="params">(Element ele, BeanDefinition bd)</span> </span>&#123;  </div><div class="line">      <span class="comment">//获取&lt;property&gt;元素的名字   </span></div><div class="line">      String propertyName = ele.getAttribute(NAME_ATTRIBUTE);  </div><div class="line">      <span class="keyword">if</span> (!StringUtils.hasLength(propertyName)) &#123;  </div><div class="line">          error(<span class="string">"Tag 'property' must have a 'name' attribute"</span>, ele);  </div><div class="line">          <span class="keyword">return</span>;  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> PropertyEntry(propertyName));  </div><div class="line">      <span class="keyword">try</span> &#123;  </div><div class="line">          <span class="comment">//如果一个Bean中已经有同名的property存在，则不进行解析，直接返回。  </span></div><div class="line">          <span class="comment">//即如果在同一个Bean中配置同名的property，则只有第一个起作用  </span></div><div class="line">          <span class="keyword">if</span> (bd.getPropertyValues().contains(propertyName)) &#123;  </div><div class="line">              error(<span class="string">"Multiple 'property' definitions for property '"</span> + propertyName + <span class="string">"'"</span>, ele);  </div><div class="line">              <span class="keyword">return</span>;  </div><div class="line">          &#125;  </div><div class="line">          <span class="comment">//解析获取property的值  </span></div><div class="line">          Object val = parsePropertyValue(ele, bd, propertyName);  </div><div class="line">          <span class="comment">//根据property的名字和值创建property实例  </span></div><div class="line">          PropertyValue pv = <span class="keyword">new</span> PropertyValue(propertyName, val);  </div><div class="line">          <span class="comment">//解析&lt;property&gt;元素中的属性  </span></div><div class="line">          parseMetaElements(ele, pv);  </div><div class="line">          pv.setSource(extractSource(ele));  </div><div class="line">          bd.getPropertyValues().addPropertyValue(pv);  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">finally</span> &#123;  </div><div class="line">          <span class="keyword">this</span>.parseState.pop();  </div><div class="line">      &#125;  </div><div class="line">  &#125;  </div><div class="line"></div><div class="line">  <span class="comment">//解析获取property值  </span></div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">parsePropertyValue</span><span class="params">(Element ele, BeanDefinition bd, String propertyName)</span> </span>&#123;  </div><div class="line">      String elementName = (propertyName != <span class="keyword">null</span>) ?  </div><div class="line">                      <span class="string">"&lt;property&gt; element for property '"</span> + propertyName + <span class="string">"'"</span> :  </div><div class="line">                      <span class="string">"&lt;constructor-arg&gt; element"</span>;  </div><div class="line">      <span class="comment">//获取&lt;property&gt;的所有子元素，只能是其中一种类型:ref,value,list等  </span></div><div class="line">      NodeList nl = ele.getChildNodes();  </div><div class="line">      Element subElement = <span class="keyword">null</span>;  </div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;  </div><div class="line">          Node node = nl.item(i);  </div><div class="line">          <span class="comment">//子元素不是description和meta属性  </span></div><div class="line">          <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;&amp;  </div><div class="line">                  !nodeNameEquals(node, META_ELEMENT)) &#123;  </div><div class="line">              <span class="keyword">if</span> (subElement != <span class="keyword">null</span>) &#123;  </div><div class="line">                  error(elementName + <span class="string">" must not contain more than one sub-element"</span>, ele);  </div><div class="line">              &#125;  </div><div class="line">              <span class="keyword">else</span> &#123;<span class="comment">//当前&lt;property&gt;元素包含有子元素  </span></div><div class="line">                  subElement = (Element) node;  </div><div class="line">              &#125;  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//判断property的属性值是ref还是value，不允许既是ref又是value  </span></div><div class="line">      <span class="keyword">boolean</span> hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);  </div><div class="line">      <span class="keyword">boolean</span> hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);  </div><div class="line">      <span class="keyword">if</span> ((hasRefAttribute &amp;&amp; hasValueAttribute) ||  </div><div class="line">              ((hasRefAttribute || hasValueAttribute) &amp;&amp; subElement != <span class="keyword">null</span>)) &#123;  </div><div class="line">          error(elementName +  </div><div class="line">                  <span class="string">" is only allowed to contain either 'ref' attribute OR 'value' attribute OR sub-element"</span>, ele);  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//如果属性是ref，创建一个ref的数据对象RuntimeBeanReference，这个对象封装了ref信息  </span></div><div class="line">      <span class="keyword">if</span> (hasRefAttribute) &#123;  </div><div class="line">          String refName = ele.getAttribute(REF_ATTRIBUTE);  </div><div class="line">          <span class="keyword">if</span> (!StringUtils.hasText(refName)) &#123;  </div><div class="line">              error(elementName + <span class="string">" contains empty 'ref' attribute"</span>, ele);  </div><div class="line">          &#125;  </div><div class="line">          <span class="comment">//一个指向运行时所依赖对象的引用  </span></div><div class="line">          RuntimeBeanReference ref = <span class="keyword">new</span> RuntimeBeanReference(refName);  </div><div class="line">          <span class="comment">//设置这个ref的数据对象是被当前的property对象所引用  </span></div><div class="line">          ref.setSource(extractSource(ele));  </div><div class="line">          <span class="keyword">return</span> ref;  </div><div class="line">      &#125;  </div><div class="line">       <span class="comment">//如果属性是value，创建一个value的数据对象TypedStringValue，这个对象封装了value信息  </span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (hasValueAttribute) &#123;  </div><div class="line">          <span class="comment">//一个持有String类型值的对象  </span></div><div class="line">          TypedStringValue valueHolder = <span class="keyword">new</span> TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));  </div><div class="line">          <span class="comment">//设置这个value数据对象是被当前的property对象所引用  </span></div><div class="line">          valueHolder.setSource(extractSource(ele));  </div><div class="line">          <span class="keyword">return</span> valueHolder;  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//如果当前&lt;property&gt;元素还有子元素  </span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (subElement != <span class="keyword">null</span>) &#123;  </div><div class="line">          <span class="comment">//解析&lt;property&gt;的子元素  </span></div><div class="line">          <span class="keyword">return</span> parsePropertySubElement(subElement, bd);  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">else</span> &#123;  </div><div class="line">          <span class="comment">//propery属性中既不是ref，也不是value属性，解析出错返回null        error(elementName + " must specify a ref or value", ele);  </span></div><div class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">      &#125;  </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>可以看出，对<code>&lt;property&gt;</code>解析的时候，先根据</p>
<ol>
<li>先根据propertyName 来确定<code>&lt;property&gt;</code>的名字，然后封装一个PropertyEntry对象</li>
<li>如果已经存在一个同名的则直接返回。可知：<strong>如果在同一个Bean中配置同名的property，则只有第一个起作用</strong></li>
<li>如果没有同名的，则继续解析property的值 ，并将其封装成PropertyValue对象</li>
<li>解析<code>&lt;property&gt;</code>的所有子元素，只能是其中一种类型:ref,value,list等，<ul>
<li>对值的属性进行判断，是ref还是value，不能同时是这两者</li>
<li>如果属性是ref，创建一个ref的数据对象RuntimeBeanReference，这个对象封装了ref信息  </li>
<li>如果属性是value，创建一个value的数据对象TypedStringValue，这个对象封装了value信息  </li>
<li>ref和value都通过<code>ref(或valueHolder).setSource(extractSource(ele));</code>方法将属性值/引用与所引用的属性关联起来。</li>
<li>不是ref或value而是子元素，则继续通过parsePropertySubElement方法解析</li>
</ul>
</li>
</ol>
<h4 id="4、property子元素的解析"><a href="#4、property子元素的解析" class="headerlink" title="4、property子元素的解析"></a>4、property子元素的解析</h4><p>下面是对property子元素的解析过程，Array、List、Set、Map等元素都会在这里进行解析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//解析&lt;property&gt;元素中ref,value或者集合等子元素  </span></div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">parsePropertySubElement</span><span class="params">(Element ele, BeanDefinition bd, String defaultValueType)</span> </span>&#123;  </div><div class="line">      <span class="comment">//如果&lt;property&gt;没有使用Spring默认的命名空间，则使用用户自定义的规则解析//内嵌元素  </span></div><div class="line">      <span class="keyword">if</span> (!isDefaultNamespace(ele)) &#123;  </div><div class="line">          <span class="keyword">return</span> parseNestedCustomElement(ele, bd);  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//如果子元素是bean，则使用解析&lt;Bean&gt;元素的方法解析  </span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, BEAN_ELEMENT)) &#123;  </div><div class="line">          BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);  </div><div class="line">          <span class="keyword">if</span> (nestedBd != <span class="keyword">null</span>) &#123;  </div><div class="line">              nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);  </div><div class="line">          &#125;  </div><div class="line">          <span class="keyword">return</span> nestedBd;  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//如果子元素是ref，ref中只能有以下3个属性：bean、local、parent  </span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, REF_ELEMENT)) &#123;  </div><div class="line">          <span class="comment">//获取&lt;property&gt;元素中的bean属性值，引用其他解析的Bean的名称  </span></div><div class="line">          <span class="comment">//可以不再同一个Spring配置文件中，具体请参考Spring对ref的配置规则  </span></div><div class="line">          String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);  </div><div class="line">          <span class="keyword">boolean</span> toParent = <span class="keyword">false</span>;  </div><div class="line">          <span class="keyword">if</span> (!StringUtils.hasLength(refName)) &#123;  </div><div class="line">               <span class="comment">//获取&lt;property&gt;元素中的local属性值，引用同一个Xml文件中配置  </span></div><div class="line">               <span class="comment">//的Bean的id，local和ref不同，local只能引用同一个配置文件中的Bean  </span></div><div class="line">              refName = ele.getAttribute(LOCAL_REF_ATTRIBUTE);  </div><div class="line">              <span class="keyword">if</span> (!StringUtils.hasLength(refName)) &#123;  </div><div class="line">                  <span class="comment">//获取&lt;property&gt;元素中parent属性值，引用父级容器中的Bean  </span></div><div class="line">                  refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);  </div><div class="line">                  toParent = <span class="keyword">true</span>;  </div><div class="line">                  <span class="keyword">if</span> (!StringUtils.hasLength(refName)) &#123;  </div><div class="line">                      error(<span class="string">"'bean', 'local' or 'parent' is required for &lt;ref&gt; element"</span>, ele);  </div><div class="line">                      <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">                  &#125;  </div><div class="line">              &#125;  </div><div class="line">          &#125;  </div><div class="line">          <span class="comment">//没有配置ref的目标属性值  </span></div><div class="line">          <span class="keyword">if</span> (!StringUtils.hasText(refName)) &#123;  </div><div class="line">              error(<span class="string">"&lt;ref&gt; element contains empty target attribute"</span>, ele);  </div><div class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">          &#125;  </div><div class="line">          <span class="comment">//创建ref类型数据，指向被引用的对象  </span></div><div class="line">          RuntimeBeanReference ref = <span class="keyword">new</span> RuntimeBeanReference(refName, toParent);  </div><div class="line">          <span class="comment">//设置引用类型值是被当前子元素所引用  </span></div><div class="line">          ref.setSource(extractSource(ele));  </div><div class="line">          <span class="keyword">return</span> ref;  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//如果子元素是&lt;idref&gt;，使用解析ref元素的方法解析  </span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, IDREF_ELEMENT)) &#123;  </div><div class="line">          <span class="keyword">return</span> parseIdRefElement(ele);  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//如果子元素是&lt;value&gt;，使用解析value元素的方法解析  </span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, VALUE_ELEMENT)) &#123;  </div><div class="line">          <span class="keyword">return</span> parseValueElement(ele, defaultValueType);  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//如果子元素是null，为&lt;property&gt;设置一个封装null值的字符串数据  </span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, NULL_ELEMENT)) &#123;  </div><div class="line">          TypedStringValue nullHolder = <span class="keyword">new</span> TypedStringValue(<span class="keyword">null</span>);  </div><div class="line">          nullHolder.setSource(extractSource(ele));  </div><div class="line">          <span class="keyword">return</span> nullHolder;  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//如果子元素是&lt;array&gt;，使用解析array集合子元素的方法解析  </span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, ARRAY_ELEMENT)) &#123;  </div><div class="line">          <span class="keyword">return</span> parseArrayElement(ele, bd);  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//如果子元素是&lt;list&gt;，使用解析list集合子元素的方法解析  </span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, LIST_ELEMENT)) &#123;  </div><div class="line">          <span class="keyword">return</span> parseListElement(ele, bd);  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//如果子元素是&lt;set&gt;，使用解析set集合子元素的方法解析  </span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, SET_ELEMENT)) &#123;  </div><div class="line">          <span class="keyword">return</span> parseSetElement(ele, bd);  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//如果子元素是&lt;map&gt;，使用解析map集合子元素的方法解析  </span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, MAP_ELEMENT)) &#123;  </div><div class="line">          <span class="keyword">return</span> parseMapElement(ele, bd);  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//如果子元素是&lt;props&gt;，使用解析props集合子元素的方法解析  </span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nodeNameEquals(ele, PROPS_ELEMENT)) &#123;  </div><div class="line">          <span class="keyword">return</span> parsePropsElement(ele);  </div><div class="line">      &#125;  </div><div class="line">      <span class="comment">//既不是ref，又不是value，也不是集合，则子元素配置错误，返回null  </span></div><div class="line">      <span class="keyword">else</span> &#123;  </div><div class="line">          error(<span class="string">"Unknown property sub-element: ["</span> + ele.getNodeName() + <span class="string">"]"</span>, ele);  </div><div class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">      &#125;  </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这个方法很明白，就是根据子元素可能的属性进行判断，然后分别调用对应的方法进行解析。</p>
<p>下面以list的解析为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//解析&lt;list&gt;集合子元素  </span></div><div class="line">  <span class="function"><span class="keyword">public</span> List <span class="title">parseListElement</span><span class="params">(Element collectionEle, BeanDefinition bd)</span> </span>&#123;  </div><div class="line">      <span class="comment">//获取&lt;list&gt;元素中的value-type属性，即获取集合元素的数据类型  </span></div><div class="line">      String defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE);  </div><div class="line">      <span class="comment">//获取&lt;list&gt;集合元素中的所有子节点  </span></div><div class="line">      NodeList nl = collectionEle.getChildNodes();  </div><div class="line">      <span class="comment">//Spring中将List封装为ManagedList  </span></div><div class="line">      ManagedList&lt;Object&gt; target = <span class="keyword">new</span> ManagedList&lt;Object&gt;(nl.getLength());  </div><div class="line">      target.setSource(extractSource(collectionEle));  </div><div class="line">      <span class="comment">//设置集合目标数据类型  </span></div><div class="line">      target.setElementTypeName(defaultElementType);  </div><div class="line">      target.setMergeEnabled(parseMergeAttribute(collectionEle));  </div><div class="line">      <span class="comment">//具体的&lt;list&gt;元素解析  </span></div><div class="line">      parseCollectionElements(nl, target, bd, defaultElementType);  </div><div class="line">      <span class="keyword">return</span> target;  </div><div class="line">  &#125;   </div><div class="line">  <span class="comment">//具体解析&lt;list&gt;集合元素，&lt;array&gt;、&lt;list&gt;和&lt;set&gt;都使用该方法解析  </span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseCollectionElements</span><span class="params">(  </span></span></div><div class="line">          NodeList elementNodes, Collection&lt;Object&gt; target, BeanDefinition bd, String defaultElementType) &#123;  </div><div class="line">      <span class="comment">//遍历集合所有节点  </span></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elementNodes.getLength(); i++) &#123;  </div><div class="line">          Node node = elementNodes.item(i);  </div><div class="line">          <span class="comment">//节点不是description节点  </span></div><div class="line">          <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT)) &#123;  </div><div class="line">              <span class="comment">//将解析的元素加入集合中，递归调用下一个子元素  </span></div><div class="line">              target.add(parsePropertySubElement((Element) node, bd, defaultElementType));  </div><div class="line">          &#125;  </div><div class="line">      &#125;  </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>可以看出，这个方法返回的是一个List对象，而具体的类是Spring定义的ManagedList，作为封装List这类配置定义的数据封装。</p>
<p>这应该是最后一层了，至此，Spring IoC现在已经将XML形式定义的Bean定义资源文件转换为Spring IoC所识别的数据结构——BeanDefinition，它是Bean定义资源文件中配置的POJO对象在Spring IoC容器中的映射，我们可以通过AbstractBeanDefinition为入口，让IoC容器进行索引、查询和操作。</p>
<p>通过Spring IoC容器对Bean定义资源的解析后，IoC容器大致完成了管理Bean对象的准备工作，即初始化过程，但是最为重要的依赖注入还没有发生，现在在IoC容器中BeanDefinition存储的只是一些静态信息，接下来需要向容器注册Bean定义信息才能全部完成IoC容器的初始化过程</p>
<h2 id="4、BeanDefinition的注册"><a href="#4、BeanDefinition的注册" class="headerlink" title="4、BeanDefinition的注册"></a>4、BeanDefinition的注册</h2><p>在3.2的DefaultBeanDefinitionDocumentReader类中提到，在完成解析之后，就会将这个BeanDefinitionHolder对象作为参数调用BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry())方法，来启动注册的过程。</p>
<p>下面来看一下这个registerBeanDefinition方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将解析的BeanDefinitionHold注册到容器中 </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span>  </span></div><div class="line">    <span class="keyword">throws</span> BeanDefinitionStoreException &#123;  </div><div class="line">        <span class="comment">//获取解析的BeanDefinition的名称</span></div><div class="line">         String beanName = definitionHolder.getBeanName();  </div><div class="line">        <span class="comment">//向IoC容器注册BeanDefinition </span></div><div class="line">        registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());  </div><div class="line">        <span class="comment">//如果解析的BeanDefinition有别名，向容器为其注册别名  </span></div><div class="line">         String[] aliases = definitionHolder.getAliases();  </div><div class="line">        <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="keyword">for</span> (String aliase : aliases) &#123;  </div><div class="line">                registry.registerAlias(beanName, aliase);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当调用BeanDefinitionReaderUtils向IoC容器注册解析的BeanDefinition时，真正完成注册功能的是DefaultListableBeanFactory。在DefaultListableBeanFactory中，是通过一个ConcurrentHashMap来持有这个BeanDefinition的，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Map of bean definition objects, keyed by bean name */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</div></pre></td></tr></table></figure>
<h3 id="4-1、DefaultListableBeanFactory"><a href="#4-1、DefaultListableBeanFactory" class="headerlink" title="4.1、DefaultListableBeanFactory"></a>4.1、DefaultListableBeanFactory</h3><p>下面就是具体的注册过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//存储注册的俄BeanDefinition  </span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, BeanDefinition&gt;();  </div><div class="line">   <span class="comment">//向IoC容器注册解析的BeanDefiniton  </span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span>  </span></div><div class="line">           <span class="keyword">throws</span> BeanDefinitionStoreException &#123;  </div><div class="line">       Assert.hasText(beanName, <span class="string">"Bean name must not be empty"</span>);  </div><div class="line">       Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);  </div><div class="line">       <span class="comment">//校验解析的BeanDefiniton  </span></div><div class="line">       <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;  </div><div class="line">           <span class="keyword">try</span> &#123;  </div><div class="line">               ((AbstractBeanDefinition) beanDefinition).validate();  </div><div class="line">           &#125;  </div><div class="line">           <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;  </div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,  </div><div class="line">                       <span class="string">"Validation of bean definition failed"</span>, ex);  </div><div class="line">           &#125;  </div><div class="line">       &#125;  </div><div class="line">       <span class="comment">//注册的过程中需要线程同步，以保证数据的一致性  </span></div><div class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;  </div><div class="line">           Object oldBeanDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);  </div><div class="line">           <span class="comment">//检查是否有同名的BeanDefinition已经在IoC容器中注册，如果已经注册，并且不允许覆盖已注册的Bean，则抛出注册失败异常  </span></div><div class="line">           <span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span>) &#123;  </div><div class="line">               <span class="keyword">if</span> (!<span class="keyword">this</span>.allowBeanDefinitionOverriding) &#123;  </div><div class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,  </div><div class="line">                           <span class="string">"Cannot register bean definition ["</span> + beanDefinition + <span class="string">"] for bean '"</span> + beanName +  </div><div class="line">                           <span class="string">"': There is already ["</span> + oldBeanDefinition + <span class="string">"] bound."</span>);  </div><div class="line">               &#125;  </div><div class="line">               <span class="keyword">else</span> &#123;<span class="comment">//如果允许覆盖，则同名的Bean，后注册的覆盖先注册的  </span></div><div class="line">                   <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;  </div><div class="line">                       <span class="keyword">this</span>.logger.info(<span class="string">"Overriding bean definition for bean '"</span> + beanName +  </div><div class="line">                               <span class="string">"': replacing ["</span> + oldBeanDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);  </div><div class="line">                   &#125;  </div><div class="line">               &#125;  </div><div class="line">           &#125;  </div><div class="line">           <span class="comment">//IoC容器中没有已经注册同名的Bean，按正常注册流程注册  </span></div><div class="line">           <span class="keyword">else</span> &#123;  </div><div class="line">               <span class="keyword">this</span>.beanDefinitionNames.add(beanName);  </div><div class="line">               <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;  </div><div class="line">           &#125;  </div><div class="line">           <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);  </div><div class="line">           <span class="comment">//重置所有已经注册过的BeanDefinition的缓存  </span></div><div class="line">           resetBeanDefinition(beanName);  </div><div class="line">       &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>至此，Bean定义资源文件中配置的Bean被解析过后，已经注册到IoC容器中，被容器管理起来，真正完成了IoC容器初始化所做的全部工作。现在IoC容器中已经建立了整个Bean的配置信息，这些BeanDefinition信息已经可以使用，并且可以被检索，IoC容器的作用就是对这些注册的Bean定义信息进行处理和维护。这些的注册的Bean定义信息是IoC容器控制反转的基础，正是有了这些注册的数据，容器才可以进行依赖注入。</p>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>这篇源码分析应该是我用时最长的一篇，因为实在是太复杂了，写到这里最上面的已经有些记不清了，不知道再过几天还能记住多少，不过确实收获了很多东西</p>
<ol>
<li>开始最难的就是各个类定义的比较多，找不到对应的关系，但是弄明白以后发现这样多层的继承关系有着很强的可扩展性，学到了一个设计模式就是模版模式，在父类中定义好整体流程，具体的方法留在各个不同的子类中实现，各种不同资源的定位就是用的这个思想</li>
<li>载入和解析过程主要就是XML文件的解析，这里又学习了Java中XML文件的解析方法，DOM和SAX两种方法的区别，Spring中用的是JAXP的方法，而不是很有名的JDOM或者DOM4J。</li>
<li>其他就是明白了整个bean从定义，到变成容器中数据结构的整体流程</li>
<li>学习是一个厚积薄发的过程，开始的时候先不要看一些超出自己能力太多的东西，比如从刚开学的时候就想学Spring的源码，看了Spring技术内幕和很多博客，但是怎么看都看不懂。过了半个学期以后基本能勉强看懂了，当然，和Spring技术内幕这本书排版太乱也有一定关系</li>
<li>主要参考的还是<a href="http://www.cnblogs.com/ITtangtang/p/3978349.html" target="_blank" rel="external">http://www.cnblogs.com/ITtangtang/p/3978349.html</a>这篇博客，感谢作者。</li>
</ol>
<h1 id="四、参考地址"><a href="#四、参考地址" class="headerlink" title="四、参考地址"></a>四、参考地址</h1><p><a href="http://blog.csdn.net/randyjiawenjie/article/details/8315861" target="_blank" rel="external">http://blog.csdn.net/randyjiawenjie/article/details/8315861</a></p>
<p><a href="http://elim.iteye.com/blog/2016305" target="_blank" rel="external">http://elim.iteye.com/blog/2016305</a></p>
<p><a href="http://www.blogjava.net/DLevin/archive/2012/12/01/392337.html" target="_blank" rel="external">http://www.blogjava.net/DLevin/archive/2012/12/01/392337.html</a></p>
<p><a href="http://www.cnblogs.com/chenssy/p/5619170.html" target="_blank" rel="external">http://www.cnblogs.com/chenssy/p/5619170.html</a></p>
<p><a href="http://www.cnblogs.com/ITtangtang/p/3978349.html" target="_blank" rel="external">http://www.cnblogs.com/ITtangtang/p/3978349.html</a></p>
<p><a href="https://my.oschina.net/kaywu123/blog/614325" target="_blank" rel="external">https://my.oschina.net/kaywu123/blog/614325</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java的Concurrent包]]></title>
      <url>http://yoursite.com/2016/12/27/MultiThreading/Java%E4%B8%AD%E7%9A%84Concurrent%E5%8C%85/</url>
      <content type="html"><![CDATA[<p>Java 5 添加了一个新的包到 Java 平台，java.util.concurrent 包。这个包包含有一系列能够让 Java 的并发编程变得更加简单轻松的类。包中内容大致有下面一些：</p>
<ul>
<li>atomic文件夹：里面包含了一系列的基本数据类型对应的原子类比如AtomicInteger</li>
<li>locks文件夹：里面包含了显示锁Lock和相关的Condition、ReentrantLock类、读写锁ReentrantReadWriteLock类和很多同步工具都使用的AQS即AbstractQueuedLongSynchronizer类</li>
<li>同步容器类：<ul>
<li>写时复制队列：CopyOnWriteArrayList</li>
<li>阻塞队列：BlockingQueue类</li>
<li>HashMap:ConcurrentHashMap</li>
</ul>
</li>
<li>同步工具类：<ul>
<li>闭锁：CountDownLatch</li>
<li>信号量：Semaphore</li>
<li>栅栏：CyclicBarrier</li>
</ul>
</li>
</ul>
<h1 id="一、同步工具类"><a href="#一、同步工具类" class="headerlink" title="一、同步工具类"></a>一、同步工具类</h1><h2 id="1、CountDownLatch"><a href="#1、CountDownLatch" class="headerlink" title="1、CountDownLatch"></a>1、CountDownLatch</h2><p>在多线程程序设计中，经常会遇到一个线程等待一个或多个线程的场景</p>
<ul>
<li>如果是一个线程等待一个线程，则可以通过wait()和notify()来实现；</li>
<li>如果是一个线程等待多个线程，则就可以使用CountDownLatch和CyclicBarrier来实现比较好的控制。</li>
</ul>
<p>CountDownLatch是一种灵活实现的闭锁，在Java中的实现类为java.util.concurrent.CountDownLatch</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">timeTasks</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">final</span> Runnable task)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">final</span> java.util.concurrent.CountDownLatch startGate=<span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">        <span class="keyword">final</span> CountDownLatch endGate=<span class="keyword">new</span> CountDownLatch(n);</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</div><div class="line">            Thread t=<span class="keyword">new</span> Thread()&#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        startGate.await();<span class="comment">//所有线程都要先等待，然后统一开始执行</span></div><div class="line">                        <span class="keyword">try</span>&#123;</div><div class="line">                            task.run();</div><div class="line">                        &#125;<span class="keyword">finally</span>&#123;<span class="comment">//latch.countDown()建议放在finally里面执行</span></div><div class="line">                            endGate.countDown();<span class="comment">//执行之后count-，知道为0，代表所有线程执行完毕</span></div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            t.start();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> start=System.nanoTime();</div><div class="line">        startGate.countDown();<span class="comment">//统一开始执行</span></div><div class="line">        endGate.await();<span class="comment">//等待所有线程执行完毕</span></div><div class="line">        <span class="keyword">long</span> end=System.nanoTime();</div><div class="line">        <span class="keyword">return</span> end-start;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2、CycleBarrier"><a href="#2、CycleBarrier" class="headerlink" title="2、CycleBarrier"></a>2、CycleBarrier</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">        <span class="keyword">private</span> CyclicBarrier barrier;		</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(CyclicBarrier barrier)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.barrier=barrier;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span>&#123;</div><div class="line">                System.out.println(<span class="string">"worker is waiting"</span>);</div><div class="line">                barrier.await();</div><div class="line">                System.out.println(<span class="string">"ID:"</span>+Thread.currentThread().getId()+<span class="string">" Working"</span>);</div><div class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        CyclicBarrier barrier=<span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, <span class="keyword">new</span> Runnable()&#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"Inseide barrier"</span>);				</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(barrier)).start();</div><div class="line">        &#125;		</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>CyclicBarrier初始化时规定一个数目，然后计算调用了CyclicBarrier.await()进入等待的线程数。当线程数达到了这个数目时，所有进入等待状态的线程被唤醒并继续。 </li>
<li>CyclicBarrier就象它名字的意思一样，可看成是个障碍， 所有的线程必须到齐后才能一起通过这个障碍。 </li>
<li>CyclicBarrier初始时还可带一个Runnable的参数， 此Runnable任务在CyclicBarrier的数目达到后，所有其它线程被唤醒前被执行。</li>
</ol>
<h3 id="CountDownLatch与CyclicBarrier比较"><a href="#CountDownLatch与CyclicBarrier比较" class="headerlink" title="CountDownLatch与CyclicBarrier比较"></a>CountDownLatch与CyclicBarrier比较</h3><ol>
<li>CountDownLatch是一次性的，而CyclicBarrier在调用reset之后还可以继续使用。</li>
<li>CountDownLatch是一个线程等待N个线程全部完成(计数为0)，这个线程才可以继续执行。</li>
<li>CyclicBarrier是多个线程之间相互等待，所有线程都完成了(到达初始化时指定的数值)，再一起继续执行。</li>
</ol>
<h2 id="3、Semaphore"><a href="#3、Semaphore" class="headerlink" title="3、Semaphore"></a>3、Semaphore</h2><p>Java中实现计数信号量的类为java.util.concurrent.Semaphore，是在1.5中引入的。</p>
<ul>
<li>Semaphore中管理着一组许可，许可的初始数量可以通过构造方法来指定。</li>
<li>在执行操作时需要先获得许可（acquire），并在使用完后释放许可（release）。</li>
<li>如果当前没有许可，那么acquire将阻塞下到有许可可用，或者直到被中断，或者操作超时。</li>
<li>当初始值为1时，该信号量就可以实现互斥锁的功能。</li>
</ul>
<p>Semaphore可以用于实现资源池，例如数据库的连接池。可以构建一个固定长度的资源池，当池为空时，请求资源就会失败，但Semaphore可以实现阻塞而非失败，并且当资源非空时接触阻塞。</p>
<p>可以使用Semaphore将任何容器变成有界的阻塞容器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedList</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;T&gt; list;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore semaphore;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedList</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;  </div><div class="line">        list = Collections.synchronizedList(<span class="keyword">new</span> LinkedList&lt;T&gt;());  </div><div class="line">        semaphore = <span class="keyword">new</span> Semaphore(bound);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T obj)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </div><div class="line">        semaphore.acquire();  </div><div class="line">        <span class="keyword">boolean</span> addedFlag = <span class="keyword">false</span>;  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            addedFlag = list.add(obj);  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">finally</span> &#123;  </div><div class="line">            <span class="keyword">if</span> (!addedFlag) &#123;  </div><div class="line">                semaphore.release();  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> addedFlag;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object obj)</span> </span>&#123;  </div><div class="line">        <span class="keyword">boolean</span> removedFlag = list.remove(obj);  </div><div class="line">        <span class="keyword">if</span> (removedFlag) &#123;  </div><div class="line">            semaphore.release();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> removedFlag;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="二、AbstractQueuedSynchronizer类"><a href="#二、AbstractQueuedSynchronizer类" class="headerlink" title="二、AbstractQueuedSynchronizer类"></a>二、AbstractQueuedSynchronizer类</h1><p>上面介绍的几个类，他们在实现的时候都用到了一个共同的基类，就是AbstractQueuedSynchronizer（AQS）类。</p>
<p>ReentrantLock、ReentrantReadWriteLock、Semaphore、CountDownLatch、FuturTask等类都使用到了这个类。</p>
<p>他们都有各自获取锁的方法，同时相对于Java的内置锁，他们具有明显的优势：花最小的空间开销创建锁、最少的时间开销获得锁、使用更加方便灵活。</p>
<p>AQS解决了再实现同步器时涉及的大量细节问题，例如等待线程采用FIFO队列操作顺序。</p>
<p>在基于AQS的同步器类中，最基本的操作暴多各种形式的<strong>获取操作</strong>和<strong>释放操作</strong>。</p>
<p>下面是书中给出的AQS中获取操作与释放操作的形式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">acauire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</div><div class="line">    <span class="keyword">while</span>(当前状态不允许获取操作)&#123;</div><div class="line">        <span class="keyword">if</span>(需要阻塞获取操作)&#123;</div><div class="line">            如果当前县城不在队列中，则将其插入队列中</div><div class="line">            阻塞当前线程</div><div class="line">        &#125;<span class="keyword">else</span></div><div class="line">            返回失败</div><div class="line">    &#125;</div><div class="line">    可能更新同步器的状态</div><div class="line">    如果线程位于队列中，则将移出队列</div><div class="line">    返回成功</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>&#123;</div><div class="line">    更新同步器状态</div><div class="line">    <span class="keyword">if</span>(新的状态允许某个被阻塞的线程获取成功)&#123;</div><div class="line">        解除队列中一个或多个线程的阻塞状态</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>发现await、signal方法的使用就是以这个为基础的。每个同步类中都可以看到一个内部类继承自AQS。</p>
<h1 id="三、参考地址"><a href="#三、参考地址" class="headerlink" title="三、参考地址"></a>三、参考地址</h1><p><a href="http://www.cnblogs.com/techyc/archive/2013/03/13/2957059.html" target="_blank" rel="external">http://www.cnblogs.com/techyc/archive/2013/03/13/2957059.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ThreadLocal实现与使用]]></title>
      <url>http://yoursite.com/2016/12/26/MultiThreading/ThreadLocal%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>看了网上的博客发现对这个类的作用争议比较大，于是自己看了源码，比较认同的说法是：</p>
<blockquote>
<p>This class provides thread-local variables. These variables differ from<br>their normal counterparts in that each thread that accesses one (via its<br>{@code get} or {@code set} method) has its own, independently initialized<br>copy of the variable. {@code ThreadLocal} instances are typically private<br>static fields in classes that wish to associate state with a thread (e.g.,<br>a user ID or Transaction ID).</p>
</blockquote>
<p>可以总结为一句话：<strong>ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。</strong></p>
<h1 id="一、基本操作"><a href="#一、基本操作" class="headerlink" title="一、基本操作"></a>一、基本操作</h1><h2 id="1、构造函数"><a href="#1、构造函数" class="headerlink" title="1、构造函数"></a>1、构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadLocal</span><span class="params">()</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>没有任何实现</p>
<h2 id="2、initialValue方法"><a href="#2、initialValue方法" class="headerlink" title="2、initialValue方法"></a>2、initialValue方法</h2><p>用来设置当前线程的初始值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>默认返回的是null，声明为protect说明为了让子类重写，一般自己定义的都会重写这个方法来设置初始值。</p>
<p>通常该方法只会被调用一次</p>
<ul>
<li>在调用get方法的时候会第一次调用</li>
<li>如果开始就调用了set方法，那么该方法就不会被调用</li>
<li>在remove方法之后还会重复上面两条原则</li>
</ul>
<h2 id="3、get方法"><a href="#3、get方法" class="headerlink" title="3、get方法"></a>3、get方法</h2><p>返回当前线程的ThreadLocal值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">///</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4、set方法"><a href="#4、set方法" class="headerlink" title="4、set方法"></a>4、set方法</h2><p>用于设置当前线程的ThreadLocal值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">  <span class="comment">///</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="5、remove方法"><a href="#5、remove方法" class="headerlink" title="5、remove方法"></a>5、remove方法</h2><p>用来将当前线程的ThreadLocal绑定的值删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在某些情况下需要手动调用该方法，防止内存泄露。</p>
<h2 id="6、使用示例"><a href="#6、使用示例" class="headerlink" title="6、使用示例"></a>6、使用示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; value=<span class="keyword">new</span> ThreadLocal&lt;Integer&gt;()&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;		</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> id;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.id=id;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">            System.out.println(<span class="string">"线程: "</span>+id+<span class="string">"初始值： "</span>+value.get());</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</div><div class="line">                value.set(value.get()+<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">"线程: "</span>+id+<span class="string">"累加值： "</span>+value.get());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(i)).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">线程: 1初始值： 0</div><div class="line">线程: 2初始值： 0</div><div class="line">线程: 0初始值： 0</div><div class="line">线程: 2累加值： 10</div><div class="line">线程: 1累加值： 10</div><div class="line">线程: 0累加值： 10</div></pre></td></tr></table></figure>
<p>总结了一下发现其实这个类就是相当于定义一个变量，以上面的为例</p>
<p>如果直接定义一个Integer value变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Integer value=<span class="keyword">new</span> Integer(<span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>那么所有线程就可以共享这个变量了。</p>
<p>而如果想把这个变量设置为线程间内的局部变量，就可以</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; value=<span class="keyword">new</span> ThreadLocal&lt;Integer&gt;()&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;		</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其实都是定义了一个初始值为0的变量，只不过作用域不同而已。</p>
<h1 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h1><p>关于内部实现网上有很多争议，最开始理解的版本可能比较容易</p>
<blockquote>
<p>每个ThreadLocal类创建一个Map，然后用线程的ID作为Map的key，实例对象作为Map的value，这样就能达到各个线程的值隔离的效果。</p>
</blockquote>
<p>不知道早期的类是不是这么实现的，但是在JDK8中的源码确实不是这样实现的。</p>
<h2 id="1、get"><a href="#1、get" class="headerlink" title="1、get"></a>1、get</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">//1、get方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">       Thread t = Thread.currentThread();<span class="comment">//获取当前线程</span></div><div class="line">       ThreadLocalMap map = getMap(t);<span class="comment">//根据当前线程获取ThreadLocalMap，调用了getMap方法</span></div><div class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;<span class="comment">//map不为空</span></div><div class="line">           ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</div><div class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;<span class="comment">//且在map中以ThreadLocal对象为key的值不为空</span></div><div class="line">               <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">               T result = (T)e.value;</div><div class="line">               <span class="keyword">return</span> result;<span class="comment">//返回</span></div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> setInitialValue();<span class="comment">//如果map为空或e为空，说明是第一次get，肯定会返回设定的初始值，则调用setInitialValue方法</span></div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="comment">//2、getMap方法</span></div><div class="line">   <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> t.threadLocals;<span class="comment">//返回当前线程的threadLocals</span></div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="comment">//3、setInitialValue方法</span></div><div class="line">   <span class="keyword">private</span> T setInitialValue方法() &#123;</div><div class="line">       T value = initialValue();<span class="comment">//获取设置的初始值</span></div><div class="line">       Thread t = Thread.currentThread();<span class="comment">//获取当前线程</span></div><div class="line">       ThreadLocalMap map = getMap(t);<span class="comment">//再次获取当前线程的ThreadLocalMap</span></div><div class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>)<span class="comment">//如果mao已经存在，则设置初始值</span></div><div class="line">           map.set(<span class="keyword">this</span>, value);</div><div class="line">       <span class="keyword">else</span><span class="comment">//没有map就创建，调用createMap方法</span></div><div class="line">           createMap(t, value);</div><div class="line">       <span class="keyword">return</span> value;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="comment">//4、createMap方法</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</div><div class="line">       t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 下面是Thread类的源码</div><div class="line"> */</div><div class="line"></div><div class="line">   <span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></div><div class="line">    * by the ThreadLocal class. */</div><div class="line">   ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</div></pre></td></tr></table></figure>
<p>可以看出整个get方法的流程：</p>
<ol>
<li>首先获取当前线程</li>
<li>根据当前线程获取一个Map</li>
<li>如果获取的Map不为空，则在Map中以ThreadLocal的引用作为key来在Map中获取对应的value e，否则转到5</li>
<li>如果e不为null，则返回e.value，否则转到5</li>
<li>Map为空或者e为空，则通过initialValue方法获取初始值value，然后用ThreadLocal的引用和value作为firstKey和firstValue创建一个新的Map</li>
</ol>
<h2 id="2、设计思路"><a href="#2、设计思路" class="headerlink" title="2、设计思路"></a>2、设计思路</h2><p>从上面的分析可以看出，ThreadLocl的设计思路是和随开始理解的相反的，是以线程为单位去维护一个map，而吧ThreadLocl当做key，而这个map是ThreadLocal的一个内部类ThreadLocalMap</p>
<ol>
<li>Thread类中有一个ThreadLocal.ThreadLocalMap变量threadLocals，用于维护这个线程的所有ThreadLocal变量</li>
<li>每次获取某个ThreadLocal变量时，都会获取当前线程的map</li>
<li>在map中，ThreadLocal变量作为key去查找，如果不存在，就根据设置的初始值去初始化</li>
</ol>
<p>这样做的好处在于：</p>
<ol>
<li>这样设计之后每个Map的Entry数量变小了：之前是Thread的数量，现在是ThreadLocal的数量，能提高性能，据说性能的提升不是一点两点(没有亲测)</li>
<li>当Thread销毁之后对应的ThreadLocalMap也就随之销毁了，能减少内存使用量。</li>
</ol>
<h2 id="3、ThreadLocalMap"><a href="#3、ThreadLocalMap" class="headerlink" title="3、ThreadLocalMap"></a>3、ThreadLocalMap</h2><p>ThreadLocalMap是ThreadL的一个内部类，关于它有一点就是它的Entry是一个弱引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The entries in this hash map extend WeakReference, using</div><div class="line">     * its main ref field as the key (which is always a</div><div class="line">     * ThreadLocal object).  Note that null keys (i.e. entry.get()</div><div class="line">     * == null) mean that the key is no longer referenced, so the</div><div class="line">     * entry can be expunged from table.  Such entries are referred to</div><div class="line">     * as "stale entries" in the code that follows.</div><div class="line">     */</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</div><div class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></div><div class="line">        Object value;</div><div class="line"></div><div class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</div><div class="line">            <span class="keyword">super</span>(k);</div><div class="line">            value = v;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  <span class="comment">///</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于引用的四种类型已经介绍过，弱引用面临着随时被GC的风险.</p>
<p>从上面代码可以看出，Entry是继承WeakReference。即Entry实例本质上就是对ThreadLocal对象的弱引用。只不过，Entry同时还保存了value。</p>
<p> <img src="https://github.com/paine1690/HelloWorld/blob/master/pic/MultiThreading/1.png?raw=true" alt="ThreadLocal"></p>
<p>所以关于ThreadLocal印发内存泄漏的说法</p>
<blockquote>
<p>如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：<br><strong>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</strong><br>永远无法回收，造成内存泄露。</p>
</blockquote>
<p>但是ThreadLocal在设计的时候会避免这个的发生</p>
<ol>
<li>首先从ThreadLocal的直接索引位置(通过ThreadLocal.threadLocalHashCode &amp; (len-1)运算得到)获取Entry e，如果e不为null并且key相同则返回e；</li>
<li>如果e为null或者key不一致则向下一个位置查询，如果下一个位置的key和当前需要查询的key相等，则返回对应的Entry，否则，如果key值为null，则擦除该位置的Entry，否则继续向下一个位置查询</li>
</ol>
<p><strong>在这个过程中遇到的key为null的Entry都会被擦除</strong> </p>
<p>上面的设计思路依赖一个前提条件：<strong>要调用ThreadLocalMap的getEntry方法或者set方法。</strong>这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的remove方法，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成private static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。</p>
<h1 id="三、ThreadLocal在Spring中的应用"><a href="#三、ThreadLocal在Spring中的应用" class="headerlink" title="三、ThreadLocal在Spring中的应用"></a>三、ThreadLocal在Spring中的应用</h1><h2 id="1、应用"><a href="#1、应用" class="headerlink" title="1、应用"></a>1、应用</h2><p>在网上看了N篇博客说明ThreadLocal在Spring中的应用，发现都是出自一处的，不知道是谁转载谁。</p>
<p>在此主要引用参考地址中第三个的博客</p>
<blockquote>
<p>ThreadLocal在Spring中发挥着重要的作用，在管理request作用域的Bean、事务管理、任务调度、AOP等模块都出现了它们的身影，起着举足轻重的作用。</p>
</blockquote>
<p>举例子比较多的（没见过其他例子）就是Spring的DAO模版。</p>
<blockquote>
<p>我们知道Spring通过各种模板类降低了开发者使用各种数据持久技术的难度。这些模板类都是线程安全的，也就是说，多个DAO可以复用同一个模板实例而不会发生冲突。我们使用模板类访问底层数据，根据持久化技术的不同，模板类需要绑定数据连接或会话的资源。但这些资源本身是非线程安全的，也就是说它们不能在同一时刻被多个线程共享。虽然模板类通过资源池获取数据连接或会话，但资源池本身解决的是数据连接或会话的缓存问题，并非数据连接或会话的线程安全问题。 </p>
</blockquote>
<p>按照传统经验，如果某个对象是非线程安全的，在多线程环境下，对对象的访问必须采用synchronized进行线程同步。但模板类并未采用线程同步机制，因为线程同步会降低并发性，影响系统性能。此外，通过代码同步解决线程安全的挑战性很大，可能会增强好几倍的实现难度。那么模板类究竟仰仗何种魔法神功，可以在无须线程同步的情况下就化解线程安全的难题呢？<strong>答案就是ThreadLocal！</strong></p>
<h2 id="2、举例"><a href="#2、举例" class="headerlink" title="2、举例"></a>2、举例</h2><p>TopicDao：非线程安全 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicDao</span> </span>&#123;  </div><div class="line">   <span class="comment">//①一个非线程安全的变量  </span></div><div class="line">   <span class="keyword">private</span> Connection conn;   </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTopic</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="comment">//②引用非线程安全变量  </span></div><div class="line">       Statement stat = conn.createStatement();  </div><div class="line">       …  </div><div class="line">   &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于①处的conn是成员变量，因为addTopic()方法是非线程安全的，必须在使用时创建一个新TopicDao实例（非singleton）。下面使用ThreadLocal对conn这个非线程安全的“状态”进行改造： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopicDao</span> </span>&#123;  </div><div class="line">     <span class="comment">//①使用ThreadLocal保存Connection变量  </span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;();  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>&#123; 	           </div><div class="line">        <span class="comment">//②如果connThreadLocal没有本线程对应的Connection创建一个新的Connection，  </span></div><div class="line">        <span class="comment">//并将其保存到线程本地变量中。  </span></div><div class="line">        <span class="keyword">if</span>(connThreadLocal.get()==<span class="keyword">null</span>)&#123;  </div><div class="line">            Connection conn=ConnectionManager.getConnection();  </div><div class="line">            connThreadLocal.set(conn);  </div><div class="line">            <span class="keyword">return</span> conn;  </div><div class="line">        &#125;<span class="keyword">else</span>&#123;  </div><div class="line">            <span class="comment">//③直接返回线程本地变量  </span></div><div class="line">            <span class="keyword">return</span> connThreadLocal.get();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTopic</span><span class="params">()</span> </span>&#123;  	  </div><div class="line">        <span class="comment">//④从ThreadLocal中获取线程对应的  </span></div><div class="line">        Statement stat = getConnection().createStatement();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是网上的版本，而我觉得可以通过重写初始化方法来直接新建Connection，不需要你们麻烦</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopicDao</span> </span>&#123;  </div><div class="line">     <span class="comment">//①使用ThreadLocal保存Connection变量,重写初始化方法</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;()&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> Connection <span class="title">initialValue</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> ConnectionManager.getConnection();  </div><div class="line">        &#125;</div><div class="line">    &#125;;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>&#123; </div><div class="line">        <span class="keyword">return</span> connThreadLocal.get();  </div><div class="line">        </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTopic</span><span class="params">()</span> </span>&#123;  	  </div><div class="line">        <span class="comment">//④从ThreadLocal中获取线程对应的  </span></div><div class="line">        Statement stat = getConnection().createStatement();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，就保证了不同的线程使用线程相关的Connection，而不会使用其他线程的Connection。因此，这个TopicDao就可以做到singleton共享了。 </p>
<p>当然，这个例子本身很粗糙，将Connection的ThreadLocal直接放在Dao只能做到本Dao的多个方法共享Connection时不发生线程安全问题，但无法和其他Dao共用同一个Connection，要做到同一事务多Dao共享同一个Connection，必须在一个共同的外部类使用ThreadLocal保存Connection。但这个实例基本上说明了Spring对有状态类线程安全化的解决思路。在本章后面的内容中，我们将详细说明Spring如何通过ThreadLocal解决事务管理的问题。 </p>
<h2 id="3、Spring源码中的实现"><a href="#3、Spring源码中的实现" class="headerlink" title="3、Spring源码中的实现"></a>3、Spring源码中的实现</h2><p>在Spring技术内幕第五章中，找到了关于JdbcTemplete类的实现，由于源码较多，没有完全分析。但是可以发现内部实现确实是使用了ThreadLocal的。</p>
<ol>
<li><p>在JdbcTemplete.excute方法中，获取Connection的代码为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这里取得数据库的Connection，这个数据库的Connection已经在Spring的事务管理之下</span></div><div class="line">Connection con = DataSourceUtils.getConnection(getDatasource());</div></pre></td></tr></table></figure>
</li>
<li><p>DataSourceUtils是一个辅助类，Spring通过这个辅助类来对数据的Connection进行管理，比如利用它来完成打开和关闭Connection等。</p>
</li>
<li><p>在DataSourceUtils类中，实现了Connection的相关处理，也可以看见Connection和当前线程的绑定，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*把对数据库的Connection放到事务管理器中进行管理，这里使用TransactionSynchronizationManager中定义的ThreadLocal变量来和线程绑定数据库连接*/</span></div><div class="line">ConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>下面就是对conHolder的操作了。</p>
<p>如果在TransactionSynchronizationManager中已经有了与当前线程绑定的数据库连接，那就直接取出来使用。</p>
<p>不然就新打开一个数据库的Connection，并通过TransactionSynchronizationManager和当前线程绑定起来。</p>
<p>可以看出，基本与上面的例子思路一致，只不过实现起来更复杂。</p>
<h1 id="四、参考地址"><a href="#四、参考地址" class="headerlink" title="四、参考地址"></a>四、参考地址</h1><p><a href="http://qifuguang.me/2015/09/02/[Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83]%E8%A7%A3%E5%AF%86ThreadLocal/" target="_blank" rel="external">http://qifuguang.me/2015/09/02/[Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83]%E8%A7%A3%E5%AF%86ThreadLocal/</a></p>
<p><a href="http://www.jianshu.com/p/27e309e1d0f5" target="_blank" rel="external">http://www.jianshu.com/p/27e309e1d0f5</a></p>
<p><a href="http://www.iteye.com/topic/1123824" target="_blank" rel="external">http://www.iteye.com/topic/1123824</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[进程与线程]]></title>
      <url>http://yoursite.com/2016/12/23/OperatingSystem/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>进程与线程是经常一起出现的概念，面试过程中也经常被问到</p>
<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="1、进程"><a href="#1、进程" class="headerlink" title="1、进程"></a>1、进程</h2><p>进程是具有一定独立功能的程序、它是系统进行资源分配和调度的一个独立单位，重点在系统调度和单独的单位，也就是说进程是可以独立运行的一段程序。</p>
<h2 id="2、线程"><a href="#2、线程" class="headerlink" title="2、线程"></a>2、线程</h2><p>线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源。</p>
<h2 id="3、进程与线程的关系"><a href="#3、进程与线程的关系" class="headerlink" title="3、进程与线程的关系"></a>3、进程与线程的关系</h2><p>从Java的角度讲，一个虚拟机就是一个进程，但是里面可以包含很多的线程。</p>
<ol>
<li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程（通常说的主线程）。</li>
<li>资源分配给进程，同一进程的所有线程共享该进程的所有资源。</li>
<li>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</li>
<li>线程是指进程内的一个执行单元，也是进程内的可调度实体。 </li>
</ol>
<p>换个角度来理解他们之间的区别：</p>
<ol>
<li>调度：线程是<strong>CPU调度和分配</strong>的基本单位，进程是<strong>拥有资源</strong>的基本单位。</li>
<li>并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行。</li>
<li>拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。</li>
</ol>
<h1 id="二、线程间通信方法"><a href="#二、线程间通信方法" class="headerlink" title="二、线程间通信方法"></a>二、线程间通信方法</h1><p>关于线程间通信方式有很多种说法，我觉得比较合理的是</p>
<ol>
<li>wait、notify机制</li>
<li>await、signal机制</li>
<li>管道</li>
</ol>
<h2 id="1、wait、notify"><a href="#1、wait、notify" class="headerlink" title="1、wait、notify"></a>1、wait、notify</h2><p>这两个方法的使用已经分析过，这两个方法的关键就是一个对象的锁和某个条件。</p>
<ul>
<li>多个线程之间通过持有同一个对象锁来形成某种联系，并且同时只有一个线程能够持有锁</li>
<li>当一个线程持有锁时，检测是否满足某个条件，如果不满足，那么就释放这个锁，开始等待</li>
<li>如果这个条件满足了，就执行自己的操作并且在执行完成之后再释放锁并且通知其他正在等待的线程</li>
</ul>
<p>这样通过notify方法来实现对特定线程之间的通信。</p>
<h2 id="2、await、signal"><a href="#2、await、signal" class="headerlink" title="2、await、signal"></a>2、await、signal</h2><p>这两个方法也介绍过，他们是Thread类中的方法，是上面两个的升级版。</p>
<p>上面说到的对象锁，对象锁的作用就是是把所有持有这个锁的线程划到同一个集合，使这些线程之间可以相互通信。但是这样有一个弊端就是一旦通知就会通知该集合内的所有线程，而显示锁的这个机制则可以通过Condition把这个集合再划分为n个小集合，这样所有的线程都持有这个显示锁，但是通知的时候却可以通知这个集合内某个小集合内的线程。</p>
<p>以生产者消费者模型为例子，</p>
<ul>
<li><p>生产者线程和消费者线程都需要操作一个共同的队列，那么这个队列就是他们共同要持有的对象锁，</p>
<ul>
<li><p>wait机制通过持有这个队列的对象锁</p>
</li>
<li><p>await机制通过一个显示的Lock</p>
<p><strong>都是保证同时只能有一个线程来访问这个队列</strong> </p>
</li>
</ul>
</li>
<li><p>当一个先成为完成工作后，比如消费者发现队列已空，他就会通知其他线程</p>
<ul>
<li>wait的notify方法会通知所有的线程，无法区分是生产者还是消费者</li>
<li>而await的signal却可以通过定义Lock方法的两个Condition，而生产者线程和消费者线程等待的是不同的Condition对象，这样就可以实现更精确的通信，比如队列空的时候只要通知生产者就可以了，通知消费者是没有意义的</li>
</ul>
</li>
</ul>
<h2 id="3、管道"><a href="#3、管道" class="headerlink" title="3、管道"></a>3、管道</h2><p>管道流是JAVA中线程通讯的常用方式之一，基本流程如下：</p>
<ol>
<li>创建管道输出流PipedOutputStream pos和管道输入流PipedInputStream pis</li>
<li>将pos和pis匹配，pos.connect(pis);</li>
<li>将pos赋给信息输入线程，pis赋给信息获取线程，就可以实现线程间的通讯了</li>
</ol>
<p>管道流虽然使用起来方便，但是也有一些缺点</p>
<ol>
<li>管道流只能在两个线程之间传递数据</li>
<li>管道流只能实现单向发送，如果要两个线程之间互通讯，则需要两个管道流</li>
</ol>
<h1 id="三、进程间通信方式"><a href="#三、进程间通信方式" class="headerlink" title="三、进程间通信方式"></a>三、进程间通信方式</h1><p>进程间的通信方式属于操作系统的范畴：</p>
<ol>
<li>管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。</li>
<li>命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关 系 进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。</li>
<li>信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送 信号给进程本身；Linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。</li>
<li>消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺</li>
<li>共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。</li>
<li>内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。</li>
<li>信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。</li>
<li>套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。</li>
</ol>
<h2 id="1、管道"><a href="#1、管道" class="headerlink" title="1、管道"></a>1、管道</h2><p>它传递数据是单向性的，只能从一方流向另一方，也就是一种半双工的通信方式；只用于有亲缘关系的进程间的通信，亲缘关系也就是父子进程或兄弟进程；没有名字并且大小受限，传输的是无格式的流，所以两进程通信时必须约定好数据通信的格式。管道它就像一个特殊的文件，但这个文件之存在于内存中，在创建管道时，系统为管道分配了一个页面作为数据缓冲区，进程对这个数据缓冲区进行读写，以此来完成通信。其中一个进程只能读一个只能写，所以叫半双工通信，为什么一个只能读一个只能写呢?因为写进程是在缓冲区的末尾写入，读进程是在缓冲区的头部读取，他们各自的数据结构不同，所以功能不同。</p>
<h2 id="2、有名管道"><a href="#2、有名管道" class="headerlink" title="2、有名管道"></a>2、有名管道</h2><p>看见这个名字就能知道个大概了，它于管道的不同的是它有名字了。这就不同与管道只能在<strong>具有亲缘关系</strong>的进程间通信了。它提供了一个路径名与之关联，有了自己的传输格式。有名管道和管道的不同之处还有一点是,有名管道是个设备文件，存储在文件系统中，没有亲缘关系的进程也可以访问，但是它要按照先进先出的原则读取数据。同样也是单双工的。</p>
<h2 id="3、信号"><a href="#3、信号" class="headerlink" title="3、信号"></a>3、信号</h2><p>信号是在软件层次上对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是异步的，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。信号是进程间通信机制中唯一的异步通信机制，可以看作是异步通知，通知接收信号的进程有哪些事情发生了。信号机制经过POSIX实时扩展后，功能更加强大，除了基本通知功能外，还可以传递附加信息。信号事件的发生有两个来源：硬件来源(比如我们按下了键盘或者其它硬件故障)；软件来源。信号分为可靠信号和不可靠信号，实时信号和非实时信号。进程有三种方式响应信号1.忽略信号2.捕捉信号3.执行缺省操作。</p>
<h2 id="4、消息队列"><a href="#4、消息队列" class="headerlink" title="4、消息队列"></a>4、消息队列</h2><p>存放在内核中的消息链表，每个消息队列由消息队列标识符标识，于管道不同的是，消息队列存放在内核中，只有在内核重启时才能删除一个消息队列，内核重启也就是系统重启，同样消息队列的大小也是受限制的。</p>
<h2 id="5、共享内存"><a href="#5、共享内存" class="headerlink" title="5、共享内存"></a>5、共享内存</h2><p>就是分配一块能被其他进程访问的内存。共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式。首先说下在使用共享内存区前，必须通过系统函数将其附加到进程的地址空间或说为映射到进程空间。两个不同进程A、B共享内存的意思是，同一块物理内存被映射到 进程A、B各自的进程地址空间。进程A可以即时看到进程B对共享内存中数据的更新，反之亦然。由于多个进程共享同一块内存区域，必然需要某种同步机制，互 斥锁和信号量都可以。采用共享内存通信的一个显而易 见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而 共享内存则只拷贝两次数据[1]：一次从输入文件到共享内存区，另一次从共享内存区到输出文件。实际上，进程之间在共享内存时，并不总是读写少量数据后就 解除映射，有新的通信时，再重新建立共享内存区域。而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存 中的内容往往是在解除映射时才写回文件的。因此，采用共享内存的通信方式效率是非常高的。</p>
<h2 id="6、内存映射"><a href="#6、内存映射" class="headerlink" title="6、内存映射"></a>6、内存映射</h2><p>在Java NIO中接触过，不知道是不是</p>
<h2 id="7、信号量"><a href="#7、信号量" class="headerlink" title="7、信号量"></a>7、信号量</h2><p>也可以说是一个计数器，常用来处理进程或线程同步的问题，特别是对临界资源的访问同步问题。临界资源：为某一时刻只能由一个进程或线程操作的资源，当信号量的值大于或等于0时，表示可以供并发进程访问的临界资源数，当小于0时，表示正在等待使用临界资源的进程数。更重要的是，信号量的值仅能由PV操作来改变。</p>
<h2 id="8、套接字"><a href="#8、套接字" class="headerlink" title="8、套接字"></a>8、套接字</h2><p>Socket</p>
<h1 id="四、参考地址"><a href="#四、参考地址" class="headerlink" title="四、参考地址"></a>四、参考地址</h1><p><a href="http://blog.csdn.net/ls5718/article/details/51878770" target="_blank" rel="external">http://blog.csdn.net/ls5718/article/details/51878770</a></p>
<p><a href="http://blog.csdn.net/cneaglelee/article/details/7943021" target="_blank" rel="external">http://blog.csdn.net/cneaglelee/article/details/7943021</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[生产者消费者模型]]></title>
      <url>http://yoursite.com/2016/12/23/MultiThreading/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>生产者消费者问题是研究多线程程序时绕不开的经典问题之一，比较典型的描述就是有一块缓冲区作为仓库，生产者可以将产品放入仓库，消费者则可以从仓库中取走产品。</p>
<p>解决生产者/消费者问题的方法可分为两类：</p>
<ol>
<li>采用某种机制保护生产者和消费者之间的同步；</li>
<li>在生产者和消费者之间建立一个管道。</li>
</ol>
<p>第一种方式有较高的效率，并且易于实现，代码的可控制性较好，属于常用的模式。第二种管道缓冲区不易控制，被传输数据对象不易于封装等，实用性不强。因此本文只介绍同步机制实现的生产者/消费者问题。</p>
<p>同步问题核心在于：如何保证同一资源被多个线程并发访问时的完整性。常用的同步方法是采用信号或加锁机制，保证资源在任意时刻至多被一个线程访问。Java语言在多线程编程上实现了完全对象化，提供了对同步机制的良好支持。在Java中一共有四种方法支持同步，其中前三个是同步方法，一个是管道方法。</p>
<ol>
<li>wait() / notify()方法</li>
<li>await() / signal()方法</li>
<li>BlockingQueue阻塞队列方法</li>
</ol>
<h1 id="一、wait、notify方法"><a href="#一、wait、notify方法" class="headerlink" title="一、wait、notify方法"></a>一、wait、notify方法</h1><h2 id="1、方法介绍"><a href="#1、方法介绍" class="headerlink" title="1、方法介绍"></a>1、方法介绍</h2><p>前面介绍Object类的方法时提到过里面有几个自带的关于线程的方法，</p>
<ul>
<li>wait</li>
<li>notify</li>
<li>notifyAll</li>
</ul>
<p>这三个方法一般配合在一起使用，用于线程间的通信。</p>
<p>关于wait方法的标准写法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// The standard idiom for calling the wait method in Java </span></div><div class="line"><span class="keyword">synchronized</span> (sharedObject) &#123; </div><div class="line">    <span class="keyword">while</span> (condition) &#123; </div><div class="line">        sharedObject.wait(); </div><div class="line">        <span class="comment">// (Releases lock, and reacquires on wakeup) </span></div><div class="line">    &#125; </div><div class="line">    <span class="comment">// do action based upon condition e.g. take or put into queue </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以利用wait()来让一个线程在某些条件下暂停运行。例如，在生产者消费者模型中，生产者线程在缓冲区为满的时候，消费者在缓冲区为空的时 候，都应该暂停运行。如果某些线程在等待某些条件触发，那当那些条件为真时，你可以用 notify 和 notifyAll 来通知那些等待中的线程重新开始运行。不同之处在于，notify 仅仅通知一个线程，并且我们不知道哪个线程会收到通知，然而 notifyAll 会通知所有等待中的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.LinkedList;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 仓库最大存储量  </span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">100</span>;  </div><div class="line">  </div><div class="line">    <span class="comment">// 仓库存储的载体  </span></div><div class="line">    <span class="keyword">private</span> LinkedList&lt;Object&gt; list = <span class="keyword">new</span> LinkedList&lt;Object&gt;();  </div><div class="line">    </div><div class="line">    <span class="comment">// 生产num个产品  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">int</span> num, Thread thread)</span></span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(list)&#123;</div><div class="line">            <span class="comment">// 如果仓库剩余容量不足  </span></div><div class="line">            <span class="keyword">while</span>(list.size()+num&gt;MAX_SIZE)&#123;</div><div class="line">                System.out.println(thread.getName()+<span class="string">"【要生产的产品数量】:"</span> + num + <span class="string">"\t【库存量】:"</span>  </div><div class="line">                        + list.size() + <span class="string">"/t暂时不能执行生产任务!"</span>);  </div><div class="line">                <span class="keyword">try</span>&#123;</div><div class="line">                    list.wait();</div><div class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line">                    </div><div class="line">                &#125;</div><div class="line">            &#125;    </div><div class="line">            <span class="comment">// 生产条件满足情况下，生产num个产品  </span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num; i++)&#123;</div><div class="line">                list.add(<span class="keyword">new</span> Object());</div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">"【已经生产产品数】:"</span> + num + <span class="string">"\t【现仓储量为】:"</span> + list.size());  </div><div class="line">            list.notifyAll();              </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 消费num个产品  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(<span class="keyword">int</span> num, Thread thread)</span></span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(list)&#123;</div><div class="line">            <span class="comment">// 如果仓库存储量不足  </span></div><div class="line">            <span class="keyword">while</span>(list.size()&lt;num)&#123;</div><div class="line">                System.out.println(thread.getName()+<span class="string">"【要消费的产品数量】:"</span> + num + <span class="string">"\t【库存量】:"</span>  </div><div class="line">                        + list.size() + <span class="string">"/t暂时不能执行消费任务!"</span>);  </div><div class="line">                <span class="keyword">try</span>&#123;</div><div class="line">                    list.wait();</div><div class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line">                    </div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 消费条件满足情况下，消费num个产品  </span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num; i++)&#123;</div><div class="line">                list.remove();</div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">"【已经消费产品数】:"</span> + num + <span class="string">"\t【现仓储量为】:"</span> + list.size());  </div><div class="line">            list.notifyAll();  </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">        Storage storage;<span class="comment">// 所在放置的仓库  </span></div><div class="line">        <span class="keyword">int</span> num;<span class="comment">// 每次生产的产品数量  </span></div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(String name, Storage storage, <span class="keyword">int</span> num)</span></span>&#123;</div><div class="line">            <span class="keyword">super</span>(name);</div><div class="line">            <span class="keyword">this</span>.storage=storage;</div><div class="line">            <span class="keyword">this</span>.num=num;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">            storage.produce(num, <span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">        Storage storage;<span class="comment">// 所在放置的仓库  </span></div><div class="line">        <span class="keyword">int</span> num;<span class="comment">// 每次生产的产品数量  </span></div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(String name, Storage storage, <span class="keyword">int</span> num)</span></span>&#123;</div><div class="line">            <span class="keyword">super</span>(name);</div><div class="line">            <span class="keyword">this</span>.storage=storage;</div><div class="line">            <span class="keyword">this</span>.num=num;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">            storage.consume(num, <span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </div><div class="line">        Storage storage = <span class="keyword">new</span> Storage();  <span class="comment">// 仓库对象  </span></div><div class="line"></div><div class="line">        <span class="comment">// 生产者对象  </span></div><div class="line">        Producer p1=<span class="keyword">new</span> Producer(<span class="string">"producer1"</span>, storage, <span class="number">10</span>); </div><div class="line">        Producer p2=<span class="keyword">new</span> Producer(<span class="string">"producer2"</span>, storage, <span class="number">10</span>); </div><div class="line">        Producer p3=<span class="keyword">new</span> Producer(<span class="string">"producer3"</span>, storage, <span class="number">10</span>); </div><div class="line">        Producer p4=<span class="keyword">new</span> Producer(<span class="string">"producer4"</span>, storage, <span class="number">10</span>); </div><div class="line">        Producer p5=<span class="keyword">new</span> Producer(<span class="string">"producer5"</span>, storage, <span class="number">10</span>); </div><div class="line">        Producer p6=<span class="keyword">new</span> Producer(<span class="string">"producer6"</span>, storage, <span class="number">10</span>);</div><div class="line">        Producer p7=<span class="keyword">new</span> Producer(<span class="string">"producer7"</span>, storage, <span class="number">10</span>);</div><div class="line">        </div><div class="line">        <span class="comment">// 消费者对象  </span></div><div class="line">        Consumer c1=<span class="keyword">new</span> Consumer(<span class="string">"consumer1"</span>, storage, <span class="number">50</span>);  </div><div class="line">        Consumer c2=<span class="keyword">new</span> Consumer(<span class="string">"consumer2"</span>, storage, <span class="number">50</span>);  </div><div class="line">        Consumer c3=<span class="keyword">new</span> Consumer(<span class="string">"consumer3"</span>, storage, <span class="number">50</span>);   </div><div class="line">        </div><div class="line">        <span class="comment">// 线程开始执行  </span></div><div class="line">        c1.start();  </div><div class="line">        c2.start();  </div><div class="line">        c3.start();  </div><div class="line">        p1.start();  </div><div class="line">        p2.start();  </div><div class="line">        p3.start();  </div><div class="line">        p4.start();  </div><div class="line">        p5.start();  </div><div class="line">        p6.start();  </div><div class="line">        p7.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果（每次的输出结果都是不一样的）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">consumer1【要消费的产品数量】:50    【库存量】:0/t暂时不能执行消费任务!</div><div class="line">【已经生产产品数】:10    【现仓储量为】:10</div><div class="line">consumer1【要消费的产品数量】:50    【库存量】:10/t暂时不能执行消费任务!</div><div class="line">【已经生产产品数】:10    【现仓储量为】:20</div><div class="line">【已经生产产品数】:10    【现仓储量为】:30</div><div class="line">【已经生产产品数】:10    【现仓储量为】:40</div><div class="line">consumer3【要消费的产品数量】:50    【库存量】:40/t暂时不能执行消费任务!</div><div class="line">【已经生产产品数】:10    【现仓储量为】:50</div><div class="line">【已经消费产品数】:50    【现仓储量为】:0</div><div class="line">consumer3【要消费的产品数量】:50    【库存量】:0/t暂时不能执行消费任务!</div><div class="line">consumer1【要消费的产品数量】:50    【库存量】:0/t暂时不能执行消费任务!</div><div class="line">【已经生产产品数】:10    【现仓储量为】:10</div><div class="line">【已经生产产品数】:10    【现仓储量为】:20</div><div class="line">consumer1【要消费的产品数量】:50    【库存量】:20/t暂时不能执行消费任务!</div><div class="line">consumer3【要消费的产品数量】:50    【库存量】:20/t暂时不能执行消费任务!</div></pre></td></tr></table></figure>
<p>实现类Storage中定义了produce和consume方法，供生产者和消费者线程调用，修改逻辑后生产者和消费者的代码完全不用改变</p>
<h2 id="2、wait与sleep的区别"><a href="#2、wait与sleep的区别" class="headerlink" title="2、wait与sleep的区别"></a>2、wait与sleep的区别</h2><h3 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a>sleep方法</h3><p>sleep()方法是Thread类的静态方法，使目前正在执行的线程休眠millis毫秒。</p>
<ul>
<li>当线程睡眠时，它睡在某个地方，在苏醒之前不会返回到可运行状态。</li>
<li>当睡眠时间到期，则返回到可运行状态。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    Thread.sleep(<span class="number">1000</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">    e.printStackTrace(); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>这两个方法都会使线程进入阻塞状态，也都会抛出中断异常，但是它们有一下几点区别：</p>
<ol>
<li><p>关于方法来源与作用：</p>
<ul>
<li>wait是Object类的方法，用来线程间的通信</li>
<li>sleep是Thread类的方法，是线程用来控制自身流程的</li>
</ul>
</li>
<li><p>关于锁的释放：</p>
<ul>
<li>sleep方法不会释放锁</li>
<li>wait方法会释放锁</li>
</ul>
</li>
<li><p>关于使用区域：</p>
<ul>
<li>wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用</li>
<li>sleep可以在任何地方使用。</li>
</ul>
<p>​</p>
</li>
</ol>
<h1 id="二、await、signal方法"><a href="#二、await、signal方法" class="headerlink" title="二、await、signal方法"></a>二、await、signal方法</h1><p>在JDK5.0之后，Java提供了更加健壮的线程处理机制，包括同步、锁定、线程池等，它们可以实现更细粒度的线程控制。await()和signal()就是其中用来做同步的两种方法，它们的功能基本上和wait() / nofity()相同，完全可以取代它们，但是它们和新引入的锁定机制Lock直接挂钩，具有更大的灵活性。通过在Lock对象上调用newCondition()方法，将条件变量和一个锁对象进行绑定，进而控制并发程序访问竞争资源的安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.LinkedList;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">100</span>;<span class="comment">// 仓库最大存储量    </span></div><div class="line">      </div><div class="line">    <span class="keyword">private</span> LinkedList&lt;Object&gt; list = <span class="keyword">new</span> LinkedList&lt;Object&gt;();<span class="comment">// 仓库存储的载体</span></div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock=<span class="keyword">new</span> ReentrantLock();<span class="comment">// 锁      </span></div><div class="line">    <span class="keyword">private</span> Condition full=lock.newCondition();<span class="comment">// 仓库满的条件变量  </span></div><div class="line">    <span class="keyword">private</span> Condition empty=lock.newCondition();<span class="comment">// 仓库空的条件变量  </span></div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">// 生产num个产品  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">int</span> num, Thread thread)</span></span>&#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span>&#123;<span class="comment">//显示锁最后必须显示释放</span></div><div class="line">            <span class="comment">// 如果仓库剩余容量不足  </span></div><div class="line">            System.out.println(thread.getName());</div><div class="line">            <span class="keyword">while</span>(list.size()+num&gt;MAX_SIZE)&#123;</div><div class="line">                System.out.println(<span class="string">"【要生产的产品数量】:"</span> + num + <span class="string">"\t【库存量】:"</span>  </div><div class="line">                        + list.size() + <span class="string">"/t暂时不能执行生产任务!"</span>);  </div><div class="line">                <span class="keyword">try</span>&#123;</div><div class="line">                    full.await();</div><div class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line">                    </div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 生产条件满足情况下，生产num个产品  </span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num; i++)&#123;</div><div class="line">                list.add(<span class="keyword">new</span> Object());</div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">"【已经生产产品数】:"</span> + num + <span class="string">"\t【现仓储量为】:"</span> + list.size());  </div><div class="line">            empty.signal();</div><div class="line">        &#125;<span class="keyword">finally</span>&#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 消费num个产品  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(<span class="keyword">int</span> num, Thread thread)</span></span>&#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            <span class="comment">// 如果仓库存储量不足  </span></div><div class="line">            System.out.println(thread.getName());</div><div class="line">            <span class="keyword">while</span>(list.size()&lt;num)&#123;</div><div class="line">                System.out.println(<span class="string">"【要消费的产品数量】:"</span> + num + <span class="string">"\t【库存量】:"</span>  </div><div class="line">                        + list.size() + <span class="string">"/t暂时不能执行消费任务!"</span>);  </div><div class="line">                <span class="keyword">try</span>&#123;</div><div class="line">                    empty.await();</div><div class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line">                    </div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 消费条件满足情况下，消费num个产品  </span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num; i++)&#123;</div><div class="line">                list.remove();</div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">"【已经消费产品数】:"</span> + num + <span class="string">"\t【现仓储量为】:"</span> + list.size());  </div><div class="line">            full.signal();</div><div class="line">        &#125;<span class="keyword">finally</span>&#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 其余代码与上面完全一样</div><div class="line">     */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里体现出了设计上的好处，只要改变Storage类的代码即可。</p>
<p>从修改的地方可以看出await、signal方法与wait、notify非常相似，而且是他们的升级。</p>
<p>通过将两个条件分开到两个等待线程集中，Condition更容易满足单词通知的需求。signal比signalAll更高效，它极大地减少每次在缓存操作中发生的上下文切换与锁请求的次数，个人理解就是当生产者生产了以后，只通知消费者，而且只通知一个消费者。</p>
<h1 id="三、BlockingQueue阻塞队列方法"><a href="#三、BlockingQueue阻塞队列方法" class="headerlink" title="三、BlockingQueue阻塞队列方法"></a>三、BlockingQueue阻塞队列方法</h1><p>BlockingQueue是JDK5.0的新增内容，它是一个已经在内部实现了同步的队列，实现方式采用的是我们第2种await() / signal()方法。它可以在生成对象时指定容量大小。它用于阻塞操作的是put()和take()方法。</p>
<ul>
<li>put()方法：类似于我们上面的生产者线程，容量达到最大时，自动阻塞。</li>
<li>take()方法：类似于我们上面的消费者线程，容量为0时，自动阻塞。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> BlockingQueue&lt;String&gt; queue;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> timeout; <span class="comment">// 生产一个产品后暂停的时间</span></div><div class="line">        <span class="keyword">private</span> String category; <span class="comment">// 仅仅起标记产品作用</span></div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue&lt;String&gt; queue, <span class="keyword">int</span> timeout, String category)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>();</div><div class="line">            <span class="keyword">this</span>.queue = queue;</div><div class="line">            <span class="keyword">this</span>.timeout = timeout;</div><div class="line">            <span class="keyword">this</span>.category = category;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">// put()方法也是一个会阻塞的方法，如果队列已满的时候这个方法会一起阻塞直到</span></div><div class="line">                    <span class="comment">// 队列中重新出现空间为止</span></div><div class="line">                    queue.put(<span class="string">"product "</span> + category);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</div><div class="line">                    e1.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    TimeUnit.MILLISECONDS.sleep(timeout); <span class="comment">// 每生产一个产品就暂停timeout毫秒</span></div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> BlockingQueue&lt;String&gt; queue;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(BlockingQueue&lt;String&gt; queue)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>();</div><div class="line">            <span class="keyword">this</span>.queue = queue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    System.out.println(<span class="string">"product got:"</span> + queue.take());</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</div><div class="line">                    e1.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">// 暂停10毫秒，这里主要是为了证明take()是一个阻塞方法，如果 BlockingQueue中</span></div><div class="line">                    <span class="comment">// 没有元素，它会一起阻塞直到队列中有元素为止</span></div><div class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 这里简单的说一下BlockingQueue的实现,它基于生产者-消费者模式，其中有两个重要的阻塞方法</span></div><div class="line">        <span class="comment">// put()和take()，而这两个方法的实现用到了Lock和Condition，具体实现请参考API</span></div><div class="line">        BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="number">10</span>);</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(queue, <span class="number">500</span>, <span class="string">"peak"</span>)); <span class="comment">// 生产者线程,并且要比nike生产的快</span></div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(queue, <span class="number">1000</span>, <span class="string">"nike"</span>)); <span class="comment">// 第二个生产者线程</span></div><div class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Customer(queue)); <span class="comment">// 消费者线程</span></div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t3.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="四、参考地址"><a href="#四、参考地址" class="headerlink" title="四、参考地址"></a>四、参考地址</h1><p><a href="http://developer.51cto.com/art/201508/487488.htm" target="_blank" rel="external">http://developer.51cto.com/art/201508/487488.htm</a></p>
<p><a href="http://blog.csdn.net/monkey_d_meng/article/details/6251879" target="_blank" rel="external">http://blog.csdn.net/monkey_d_meng/article/details/6251879</a></p>
<p><a href="http://blog.csdn.net/moreevan/article/details/6763508" target="_blank" rel="external">http://blog.csdn.net/moreevan/article/details/6763508</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[浅析Servlet]]></title>
      <url>http://yoursite.com/2016/12/19/Java/%E6%B5%85%E6%9E%90Servlet/</url>
      <content type="html"><![CDATA[<p>Servlet是Java Web中一个非常重要的概念，而且它的定义很模糊，在此总结一下</p>
<blockquote>
<p><strong>Servlet</strong>（Server Applet），全称<strong>Java Servlet</strong>，暂无中文译文。是用Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。</p>
</blockquote>
<h1 id="一、Servlet容器与Tomcat"><a href="#一、Servlet容器与Tomcat" class="headerlink" title="一、Servlet容器与Tomcat"></a>一、Servlet容器与Tomcat</h1><p>Servlet没有main()方法，他们受控于另外一个Java应用，这个Java应用称为容器(Container)。最著名的Servlet容器一个就是Tomcat了。</p>
<h2 id="1、Tomcat定义"><a href="#1、Tomcat定义" class="headerlink" title="1、Tomcat定义"></a>1、Tomcat定义</h2><p>Tomcat是Servlet容器，同时也是轻量级的Web服务器。<strong>这是它的两个身份！</strong></p>
<p>Apache Server、Microsoft IIS、Apache Tomcat都是Web服务器。</p>
<p>Tomcat作为Web服务器时，主要负责实现HTTP传输等工作。</p>
<p>Tomcat作为Servlet容器时，主要负责解析Request，生成ServletRequest、ServletResponse，将其传给相应的Servlet（调用service( )方法），再将Servlet的相应结果返回。</p>
<h2 id="2、Tomcat的工作过程"><a href="#2、Tomcat的工作过程" class="headerlink" title="2、Tomcat的工作过程"></a>2、Tomcat的工作过程</h2><p>Tomcat实现了servlet API。也就是说它的内部，定义了Servlet中接口的实现类，并且在它运行时，将一些实现类自动地实例化。</p>
<p>Tomcat 是Web应用服务器，是一个Servlet/JSP容器。Tomcat 作为Servlet容器，负责处理客户请求,把请求传送给Servlet，并将Servlet的响应传送回给客户。</p>
<p>而Servlet是一种运行在支持Java语言的服务器上的组件。Servlet最常见的用途是扩展Java Web服务器功能，提供非常安全的，可移植的，易于使用的CGI替代品。 它的处理流程如下：</p>
<ol>
<li>Web客户向Servlet容器（Tomcat）发出Http请求</li>
<li>Servlet容器分析客户的请求信息</li>
<li>Servlet容器创建一个HttpRequest对象，将客户请求的信息封装到这个对象中</li>
<li>Servlet容器创建一个HttpResponse对象  </li>
<li>Servlet容器调用HttpServlet对象的service方法，把HttpRequest对象与HttpResponse对象作为参数传给 HttpServlet对象</li>
<li>HttpServlet调用HttpRequest对象的有关方法，获取Http请求信息</li>
<li>HttpServlet调用HttpResponse对象的有关方法，生成响应数据</li>
<li>Servlet容器把HttpServlet的响应结果传给Web客户</li>
</ol>
<h2 id="3、Tomcat结构组成"><a href="#3、Tomcat结构组成" class="headerlink" title="3、Tomcat结构组成"></a>3、Tomcat结构组成</h2><p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/java/8.png?raw=true" alt=""></p>
<ul>
<li><p>Server，代表整个Servlet容器组件，是Tomcat的顶层元素。其中可以包含一到多个Service；</p>
</li>
<li><p>Service，包含一个Engine，以及一到多个Connector；</p>
</li>
<li><p>Connector，代表和客户端程序实际交互的组件，负责接收客户请求，以及向客户返回响应结果；</p>
</li>
<li><p>Engine，处理同一个Service中所有Connector接收到的客户请求；</p>
</li>
<li><p>Host，在Engine中可以包含多个Host，每个Host定义了一个虚拟主机，它可以包含一个到多个Web应用；</p>
</li>
<li><p>Context，一个Host中可以包含多个Context，每个Context代表了运行在虚拟主机上的单个Web应用。</p>
<p>​</p>
</li>
</ul>
<h2 id="4、Tomcat的工作模式"><a href="#4、Tomcat的工作模式" class="headerlink" title="4、Tomcat的工作模式"></a>4、Tomcat的工作模式</h2><ol>
<li>独立的Servlet容器：Tomcat作为独立的Web服务器单独运行，Servlet容器作为Web服务器的一部分，这也是默认工作模式。</li>
<li>其他Web服务器进程内的Servlet容器：Tomcat作为进程内的Servlet容器时，Servlet容器是作为Web服务器的插件和Java容器的实现。</li>
<li>其他Web服务器进程外的Servlet容器：Tomcat作为进程外的Servlet容器时，Servlet容器运行于Web服务器之外的地址空间，并且作为Web服务器的插件和Java容器的实现的结合。</li>
</ol>
<h1 id="二、Servlet的生命周期"><a href="#二、Servlet的生命周期" class="headerlink" title="二、Servlet的生命周期"></a>二、Servlet的生命周期</h1><h2 id="1、生命周期"><a href="#1、生命周期" class="headerlink" title="1、生命周期"></a>1、生命周期</h2><p>Servlet的生命周期是由Servlet容器控制的。Servlet一生中只有一个实例出现，但是有多个线程出现。</p>
<ol>
<li>加载类：Servlet .class文件</li>
<li>实例化：构造函数运行</li>
<li>初始化：容器调用 init() 方法(一生只调一次，并且是在第一次调用Servlet的时候执行)</li>
<li>Service方法：Servlet一生主要在这里度过</li>
<li>销毁：销毁实例之前调用 destroy() 方法</li>
<li>可回收：等待垃圾回收等待垃圾回收</li>
</ol>
<p><strong>注意：当我们配置文件中指定load-on-startup 属性时，若他的值是一个大于等于0的整数，容器会在启动的时候加载这个servlet类并调用他的init方法。</strong></p>
<h2 id="2、关键方法"><a href="#2、关键方法" class="headerlink" title="2、关键方法"></a>2、关键方法</h2><ol>
<li>init()方法：在servlet实例被创建后调用，可以覆盖此方法做一些初始化的工作，比方说得到一个数据库连接。</li>
<li>service()方法：当客户请求到来时，容器会创建一个新的线程，调用Servlet的service()方法。Servlet的一生基本都在这里度过。我们一般不要覆盖此方法。</li>
<li>doGet或者doPost()方法：service方法根据请求的HTTP方法，来调用doGet()或者doPost()方法。我们在开发Servlet时肯定要覆盖此方法。每次运行doGet()或者doPost()方法，它都在一个单独的线程中。</li>
</ol>
<h2 id="3、init方法与构造函数"><a href="#3、init方法与构造函数" class="headerlink" title="3、init方法与构造函数"></a>3、init方法与构造函数</h2><p>一直有个疑问：构造函数用来初始化类，可是servlet初始化却是init方法，可servlet本质上也是Java类，那它的构造方法和init函数到底是什么关系？</p>
<ul>
<li>首先，构造函数是有的，虽然我们通常不写Servlet的构造函数，但是就像任何一个普通的Java类一样，编译器会自动给你生成一个默认构造函数；</li>
<li>其次，构造函数和init方法都会被web容器调用，而且是先调用构造函数，然后调用init方法；</li>
<li>最后，貌似容器只会调用默认构造函数，所以如果你自己写了带参数的构造函数（系统就不会自动生成默认构造函数），容器初始化servlet就会出错……P.S.：任何时候都不推荐自己写构造函数来初始化servlet类，哪怕你自己提供不带参数的构造函数……</li>
</ul>
<h2 id="4、单例多线程"><a href="#4、单例多线程" class="headerlink" title="4、单例多线程"></a>4、单例多线程</h2><p>关于Servlet接触到一个新的名词：单例多线程。就是只有一个实例，但是有多个线程来执行它</p>
<h3 id="4-1单实例多线程"><a href="#4-1单实例多线程" class="headerlink" title="4.1单实例多线程"></a>4.1单实例多线程</h3><p>再来看一下Servlet容器默认是采用单实例多线程的方式处理多个请求的：</p>
<ol>
<li>当web服务器启动的时候（或客户端发送请求到服务器时），Servlet就被加载并实例化（只存在一个Servlet实例）；</li>
</ol>
<ol>
<li>容器初始化Servlet。主要就是读取配置文件（例如tomcat，可以通过servlet.xml的\<connector>设置线程池中线程数目，初始化线程池；通过web.xml，初始化每个参数值等等）；</connector></li>
</ol>
<ol>
<li>当请求到达时，Servlet容器通过调度线程（Dispatchaer Thread）调度它管理下的线程池中等待执行的线程（Worker Thread）给请求者；</li>
</ol>
<ol>
<li>线程执行Servlet的service方法；</li>
</ol>
<ol>
<li>请求结束，放回线程池，等到被调用；</li>
</ol>
<p>由此可以看出：</p>
<ol>
<li>Servlet单实例，减少了产生servlet的开销；</li>
<li>通过线程池来响应多个请求，提高了请求的响应时间；</li>
<li>Servlet容器并不关心到达的Servlet请求访问的是否是同一个Servlet还是另一个Servlet，直接分配给它一个新的线程；如果是同一个Servlet的多个请求，那么Servlet的service方法将在多线程中并发的执行；</li>
<li>每一个请求由ServletRequest对象来接受请求，由ServletResponse对象来响应该请求；</li>
</ol>
<h3 id="4-2、原因"><a href="#4-2、原因" class="headerlink" title="4.2、原因"></a>4.2、原因</h3><p>为什么只有一个实例：</p>
<blockquote>
<p>出于性能的考虑：特别的对于门户网站而言，每一个Servlet在每一秒内的并发访问量都可以是成千上万的。在一个面向模块化开发的现在，常常一个点击操作就被定义为一个Servlet的实现，而如果Servlet的每一次被访问，都创建一个新的实例的话，服务器的可用资源消耗量将是一个相当重要的问题。退一步，一般Servlet的访问是很快的，每一个实例被快速的创建，又被快速的回收，GC的回收速度也跟不上，频繁的内存操作也将可能带来次生的问题。</p>
<p>所以，Servlet的“单一实例化”是一个很重要的策略。另外一点，JSP实质上也是一个Servlet文件。一个页面被请求时，应该如何返回被请求页面的内容？是把一个“页面对象”返回？一个页面既有的框架内容大都基本固定（当然现在ajax横行，但其所基于的也是另一个页面的访问），其所可复用，重用的部分是相当的。</p>
</blockquote>
<p>那么，它如何解决并发的问题呢？</p>
<blockquote>
<p>服务器容器会为每一个Servlet维护一个连接池，是c3p0或dbcp，都实现了DataSource，是其实现类。在编程实现上可理解为一个Application级别的Vector（自身线程安全的集合类），里面装载相当数量的Connection。每一个HTTP请求到来时，将分配一个Connection去响应请求。并在结束响应后，把Connection放回线程池。而如果当前可用Connection小于一个标准数量值，便自动添加新的Connection到Vector中。</p>
<p>所以，除了Servlet文件的编写及相关的部署外，所有的其他操作其实都交付给了服务器容器来进行管理。</p>
<p>另外，在Tomcat上，Container的实现形式有Wrapper、Context、Host、Engine，其级别递增。而每一个Servlet就代表了一个Wrapper容器，那么很自然的，也可以“证明”上面的说法。</p>
</blockquote>
<h3 id="4-3、Servlet的成员变量"><a href="#4-3、Servlet的成员变量" class="headerlink" title="4.3、Servlet的成员变量"></a>4.3、Servlet的成员变量</h3><p>因为是单例的，又有多线程访问，所以自然要设计到线程安全问题。</p>
<blockquote>
<p>同一个Servlet得到多个请求到来时，如果该Servlet中存在成员变量，可能发生多线程同时访问该资源时，都来操作它，造成数据的不一致，因此产生线程安全问题。</p>
</blockquote>
<p>解决方法：</p>
<ol>
<li>实现SingleThreadModel接口：<ul>
<li>如果一个Servlet被这个接口指定，那么在这个Servlet中的service方法将不会有两个线程被同时执行，当然也就不存在线程安全的问题；</li>
<li>如果一个Servlet实现了SingleThreadModel接口，Servlet引擎将为每个新的请求创建一个单独的Servlet实例，这将引起大量的系统开销。SingleThreadModel在Servlet2.4中已不再提倡使用；</li>
</ul>
</li>
<li>对共享互数据同步：<ul>
<li>使用synchronized关键字能保证一次只有一个线程可以访问被保护的区段，Servlet可以通过同步块操作来保证线程的安全。</li>
<li>ServletRequest对象是线程安全的，但是ServletContext和HttpSession不是线程安全的；</li>
<li>同样如果在程序中使用同步来保护要使用的共享的数据，也会使系统的性能大大下降。这是因为被同步的代码块在同一时刻只能有一个线程执行它，使得其同时处理客户请求的吞吐量降低，而且很多客户处于阻塞状态。</li>
</ul>
</li>
<li>避免使用成员变量：<ul>
<li>线程安全问题是由实例变量造成的，只要在Servlet里面的任何方法里面都不使用实例变量，那么该Servlet就是线程安全的。（所有建议不要在servlet中定义成员变量，尽量用局部变量代替）</li>
<li>从Java内存模型可以知道，方法中的临时变量是在栈上分配空间，而且每个线程都有自己私有的栈空间，所以它们不会影响线程的安全。</li>
<li>这里可以顺便提一下ThreadLocal，正在学习之中</li>
</ul>
</li>
</ol>
<h1 id="三、Servlet相关的类"><a href="#三、Servlet相关的类" class="headerlink" title="三、Servlet相关的类"></a>三、Servlet相关的类</h1><p>写网站的时候确实会用到ServletContext、HttpServletRequest 、HttpServletResponse和HttpSession这些类，但是对于他们的关系还是一知半解。</p>
<h2 id="1、HttpServletRequest-and-HttpServletResponse"><a href="#1、HttpServletRequest-and-HttpServletResponse" class="headerlink" title="1、HttpServletRequest and HttpServletResponse"></a>1、HttpServletRequest and HttpServletResponse</h2><p>Servlets容器依附于在特定端口监听http请求的web服务器，我们在开发的时候通常使用的是8080端口。当一个客户端（使用浏览器的用户）发送一个http请求的时候，Servlets容器会创建一个新的HttpServletRequest和HttpServletResponse对象，在一个线程中，通过在filter和servlet中已经创建了的方法匹配URL来传递。</p>
<p>这个request对象提供了http请求的所有信息，比如请求的头和请求的主体，这些response对象提供了你灵活控制发送http response的方式，比如设置头和体（通常包含jsp中HTML的内容）。当一个http response提交并完成的时候，request和response对象都会被销毁。</p>
<h2 id="2、HttpSession"><a href="#2、HttpSession" class="headerlink" title="2、HttpSession"></a>2、HttpSession</h2><p>一个客户端第一次访问web应用的时候或者httpSession第一次被request.getSession()获取的时候，servlets容器会创建它，产生一个long并且是唯一的一个ID（可以通过session.getId()获取）并且存储在服务器的内存中，servlets容器同样会在http response头中的Set-Cookie设置cookie，使用JESSIONID作为cookie的名字，唯一的session ID作为cookie的值。</p>
<p>因为每一个http cookie的详细说明（一个良好的web浏览器和web服务器间的契约必须要附加传递），只要cookie有效，客户端会在后续的request中在cookie的头中发送回cookie回去。使用浏览器内部的http流量监控你可以检查他们，servlets容器将决定每个http request中名字为JSESSRIONID和值为sessionID的cookie和服务器内存中哪一个httpSession相关联。</p>
<p>httpSession存活的时间是由<code>&lt;session-timeout&gt;</code>设置的时间决定的，你可以在web.xml中进行设定，默认情况下是30分钟。所以当客户端不访问服务器超过30分钟的时候，Servlet容器会销毁这个session。每一个后续的请求，即使已经指定了cookie，也不会访问同一个session了，servlets容器会创建一个新的session。</p>
<p>另一方面，session cookie在客户端也有一个默认的时间，只要这个浏览器是运行的。所以当客户端关闭浏览器的之后，客户端的session会被销毁，再次打开浏览器同一个session不会被发送，一个新的request.getSession()会返回一个新的httpSession并用新的sessionID设置cookie。</p>
<h2 id="3、ServletContext"><a href="#3、ServletContext" class="headerlink" title="3、ServletContext"></a>3、ServletContext</h2><p>一个 WEB 运用程序只有一个 ServletContext 实例, 它是在容器(包括 JBoss, Tomcat 等)完全启动 WEB 项目之前被创建, 生命周期伴随整个 WEB 运用。</p>
<p>利用ServletContext 能够获得 WEB 运用的配置信息, 实现在多个 Servlet 之间共享数据等。比如通过ServletContext 类的getRealPath()方法获取服务器的真实地址</p>
<p>获取方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/psxt/login"</span>) </div><div class="line">   <span class="meta">@ResponseBody</span>    </div><div class="line"><span class="function"><span class="keyword">public</span> ResponseMessage <span class="title">login</span><span class="params">(HttpSession session)</span> </span>&#123;    	</div><div class="line">   	ServletContext servletContext=session.getServletContext();</div><div class="line">   	String path=servletContext.getRealPath(<span class="string">""</span>);    	</div><div class="line">   	<span class="keyword">return</span> loginHandler.tryLogin(session,userName, password);</div><div class="line">   &#125;</div><div class="line"></div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></div><div class="line">           <span class="keyword">throws</span> Exception &#123;</div><div class="line">   	ServletContext servletContext=request.getSession().getServletContext();</div><div class="line">   	String path=servletContext.getRealPath(<span class="string">""</span>);</div><div class="line">     </div><div class="line">     	WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext();    </div><div class="line">       ServletContext servletContext = webApplicationContext.getServletContext();  </div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>可以通过当前的Session或者request来获取。或者直接通过Spring的WebApplicationContext来获取。</p>
<h2 id="4、WebApplicationContext"><a href="#4、WebApplicationContext" class="headerlink" title="4、WebApplicationContext"></a>4、WebApplicationContext</h2><p>ApplicationContext是Spring的核心，在介绍Spring的时候知道它是一个Bean容器，在SpringMVC中，会用到的是WebApplicationContext，它继承自ApplicationContext。</p>
<p>WebApplicationContext的初始化方式和以前介绍的BeanFactory、ApplicationContext容器有所区别，因为WebApplicationContext需要ServletContext实例，也就是说它必须在拥有Web容器的前提下才能完成启动的工作。</p>
<p>在web.xml中配置自启动的Servlet或定义Web容器监听器(ServletContextListener)，借助着两者中的任何一个，我们就可以启动Spring Web应用上下文的工作。</p>
<p>作用：</p>
<ul>
<li>因为它是SpringMVC容器，所以得到它后就可以直接获取Bean了。</li>
<li>还可以像上面说的获取ServletContext</li>
</ul>
<h2 id="5、生命周期"><a href="#5、生命周期" class="headerlink" title="5、生命周期"></a>5、生命周期</h2><ol>
<li>HttpServletRequest 和HttpServletResponse的生命周期是request发送和response完成，不能被共享。</li>
<li>HttpSession的生命周期和客户端服务器运行的时间一样长，只要服务器端没有超时，在同一个session中共享所有请求。</li>
<li>ServletContext的生命周期和web应用的生命周期一样长，被所有session中的所有请求所共享。</li>
</ol>
<h1 id="四、参考地址"><a href="#四、参考地址" class="headerlink" title="四、参考地址"></a>四、参考地址</h1><p><a href="http://blog.csdn.net/truong/article/details/21044595" target="_blank" rel="external">http://blog.csdn.net/truong/article/details/21044595</a></p>
<p><a href="http://blog.csdn.net/pirateleo/article/details/8574973" target="_blank" rel="external">http://blog.csdn.net/pirateleo/article/details/8574973</a></p>
<p><a href="http://blog.csdn.net/cnctloveyu/article/details/4303636" target="_blank" rel="external">http://blog.csdn.net/cnctloveyu/article/details/4303636</a></p>
<p><a href="http://blog.csdn.net/firstests/article/details/8121229" target="_blank" rel="external">http://blog.csdn.net/firstests/article/details/8121229</a></p>
<p><a href="http://blog.csdn.net/zheng0518/article/details/44948455" target="_blank" rel="external">http://blog.csdn.net/zheng0518/article/details/44948455</a></p>
<p><a href="http://greenyouyou.blog.163.com/blog/static/13838814720112143022834/" target="_blank" rel="external">http://greenyouyou.blog.163.com/blog/static/13838814720112143022834/</a></p>
<p><a href="http://blog.csdn.net/maoyeqiu/article/details/49718173" target="_blank" rel="external">http://blog.csdn.net/maoyeqiu/article/details/49718173</a></p>
<p><a href="http://blog.csdn.net/zhulinu/article/details/7305247" target="_blank" rel="external">http://blog.csdn.net/zhulinu/article/details/7305247</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring基础知识（一）：Bean的作用域和生命周期]]></title>
      <url>http://yoursite.com/2016/12/18/spring/Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(1)Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <content type="html"><![CDATA[<h1 id="一、Spring容器"><a href="#一、Spring容器" class="headerlink" title="一、Spring容器"></a>一、Spring容器</h1><p>在Spring中，Bean的是一个非常广义的概念，任何的Java对象、Java组件都被当成Bean处理。 Spring容器负责创建Bean实例，所以需要知道每个Bean的实现类，Java程序面向接口编程，无须关心Bean实例的实现类；但是Spring容器必须能够精确知道每个Bean实例的实现类，因此Spring配置文件必须精确配置Bean实例的实现类。</p>
<h2 id="1、BeanFactory与ApplicationContext"><a href="#1、BeanFactory与ApplicationContext" class="headerlink" title="1、BeanFactory与ApplicationContext"></a>1、BeanFactory与ApplicationContext</h2><p>Spring的容器有很多，可以归为两个不同的类型</p>
<ul>
<li>一类是实现BeanFactory接口的简单容器系列，这系列容器只实现了容器的最基本功能</li>
<li>另一类是ApplicationContext应用上下文是BeanFactory的子接口，它作为容器的高级形态而存在。 </li>
</ul>
<h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>BeanFactory接口包含以下几个基本方法：</p>
<ul>
<li>Boolean containBean(String name):判断Spring容器是否包含id为name的Bean实例。</li>
<li><t> getBean(Class<t> requiredType):获取Spring容器中属于requiredType类型的唯一的Bean实例。</t></t></li>
<li>Object getBean(String name)：返回Sprin容器中id为name的Bean实例。</li>
<li><t> T getBean(String name,Class requiredType)：返回容器中id为name,并且类型为requiredType的Bean</t></li>
<li>Class &lt;?&gt; getType(String name)：返回容器中指定Bean实例的类型。</li>
</ul>
<p>这个容器基本很少使用，基本都是使用更高级的ApplicationContext容器。</p>
<h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p>ApplicationContext作为BeanFactory的子接口，使用它作为Spring容器会更加方便，它主要有如下几个实现类：</p>
<ul>
<li>FileSystemXmlApplicationContext：以基于文件系统的XML配置文件创建ApplicationContext实例。</li>
<li>ClassPathXmlApplicationContext：以类加载路径下的XML配置文件创建的ApplicationContext实例。</li>
<li>AnnotationConfigApplicationContext：以基于Java注解为配置创建的ApplicationContext实例。</li>
</ul>
<p>创建Spring容器实例时，必须提供Spring容器管理的Bean的详细配置信息。Spring的配置信息通常采用xml配置文件来设置，因此，创建BeanFactory实例时，应该提供XML配置文件作为参数。</p>
<p>XML配置文件通常使用Resource对象传入。Resource接口是Spring提供的资源访问接口，通过使用该接口，Spring能够以简单、透明的方式访问磁盘、类路径以及网络上的资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ApplicationContext ctx=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </div><div class="line">ApplicationContext ctx1=<span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"c:/bean.xml"</span>);</div><div class="line">ApplicationContext ctx2=<span class="keyword">new</span> AnnotationConfigApplicationContext(ApplicationContextConfig.class);</div></pre></td></tr></table></figure>
<h1 id="二、Bean的生命周期"><a href="#二、Bean的生命周期" class="headerlink" title="二、Bean的生命周期"></a>二、Bean的生命周期</h1><h2 id="1、接口的分类"><a href="#1、接口的分类" class="headerlink" title="1、接口的分类"></a>1、接口的分类</h2><p>Bean的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类：</p>
<ol>
<li><p>Bean自身的方法：这个包括了Bean本身调用的方法和通过配置文件中<code>&lt;bean&gt;</code>的</p>
<ul>
<li>init-method</li>
<li>destroy-method指定的方法</li>
</ul>
</li>
<li><p>Bean级生命周期接口方法</p>
<ul>
<li><p>BeanNameAware</p>
</li>
<li><p>BeanFactoryAware</p>
</li>
<li><p>InitializingBean</p>
</li>
<li><p>DiposableBean</p>
<p>这些接口的方法</p>
</li>
</ul>
</li>
<li><p>容器级生命周期接口方法</p>
<ul>
<li><p>InstantiationAwareBeanPostProcessor </p>
</li>
<li><p>BeanPostProcessor </p>
<p>这两个接口，一般称它们的实现类为“后处理器”。</p>
</li>
</ul>
</li>
</ol>
<h2 id="2、启动步骤"><a href="#2、启动步骤" class="headerlink" title="2、启动步骤"></a>2、启动步骤</h2><ol>
<li><h3 id="Bean的建立"><a href="#Bean的建立" class="headerlink" title="Bean的建立"></a>Bean的建立</h3><p>容器寻找Bean的定义信息并将其实例化。看过源码都知道，容器首先将Bean的定义信息以BeanDefinition的形式存储，等第一次getBean的时候再将其实例化并完成下面的依赖注入过程。</p>
</li>
<li><h3 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h3><p>使用依赖注入，Spring将值和bean的引用注入到bean对应的属性中。</p>
</li>
<li><h3 id="BeanNameAware的setBeanName-："><a href="#BeanNameAware的setBeanName-：" class="headerlink" title="BeanNameAware的setBeanName()："></a>BeanNameAware的setBeanName()：</h3><p>如果bean实现了org.springframework.beans.BeanNameAware接口，Spring将bean的ID传递给setBeanName()方法。</p>
</li>
<li><h3 id="BeanFactoryAware的setBeanFactory-："><a href="#BeanFactoryAware的setBeanFactory-：" class="headerlink" title="BeanFactoryAware的setBeanFactory()："></a>BeanFactoryAware的setBeanFactory()：</h3><p>如果bean实现了org.springframework.beans.factory.BeanFactoryAware接口，Spring将调用setBeanName()方法，将BeanFactory容器实例传入。</p>
</li>
<li><h3 id="BeanPostProcessors的ProcessBeforeInitialization"><a href="#BeanPostProcessors的ProcessBeforeInitialization" class="headerlink" title="BeanPostProcessors的ProcessBeforeInitialization()"></a>BeanPostProcessors的ProcessBeforeInitialization()</h3><p>如果有org.springframework.beans.factory.config.BeanPostProcessors和Bean关联，那么其postProcessBeforeInitialization()方法将被将被调用。</p>
</li>
<li><h3 id="InitializingBean的afterPropertiesSet"><a href="#InitializingBean的afterPropertiesSet" class="headerlink" title="InitializingBean的afterPropertiesSet()"></a>InitializingBean的afterPropertiesSet()</h3><p>如果Bean类已实现org.springframework.beans.factory.InitializingBean接口，则执行他的afterProPertiesSet()方法。</p>
</li>
<li><h3 id="Bean定义文件中定义init-method："><a href="#Bean定义文件中定义init-method：" class="headerlink" title="Bean定义文件中定义init-method："></a>Bean定义文件中定义init-method：</h3><p>如果bean使用init-method生命了初始化方法，该方法也会被调用</p>
</li>
<li><h3 id="BeanPostProcessors的ProcessaAfterInitialization"><a href="#BeanPostProcessors的ProcessaAfterInitialization" class="headerlink" title="BeanPostProcessors的ProcessaAfterInitialization()"></a>BeanPostProcessors的ProcessaAfterInitialization()</h3><p>如果有任何的BeanPostProcessors实例与Bean实例关联，则执行BeanPostProcessors实例的ProcessaAfterInitialization()方法</p>
</li>
<li><h3 id="就绪"><a href="#就绪" class="headerlink" title="就绪"></a>就绪</h3><p>此时，Bean已准备就绪，可以被应用程序使用了，它们将一直驻留在容器中，直到该容器被销毁。</p>
</li>
<li><h3 id="DisposableBean的destroy"><a href="#DisposableBean的destroy" class="headerlink" title="DisposableBean的destroy()"></a>DisposableBean的destroy()</h3><p>在容器关闭时，如果Bean类有实现org.springframework.beans.factory.DisposableBean接口，Spring将调用他的destroy()方法。</p>
</li>
<li><h3 id="Bean定义文件中定义destroy-method"><a href="#Bean定义文件中定义destroy-method" class="headerlink" title="Bean定义文件中定义destroy-method"></a>Bean定义文件中定义destroy-method</h3><p>如果bean使用destroy-method生命了初始化方法，该方法也会被调用</p>
</li>
</ol>
<h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><p>这个生命周期是在是太复杂了，需要很长时间才能理清他们之间的逻辑关系。</p>
<h3 id="BeanNameAware、ApplicationContextAware和BeanFactoryAware"><a href="#BeanNameAware、ApplicationContextAware和BeanFactoryAware" class="headerlink" title="BeanNameAware、ApplicationContextAware和BeanFactoryAware"></a><strong>BeanNameAware、ApplicationContextAware和BeanFactoryAware</strong></h3><p>这三个接口放在一起写，是因为它们是一组的，作用相似。</p>
<p>“Aware”的意思是”感知到的”，那么这三个接口的意思也不难理解：</p>
<ol>
<li>实现BeanNameAware接口的Bean，在Bean加载的过程中可以获取到该Bean的id</li>
<li>实现ApplicationContextAware接口的Bean，在Bean加载的过程中可以获取到Spring的ApplicationContext，这个尤其重要，ApplicationContext是Spring应用上下文，从ApplicationContext中可以获取包括任意的Bean在内的大量Spring容器内容和信息</li>
<li>实现BeanFactoryAware接口的Bean，在Bean加载的过程中可以获取到加载该Bean的BeanFactory</li>
</ol>
<p>从上面的调用顺序可以看出，在bean实例化并设置属性之后，紧接着就是先调用这三个接口相关的方法。</p>
<h3 id="InitialingBean和DisposableBean"><a href="#InitialingBean和DisposableBean" class="headerlink" title="InitialingBean和DisposableBean"></a><strong>InitialingBean和DisposableBean</strong></h3><p>InitialingBean是一个接口，提供了一个唯一的方法afterPropertiesSet()。</p>
<p>DisposableBean也是一个接口，提供了一个唯一的方法destory()。</p>
<p>这两个接口是一组的，功能类似，因此放在一起：前者顾名思义在Bean属性都设置完毕后调用afterPropertiesSet()方法做一些初始化的工作，后者在Bean生命周期结束前调用destory()方法做一些收尾工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleBean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</div><div class="line">    <span class="keyword">private</span> String lifeCycleBeanName;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLifeCycleBeanName</span><span class="params">(String lifeCycleBeanName)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Enter LifecycleBean.setLifeCycleBeanName(), lifeCycleBeanName = "</span> + lifeCycleBeanName);</div><div class="line">        <span class="keyword">this</span>.lifeCycleBeanName = lifeCycleBeanName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Enter LifecycleBean.destroy()"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Enter LifecycleBean.afterPropertiesSet()"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beanStart</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Enter LifecycleBean.beanStart()"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beanEnd</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Enter LifecycleBean.beanEnd()"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Enter LifecycleBean.setLifeCycleBeanName(), lifeCycleBeanName = lifeCycleBean</div><div class="line">Enter LifecycleBean.afterPropertiesSet()</div><div class="line">Enter LifecycleBean.beanStart()</div><div class="line">Enter LifecycleBean.destroy()</div><div class="line">Enter LifecycleBean.beanEnd()</div></pre></td></tr></table></figure>
<p>执行结果和我们想的一样，afterPropertiesSet()方法就如同它的名字所表示的那样，是<strong>在Bean的属性都被设置完毕之后，才会调用</strong>。</p>
<ol>
<li>InitializingBean接口、Disposable接口可以和init-method、destory-method配合使用，接口执行顺序优先于配置</li>
<li>InitializingBean接口、Disposable接口底层使用<strong>类型强转.方法名()</strong>进行直接方法调用，init-method、destory-method底层<strong>使用反射</strong>。</li>
<li>一但bean实现了InitializingBean接口，那么这个bean的代码就和Spring耦合到一起了，因此不鼓励使用接口的形式。</li>
</ol>
<h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a><strong>BeanPostProcessor</strong></h3><p>之前的InitializingBean、DisposableBean、FactoryBean包括init-method和destory-method，针对的都是某个Bean控制其初始化的操作，而似乎没有一种办法可以针对每个Bean的生成前后做一些逻辑操作，PostProcessor则帮助我们做到了这一点</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/spring/6.png?raw=true" alt=""></p>
<p>BeanPostProcess接口有两个方法，都可以见名知意：</p>
<ol>
<li>postProcessBeforeInitialization：在初始化Bean之前</li>
<li>postProcessAfterInitialization：在初始化Bean之后</li>
</ol>
<p>值得注意的是，<strong>这两个方法是有返回值的，不要返回null，否则getBean的时候拿不到对象</strong>。</p>
<p>写一段测试代码，首先定义一个普通的Bean，为了后面能区分，给Bean加一个属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonBean</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String commonName;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommonName</span><span class="params">(String commonName)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.commonName = commonName;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Enter CommonBean.initMethod(), commonName = "</span> + commonName);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>定义一个PostProcess，实现BeanPostProcess接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> 五月的仓颉 http://www.cnblogs.com/xrq730/p/5721366.html</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostProcessorBean</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Enter ProcessorBean.postProcessAfterInitialization()\n"</span>);</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Enter ProcessorBean.postProcessBeforeInitialization()"</span>);</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>配置一个spring.xml，给CommonBean的commonName赋予不同的值以区分：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</div><div class="line">    xsi:schemaLocation="http://www.springframework.org/schema/beans</div><div class="line">    http://www.springframework.org/schema/beans/spring-beans-4.1.xsd"&gt;</div><div class="line">    </div><div class="line">    &lt;bean id="common0" class="org.xrq.bean.common.CommonBean" init-method="initMethod"&gt;</div><div class="line">        &lt;property name="commonName" value="common0"/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">    </div><div class="line">    &lt;bean id="common1" class="org.xrq.bean.common.CommonBean" init-method="initMethod"&gt;</div><div class="line">        &lt;property name="commonName" value="common1"/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">    </div><div class="line">    &lt;bean id="postProcessorBean" class="org.xrq.bean.processor.PostProcessorBean" /&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>运行一个Spring容器， 初始化结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Enter ProcessorBean.postProcessBeforeInitialization()</div><div class="line">Enter CommonBean.initMethod(), commonName = common0</div><div class="line">Enter ProcessorBean.postProcessAfterInitialization()</div><div class="line"></div><div class="line">Enter ProcessorBean.postProcessBeforeInitialization()</div><div class="line">Enter CommonBean.initMethod(), commonName = common1</div><div class="line">Enter ProcessorBean.postProcessAfterInitialization()</div><div class="line"></div><div class="line">Enter ProcessorBean.postProcessBeforeInitialization()</div><div class="line">Enter ProcessorBean.postProcessAfterInitialization()</div></pre></td></tr></table></figure>
<p>看到每个Bean初始化前后都会分别执行postProcessorBeforeInitiallization()方法与postProcessorAfterInitialization()方法，最后两行出现原因是，PostProcessorBean本身也是一个Bean。</p>
<p>注意:</p>
<ol>
<li><p>这两个方法分别叫before和after，而中间的Initialization过程就是上面说到的各个bean实现的InitializingBean接口和inti-method方法。</p>
</li>
<li><p>BeanFactory和ApplicationContext对待bean后置处理器稍有不同。ApplicationContext会自动检测在配置文件中实现了BeanPostProcessor接口的所有bean，并把它们注册为后置处理器，然后在容器创建bean的适当时候调用它，因此部署一个后置处理器同部署其他的bean并没有什么区别。而使用BeanFactory实现的时候，bean 后置处理器必须通过代码显式地去注册。</p>
<p>​</p>
</li>
</ol>
<h2 id="4、再次总结一下"><a href="#4、再次总结一下" class="headerlink" title="4、再次总结一下"></a>4、再次总结一下</h2><p>现在bean的生命周期各个阶段应该就很清晰了，上面的步骤对应一下几个大的阶段</p>
<h3 id="实例化与属性"><a href="#实例化与属性" class="headerlink" title="实例化与属性"></a>实例化与属性</h3><p>对应步骤1和2</p>
<h3 id="Aware相关的三个方法"><a href="#Aware相关的三个方法" class="headerlink" title="Aware相关的三个方法"></a>Aware相关的三个方法</h3><p>BeanNameAware、ApplicationContextAware和BeanFactoryAware三个接口的方法，对应上面的步骤3和4，应该还有一个的里面没有写上</p>
<h3 id="BeanPostProcessor后置处理器"><a href="#BeanPostProcessor后置处理器" class="headerlink" title="BeanPostProcessor后置处理器"></a>BeanPostProcessor后置处理器</h3><p>这个接口是容器级别的，对所有的bean都起作用，也就是说每个bean初始化的时候都会检测实现这个接口的bean。</p>
<p>而这个接口对应两个方法，postProcessBeforeInitialization和postProcessAfterInitialization，分别对应上面的步骤5和8，因为一个是before一个是after，而中间的步骤6和7就是下面的各个bean自己实现的接口或者方法</p>
<h3 id="InitializingBean接口和init-method"><a href="#InitializingBean接口和init-method" class="headerlink" title="InitializingBean接口和init-method"></a>InitializingBean接口和init-method</h3><p>InitializingBean接口可以和init-method配合使用，接口执行顺序优先于配置，也就是上面的步骤6和步骤7他们的区别上面已经介绍过。</p>
<h3 id="准备就绪"><a href="#准备就绪" class="headerlink" title="准备就绪"></a>准备就绪</h3><p>至此bean已经可以使用，可以看出大体分为上面的四个阶段</p>
<h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><p>销毁阶段相对简单，因为没有上面的后置处理器，就是Disposable接口的方法和destory-method，两者的顺序和左右与InitializingBean接口和init-method都很类似，对应上面的步骤10和步骤11.</p>
<h1 id="三、Bean的作用域"><a href="#三、Bean的作用域" class="headerlink" title="三、Bean的作用域"></a>三、Bean的作用域</h1><p>当通过Spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。<strong>Spring支持如下5种作用域：</strong></p>
<ul>
<li><strong>singleton</strong>：单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例</li>
<li><strong>prototype</strong>：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例</li>
<li><strong>request</strong>：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效</li>
<li><strong>session</strong>：对于每次HTTP Session，使用session定义的Bean豆浆产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效</li>
<li><strong>globalsession</strong>：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="1、定义不同作用域的java类"><a href="#1、定义不同作用域的java类" class="headerlink" title="1、定义不同作用域的java类"></a>1、定义不同作用域的java类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>  </div><div class="line"><span class="meta">@Scope</span>( <span class="string">"session"</span>)  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionObj</span> </span>&#123;  </div><div class="line">  </div><div class="line">&#125;  </div><div class="line"><span class="meta">@Component</span>  </div><div class="line"><span class="meta">@Scope</span>( <span class="string">"request"</span>)  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestObj</span> </span>&#123;  </div><div class="line">  </div><div class="line">&#125;  </div><div class="line"><span class="meta">@Component</span>  </div><div class="line"><span class="meta">@Scope</span>( <span class="string">"prototype"</span>)  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeObj</span> </span>&#123;  </div><div class="line">  </div><div class="line">&#125;  </div><div class="line"><span class="meta">@Component</span>  </div><div class="line"><span class="meta">@Scope</span>( <span class="string">"singleton"</span>)  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObj</span> </span>&#123;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2、注入到controller"><a href="#2、注入到controller" class="headerlink" title="2、注入到controller"></a>2、注入到controller</h3><p>由于controller是单例的，因此必须通过实现ApplicationContextAware接口，直接从容器中取出对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span>  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="keyword">private</span> RequestObj RequestObj;  </div><div class="line">  </div><div class="line">    <span class="keyword">private</span> SessionObj SessionObj;  </div><div class="line">  </div><div class="line">    <span class="keyword">private</span> PrototypeObj PrototypeObj;  </div><div class="line">  </div><div class="line">    <span class="keyword">private</span> SingletonObj SingletonObj;  </div><div class="line">  </div><div class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;  </div><div class="line">  </div><div class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)  </div><div class="line">    <span class="meta">@ResponseBody</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;  </div><div class="line">        print();  </div><div class="line">        <span class="keyword">return</span> <span class="string">"Welcome"</span>;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"first  time singleton is :"</span> + getSingletonObj());  </div><div class="line">        System.out.println(<span class="string">"second time singleton is :"</span> + getSingletonObj());  </div><div class="line">  </div><div class="line">        System.out.println(<span class="string">"first  time prototype is :"</span> + getPrototypeObj());  </div><div class="line">        System.out.println(<span class="string">"second time prototype is :"</span> + getPrototypeObj());  </div><div class="line">  </div><div class="line">        System.out.println(<span class="string">"first  time request is :"</span> + getRequestObj());  </div><div class="line">        System.out.println(<span class="string">"second time request is :"</span> + getRequestObj());  </div><div class="line">  </div><div class="line">        System.out.println(<span class="string">"first  time session is :"</span> + getSessionObj());  </div><div class="line">        System.out.println(<span class="string">"second time session is :"</span> + getSessionObj());  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span>  </span></div><div class="line">            <span class="keyword">throws</span> BeansException &#123;  </div><div class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> RequestObj <span class="title">getRequestObj</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> applicationContext.getBean(RequestObj.class);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequestObj</span><span class="params">(RequestObj requestObj)</span> </span>&#123;  </div><div class="line">        RequestObj = requestObj;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> SessionObj <span class="title">getSessionObj</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> applicationContext.getBean(SessionObj.class);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSessionObj</span><span class="params">(SessionObj sessionObj)</span> </span>&#123;  </div><div class="line">        SessionObj = sessionObj;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> PrototypeObj <span class="title">getPrototypeObj</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> applicationContext.getBean(PrototypeObj.class);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrototypeObj</span><span class="params">(PrototypeObj prototypeObj)</span> </span>&#123;  </div><div class="line">        PrototypeObj = prototypeObj;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> SingletonObj <span class="title">getSingletonObj</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> applicationContext.getBean(SingletonObj.class);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSingletonObj</span><span class="params">(SingletonObj singletonObj)</span> </span>&#123;  </div><div class="line">        SingletonObj = singletonObj;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3、运行结果"><a href="#3、运行结果" class="headerlink" title="3、运行结果"></a>3、运行结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用chrome第一次打印数据：  </span></div><div class="line">first  time singleton is :com.fb.po.SingletonObj@<span class="number">1e3223</span>e  </div><div class="line">second time singleton is :com.fb.po.SingletonObj@<span class="number">1e3223</span>e  </div><div class="line">first  time prototype is :com.fb.po.PrototypeObj@<span class="number">3e683f</span>  </div><div class="line">second time prototype is :com.fb.po.PrototypeObj@<span class="number">12e18</span>d7  </div><div class="line">first  time request is :com.fb.po.RequestObj@<span class="number">1</span>d45706  </div><div class="line">second time request is :com.fb.po.RequestObj@<span class="number">1</span>d45706  </div><div class="line">first  time session is :com.fb.po.SessionObj@<span class="number">9</span>a6b2e  </div><div class="line">second time session is :com.fb.po.SessionObj@<span class="number">9</span>a6b2e  </div><div class="line">  </div><div class="line">  </div><div class="line">  </div><div class="line"><span class="comment">//使用chrome打印第二次数据  </span></div><div class="line">first  time singleton is :com.fb.po.SingletonObj@<span class="number">1e3223</span>e  </div><div class="line">second time singleton is :com.fb.po.SingletonObj@<span class="number">1e3223</span>e  </div><div class="line">first  time prototype is :com.fb.po.PrototypeObj@<span class="number">122e5</span>be  </div><div class="line">second time prototype is :com.fb.po.PrototypeObj@<span class="number">192</span>add  </div><div class="line">first  time request is :com.fb.po.RequestObj@<span class="number">4</span>d1b6c  </div><div class="line">second time request is :com.fb.po.RequestObj@<span class="number">4</span>d1b6c  </div><div class="line">first  time session is :com.fb.po.SessionObj@<span class="number">9</span>a6b2e  </div><div class="line">second time session is :com.fb.po.SessionObj@<span class="number">9</span>a6b2e  </div><div class="line">  </div><div class="line">  </div><div class="line">  </div><div class="line"><span class="comment">//使用IE打印第三次数据  </span></div><div class="line">first  time singleton is :com.fb.po.SingletonObj@<span class="number">1e3223</span>e  </div><div class="line">second time singleton is :com.fb.po.SingletonObj@<span class="number">1e3223</span>e  </div><div class="line">first  time prototype is :com.fb.po.PrototypeObj@<span class="number">10f</span>1ecb  </div><div class="line">second time prototype is :com.fb.po.PrototypeObj@<span class="number">1</span>aeb990  </div><div class="line">first  time request is :com.fb.po.RequestObj@<span class="number">18</span>a1e7  </div><div class="line">second time request is :com.fb.po.RequestObj@<span class="number">18</span>a1e7  </div><div class="line">first  time session is :com.fb.po.SessionObj@<span class="number">12</span>d5c55  </div><div class="line">second time session is :com.fb.po.SessionObj@<span class="number">12</span>d5c55</div></pre></td></tr></table></figure>
<h3 id="4、结果分析"><a href="#4、结果分析" class="headerlink" title="4、结果分析"></a>4、结果分析</h3><p>从结果来看，单例的bean的三次的数据都是打印一样的（默认的bean的级别就是单例）；</p>
<p>prototype的bean每次的数据都是不一样的，每次请求的时候调用两次结果都不一样。</p>
<p>request的bean在每次request的时候都不一致，但是同一次request返回的数据是一致的。</p>
<p>session的bean在前两次结果一致，最后一次数据不一致，和session的节奏是一致的。</p>
<h3 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h3><p>如果不指定Bean的作用域，Spring默认使用singleton作用域。Java在创建Java实例时，需要进行内存申请；销毁实例时，需要完成垃圾回收，这些工作都会导致系统开销的增加。因此，prototype作用域Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成功，可以重复使用。因此，除非必要，否则尽量避免将Bean被设置成prototype作用域。</p>
<p>现在开发应用大多数都是无状态的，所以单例多线程是比较好的实现方式，多例的比较有利于保存状态，完全没必要。</p>
<h1 id="四、参考地址"><a href="#四、参考地址" class="headerlink" title="四、参考地址"></a>四、参考地址</h1><p><a href="http://gaddma.iteye.com/blog/2037038" target="_blank" rel="external">http://gaddma.iteye.com/blog/2037038</a></p>
<p><a href="http://www.cnblogs.com/zrtqsk/p/3735273.html" target="_blank" rel="external">http://www.cnblogs.com/zrtqsk/p/3735273.html</a></p>
<p><a href="http://developer.51cto.com/art/201104/255961.htm" target="_blank" rel="external">http://developer.51cto.com/art/201104/255961.htm</a></p>
<p><a href="http://www.cnblogs.com/xrq730/p/5721366.html" target="_blank" rel="external">http://www.cnblogs.com/xrq730/p/5721366.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中的四种引用]]></title>
      <url>http://yoursite.com/2016/12/16/Java/Java%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>在JDK1.2之后，Java对引用进行了扩充，将引用分为四种形式</p>
<ul>
<li>强引用 StrongReference</li>
<li>软引用 SoftReference</li>
<li>弱引用 WeakReference</li>
<li>虚引用 PhantomReference</li>
</ul>
<p>他们的引用强度也就是被GC回收的可能依次减弱。</p>
<h1 id="一、四中引用"><a href="#一、四中引用" class="headerlink" title="一、四中引用"></a>一、四中引用</h1><h2 id="1、强引用"><a href="#1、强引用" class="headerlink" title="1、强引用"></a>1、强引用</h2><p>最普遍的引用类型，只要强引用存在就一定不会被垃圾回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object object=<span class="keyword">new</span> Object();</div></pre></td></tr></table></figure>
<p>内存不足时，会直接抛出OOM但是也不会回收强引用</p>
<h2 id="2、软引用"><a href="#2、软引用" class="headerlink" title="2、软引用"></a>2、软引用</h2><p>软引用用来描述一些还<strong>有用</strong>但并非<strong>必需</strong>的对象。</p>
<p>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 </p>
<p>示例：实现学生信息查询操作时有两套数据操作的方案</p>
<ol>
<li>将得到的信息存放在内存中，后续查询则直接读取内存信息；<ul>
<li>优点：读取速度快</li>
<li>缺点：内存空间一直被占，若资源访问量不高，则浪费内存空间</li>
</ul>
</li>
<li>每次查询均从数据库读取，然后填充到TO返回。<ul>
<li>优点：内存空间将被GC回收，不会一直被占用</li>
<li>在GC发生之前已有的TO依然存在，但还是执行了一次数据库查询，浪费IO</li>
</ul>
</li>
</ol>
<p>SoftReference的特点是它的一个实例保存对一个Java对象的软引用，该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。也就是说，一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用。另外，一旦垃圾线程回收该Java对象之后，get()方法将返回null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">MyObject aRef = <span class="keyword">new</span>  MyObject();  </div><div class="line">SoftReference aSoftRef=<span class="keyword">new</span> SoftReference(aRef);  </div><div class="line">aRef = <span class="keyword">null</span>;</div><div class="line">ReferenceQueue queue = <span class="keyword">new</span>  ReferenceQueue();  </div><div class="line">SoftReference  ref=<span class="keyword">new</span>  SoftReference(aMyObject, queue);</div></pre></td></tr></table></figure>
<p>此时，对于这个MyObject对象，有两个引用路径，一个是来自SoftReference对象的软引用，一个来自变量aReference的强引用，所以这个MyObject对象是强可及对象。随即，我们可以结束aReference对这个MyObject实例的强引用.</p>
<p>此后，这个MyObject对象成为了软可及对象。如果垃圾收集线程进行内存垃圾收集，并不会因为有一个SoftReference对该对象的引用而始终保留该对象。</p>
<h2 id="3、弱引用"><a href="#3、弱引用" class="headerlink" title="3、弱引用"></a>3、弱引用</h2><p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。 </p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<h2 id="4、虚引用"><a href="#4、虚引用" class="headerlink" title="4、虚引用"></a>4、虚引用</h2><p>如果一个对象只具有虚引用，那么它就和没有任何引用一样，随时会被JVM当作垃圾进行GC。 </p>
<p>为一个对象设置虚引用的唯一目的就是能再这个对象被垃圾回收的时候收到一个系统通知。</p>
<p><strong>虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。</strong></p>
<h2 id="5、可达性分析"><a href="#5、可达性分析" class="headerlink" title="5、可达性分析"></a>5、可达性分析</h2><p>那现在问题来了，若一个对象的引用类型有多个，那到底如何判断它的可达性呢？其实规则如下：</p>
<ol>
<li>单条引用链的可达性以最弱的一个引用类型来决定；</li>
<li>多条引用链的可达性以最强的一个引用类型来决定；</li>
</ol>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/java/1.png?raw=true" alt=""></p>
<p> 我们假设图2中引用①和③为强引用，⑤为软引用，⑦为弱引用，对于对象5按照这两个判断原则，路径①-⑤取最弱的引用⑤，因此该路径对对象5的引用为软引用。同样，③-⑦为弱引用。在这两条路径之间取最强的引用，于是对象5是一个软可及对象</p>
<h1 id="二、java-lang-ref包"><a href="#二、java-lang-ref包" class="headerlink" title="二、java.lang.ref包"></a>二、java.lang.ref包</h1><p>关于引用的所有类都在这个包中</p>
<h2 id="1、四种Reference"><a href="#1、四种Reference" class="headerlink" title="1、四种Reference"></a>1、四种Reference</h2><p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/java/2.png?raw=true" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到Reference是继承自Object，其他三个引用都是它的子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftReference</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakReference</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomReference</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2、ReferenceQueue"><a href="#2、ReferenceQueue" class="headerlink" title="2、ReferenceQueue"></a>2、ReferenceQueue</h2><p>引用队列配合Reference的子类等使用，当引用对象所指向的内存空间被GC回收后，该引用对象则被追加到引用队列的末尾</p>
<p>作为一个Java对象，SoftReference对象除了具有保存软引用的特殊性之外，也具有Java对象的一般性。所以，当软可及对象被回收之后，虽然这个SoftReference对象的get()方法返回null,但这个SoftReference对象已经不再具有存在的价值，需要一个适当的清除机制，避免大量SoftReference对象带来的内存泄漏。在java.lang.ref包里还提供了ReferenceQueue。如果在创建SoftReference对象的时候，使用了一个ReferenceQueue对象作为参数提供给SoftReference的构造方法，如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ReferenceQueue queue = <span class="keyword">new</span>  ReferenceQueue();  </div><div class="line">SoftReference  ref=<span class="keyword">new</span>  SoftReference(aMyObject, queue);</div></pre></td></tr></table></figure>
<p>那么当这个SoftReference所软引用的aMyOhject被垃圾收集器回收的同时，ref所强引用的SoftReference对象被列入ReferenceQueue。也就是说，ReferenceQueue中保存的对象是Reference对象，而且是已经失去了它所软引用的对象的Reference对象。另外从ReferenceQueue这个名字也可以看出，它是一个队列，当我们调用它的poll()方法的时候，如果这个队列中不是空队列，那么将返回队列前面的那个Reference对象。</p>
<p>在任何时候，我们都可以调用ReferenceQueue的poll()方法来检查是否有它所关心的非强可及对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。利用这个方法，我们可以检查哪个SoftReference所软引用的对象已经被回收。于是我们可以把这些失去所软引用的对象的SoftReference对象清除掉。常用的方式为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SoftReference ref = <span class="keyword">null</span>;  </div><div class="line"><span class="keyword">while</span> ((ref = (EmployeeRef) q.poll()) != <span class="keyword">null</span>) &#123;  </div><div class="line">    <span class="comment">// 清除ref  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3、WeakHashMap"><a href="#3、WeakHashMap" class="headerlink" title="3、WeakHashMap"></a>3、WeakHashMap</h2><p>在Java集合中有一种特殊的Map类型—WeakHashMap，在这种Map中存放了键对象的弱引用，当一个键对象被垃圾回收器回收时，那么相应的值对象的引用会从Map中删除。WeakHashMap能够节约存储空间，可用来缓存那些非必须存在的数据。关于Map接口的一般用法。</p>
<p>WeakHashMap是以弱引用为键实现的HsahMap。更精确地说，对于一个给定的key对象，其对应的value对象的存在并不能阻止该key对象被GC。GC某个key对象时，它所在的条目会一并被从Map中删除。这是WeakHashMap与其他HashMap最大的不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    WeakHashMap&lt;String,String&gt; weakHashMap=<span class="keyword">new</span> WeakHashMap&lt;String, String&gt;();  </div><div class="line">       String [] sts=<span class="keyword">new</span> String[<span class="number">10</span>];  </div><div class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;  </div><div class="line">           <span class="keyword">if</span>(i%<span class="number">10</span>==<span class="number">0</span>) &#123;  </div><div class="line">               sts[i/<span class="number">10</span>]=<span class="keyword">new</span> String(<span class="string">""</span>+i);  </div><div class="line">               weakHashMap.put(sts[i/<span class="number">10</span>], <span class="keyword">new</span> String(<span class="string">""</span>+i));  </div><div class="line">           &#125;  </div><div class="line">           <span class="keyword">else</span>  </div><div class="line">               weakHashMap.put(<span class="keyword">new</span> String(<span class="string">""</span>+i), <span class="keyword">new</span> String(<span class="string">""</span>+i));  </div><div class="line">       &#125;  </div><div class="line"> </div><div class="line">       <span class="comment">// 催促垃圾回收器工作  </span></div><div class="line">       System.gc();  </div><div class="line">       <span class="comment">// 把CPU让给垃圾回收器线程  </span></div><div class="line">       Thread.sleep(<span class="number">8000</span>);  </div><div class="line"> </div><div class="line">       Iterator&lt;String&gt; iterator=weakHashMap.keySet().iterator();  </div><div class="line">       <span class="keyword">while</span>(iterator.hasNext())&#123;  </div><div class="line">           System.out.println(iterator.next());  </div><div class="line">       &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当执行System.gc()方法后，垃圾回收器只会回收那些仅仅持有弱引用的Key对象。id可以被10整除的Key对象持有强引用，因此不会被回收。</p>
<h1 id="三、参考地址"><a href="#三、参考地址" class="headerlink" title="三、参考地址"></a>三、参考地址</h1><p><a href="http://www.cnblogs.com/fsjohnhuang/p/4268411.html" target="_blank" rel="external">http://www.cnblogs.com/fsjohnhuang/p/4268411.html</a></p>
<p><a href="http://blog.csdn.net/lyfi01/article/details/6415726" target="_blank" rel="external">http://blog.csdn.net/lyfi01/article/details/6415726</a></p>
<p><a href="http://blog.csdn.net/coolwxb/article/details/7939246" target="_blank" rel="external">http://blog.csdn.net/coolwxb/article/details/7939246</a></p>
<p><a href="http://yizhenn.iteye.com/blog/2317184" target="_blank" rel="external">http://yizhenn.iteye.com/blog/2317184</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中的异常机制]]></title>
      <url>http://yoursite.com/2016/12/15/Java/Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="一、异常"><a href="#一、异常" class="headerlink" title="一、异常"></a>一、异常</h1><h2 id="1、类继承结构"><a href="#1、类继承结构" class="headerlink" title="1、类继承结构"></a>1、类继承结构</h2><p>在 Java 中，所有的异常都有一个共同的祖先 Throwable（可抛出）。Throwable 指定代码中可用异常传播机制通过 Java 应用程序传输的任何问题的共性。</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/java/3.png?raw=true" alt=""></p>
<p>从图中可以看出，Throwable有两个子类，Error(错误)和Exception(异常)。二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p>
<ul>
<li><p>Error（错误）:程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</p>
<p>这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。</p>
</li>
<li><p>Exception（异常）:是程序本身可以处理的异常。</p>
<p> Exception 类有一个重要的子类 RuntimeException。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常（NullPointerException、ArithmeticException）和 ArrayIndexOutOfBoundException。</p>
</li>
<li><p>注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。</p>
</li>
</ul>
<h2 id="2、运行时异常与非运行时异常"><a href="#2、运行时异常与非运行时异常" class="headerlink" title="2、运行时异常与非运行时异常"></a>2、运行时异常与非运行时异常</h2><p>通常，Java的异常(包括Exception和Error)分为<strong>可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）</strong>。这两个概念和运行时异常与非运行时异常差不多，但是有一点区别。</p>
<ul>
<li><p>可查异常（编译器要求必须处置的异常）：也就是非运行时异常。正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。</p>
<p>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p>
</li>
<li><p>不可查异常(编译器不要求强制处置的异常):包括运行时异常（RuntimeException与其子类）和错误（Error）。</p>
</li>
</ul>
<p>下图中粉色的就是可检查异常，(checked exceptions)。而不可查异常就是运行时异常加上错误。</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/java/4.png?raw=true" alt=""></p>
<h1 id="二、异常处理机制"><a href="#二、异常处理机制" class="headerlink" title="二、异常处理机制"></a>二、异常处理机制</h1><p>与异常有关的几个关键字有</p>
<ul>
<li>throws</li>
<li>throw</li>
<li>try</li>
<li>catch</li>
<li>finally</li>
</ul>
<h2 id="1、throws与throw"><a href="#1、throws与throw" class="headerlink" title="1、throws与throw"></a>1、throws与throw</h2><p> throws总是出现在一个函数头中，用来标明该成员函数可能抛出的各种异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>throw总是出现在函数体中，用来抛出一个异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序会在throw语句后立即终止，它后面的语句执行不到，然后在包含它的所有try块中（可能在上层调用函数中）从里向外寻找含有与其匹配的catch子句的try块。</p>
<p>如果一个函数体中有throw语句或者调用了一个带有throws的方法，那么这个方法也必须加上throws表明它可能抛出的异常。</p>
<h2 id="2、try与catch"><a href="#2、try与catch" class="headerlink" title="2、try与catch"></a>2、try与catch</h2><p>如果方法不想抛出异常，可以在自己的函数体内将可能出现的异常捕获并处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        fun1();</div><div class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>catch语句的参数类似于方法的声明，包括一个例外类型和一个例外对象。例外类型必须为Throwable类的子类，它指明了catch语句所处理的例外类型，例外对象则由运行时系统在try所指定的代码块中生成并被捕获，大括号中包含对象的处理，其中可以调用对象的方法。  </p>
<p>catch语句可以有多个，分别处理不同类的例外。Java运行时系统从上到下分别对每个catch语句处理的例外类型进行检测，直到找到类型相匹配的catch语句为止。这里，类型匹配指catch所处理的例外类型与生成的例外对象的类型完全一致或者是它的父类，因此，catch语句的排列顺序应该是从特殊到一般。  </p>
<h2 id="3、finally"><a href="#3、finally" class="headerlink" title="3、finally"></a>3、finally</h2><p>try所限定的代码中，当抛弃一个例外时，其后的代码不会被执行。通过finally语句可以指定一块代码。无论try所指定的程序块中抛弃或不抛弃例外，也无论catch语句的例外类型是否与所抛弃的例外的类型一致，finally所指定的代码都要被执行，它提供了统一的出口。通常在finally语句中可以进行资源的清除工作。如关闭打开的文件等。  </p>
<ul>
<li>不论是return还是抛出异常，finally中的代码都会被执行。</li>
</ul>
<ul>
<li>如果执行到return后再执行finally，return的值不会被改变</li>
</ul>
<h1 id="三、虚拟机错误"><a href="#三、虚拟机错误" class="headerlink" title="三、虚拟机错误"></a>三、虚拟机错误</h1><p>开始对这里的理解有些误区，以为虚拟机抛出的也是异常，经过上面的学习才知道在类继承关系上是属于错误。从控制台中也可以看出确实是Error二部是Exception。</p>
<p>在了解虚拟机异常之前，首先要知道JVM的运行时数据区域</p>
<ol>
<li>程序计数器：是一块较小的内存空间，线程间相互独立</li>
<li>Java虚拟机栈：也是线程私有的。每个方法执行的时候都会有一个栈帧，方法调用到执行完成的过程就是栈帧从虚拟机栈中入栈和出栈的过程。</li>
<li>本地方法栈：与虚拟机栈作用相似，用于Native方法，有些虚拟机中将二者合二为一。</li>
<li>Java堆：内存中最大的一块，所有新对象都在这里创建。还可以细分为新生代和老年代。</li>
<li>方法区：和堆一样，是所有线程共享的，用于存储已经被加载的类信息、常量、静态变量等。也称为永久代。</li>
<li>运行时常量池：方法区的一部分，存放编译期生成的各种字面量和符号引用。</li>
<li>直接内存：直接内存并不是虚拟机内存的一部分，也不虚拟机的分配。比如NIO中的直接内存</li>
</ol>
<p>JVM主要会产生OutOfMemory和StackOverFlow两种异常，严格的说，是java.lang.StackOverflowError和java.lang.OutOfMemoryError两种错误。</p>
<p>顺便说一下，下面的程序主要来自深入理解Java虚拟机这本书，SOF这个异常的例子确实是运行试验过，不过OOM这个异常把电脑跑的卡死了都没出现，不知道是不是因为虚拟机的参数设置问题还是怎么了。</p>
<h2 id="1、Java堆溢出"><a href="#1、Java堆溢出" class="headerlink" title="1、Java堆溢出"></a>1、Java堆溢出</h2><p>堆是存放实例对象和数组的地方，当对象多过设置的堆大小，同时避免GC回收即可。最大内存块Xmx和最小内存块Xms一样，堆就不可扩展了。将new出的对象放到List中可防止GC回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * VM args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError  </div><div class="line"> * Xms equals Xmx lead to head value can't extend </div><div class="line"> */  </div><div class="line"><span class="keyword">import</span> java.util.ArrayList;  </div><div class="line"><span class="keyword">import</span> java.util.List;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;  </div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;  </div><div class="line">      </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();  </div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </div><div class="line">            list.add(<span class="keyword">new</span> OOMObject());  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2、虚拟机栈和本地方法栈溢出"><a href="#2、虚拟机栈和本地方法栈溢出" class="headerlink" title="2、虚拟机栈和本地方法栈溢出"></a>2、虚拟机栈和本地方法栈溢出</h2><p>HotSpot虚拟机不区分虚拟机栈和本地方法栈</p>
<p>关于虚拟机栈和本地方法栈，Java虚拟机规范种描述了两种异常：</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所能承受的最大深度，将抛出StackOverFlow异常</li>
<li>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemory异常</li>
</ul>
<h3 id="StackOverFlow"><a href="#StackOverFlow" class="headerlink" title="StackOverFlow"></a>StackOverFlow</h3><p>当请求的栈深度超过JVM允许最大深度即可，用Xss设置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> *VM args: -Xss128K </div><div class="line"> */  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;  </div><div class="line">        stackLength++;  </div><div class="line">        stackLeak();  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;  </div><div class="line">        JavaVMStackSOF oom = <span class="keyword">new</span> JavaVMStackSOF();  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            oom.stackLeak();  </div><div class="line">        &#125; <span class="keyword">catch</span>(Throwable e) &#123;  </div><div class="line">            System.out.println(<span class="string">"stack length:"</span> + oom.stackLength);  </div><div class="line">            <span class="keyword">throw</span> e;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在递归时如果结束判断写的有问题就会出现这种情况</p>
<h3 id="OutOfMemory"><a href="#OutOfMemory" class="headerlink" title="OutOfMemory"></a>OutOfMemory</h3><p>不断创建线程，因为虚拟机栈是线程私有的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * VM args: -Xss2M </div><div class="line"> */  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackOOM</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dontStop</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </div><div class="line">              </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeakByThread</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </div><div class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;  </div><div class="line">                <span class="meta">@Override</span>  </div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">                    dontStop();  </div><div class="line">                &#125;  </div><div class="line">            &#125;);  </div><div class="line">            thread.start();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        JavaVMStackOOM oom = <span class="keyword">new</span> JavaVMStackOOM();  </div><div class="line">        oom.stackLeakByThread();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。</p>
<p>因为每个线程分配到的栈容量越大，可以建立的线程数量就越少，建立线程时就越容易把剩下的内存耗尽。</p>
<h2 id="3、方法区和运行时常量池溢出"><a href="#3、方法区和运行时常量池溢出" class="headerlink" title="3、方法区和运行时常量池溢出"></a>3、方法区和运行时常量池溢出</h2><p>由于运行时常量池是方法区的一部分，所以他们属于一类</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。</p>
<p>当前很多主流框架如Spring、Hibernate在对类进行增强时，都用到了CGLib这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可以载入内存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * VM args: -XX:PermSize=10M -XX:MaxPermSize=10M </div><div class="line"> */  </div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;  </div><div class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;  </div><div class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;  </div><div class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMethodAreaOOM</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </div><div class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();  </div><div class="line">            enhancer.setSuperclass(OOMObject.class);  </div><div class="line">            enhancer.setUseCache(<span class="keyword">false</span>);  </div><div class="line">            enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;  </div><div class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;  </div><div class="line">                    <span class="keyword">return</span> proxy.invokeSuper(obj, args);  </div><div class="line">                &#125;  </div><div class="line">            &#125;);  </div><div class="line">            enhancer.create();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">static</span> class <span class="title">OOMObject</span><span class="params">()</span> </span>&#123;  </div><div class="line">      </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>CGLib是一个强大的，高性能，高质量的Code生成类库，它可以在运行期扩展Java类与实现Java接口。Hibernate用它来实现PO(Persistent Object 持久化对象)字节码的动态生成。</p>
</blockquote>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>使用String.interm()填充常量池。intern的作用是如果该常量不再常量池中，则添加到常量池，否则返回该常量引用。常量池是方法区一部分，运行时可限制方法区PermSize和最大方法区MaxPermSize大小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * VM args: -XX:PermSize=10M -XX:MaxPermSize=10M </div><div class="line"> */  </div><div class="line">   </div><div class="line"><span class="keyword">import</span> java.util.List;  </div><div class="line"><span class="keyword">import</span> java.util.ArrayList;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="comment">//keep reference,avoid GC collect  </span></div><div class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();  </div><div class="line">        <span class="comment">//10M PermSize in integer range enough to lead to OOM  </span></div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;  </div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </div><div class="line">            list.add(String.valueOf(i++).intern());  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结一下</p>
<table>
<thead>
<tr>
<th>溢出点</th>
<th>异常</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>虚拟机栈</td>
<td>SOF</td>
<td>方法递归调用</td>
</tr>
<tr>
<td>虚拟机栈</td>
<td>OOM</td>
<td>线程太多</td>
</tr>
<tr>
<td>方法区或运行时常量池</td>
<td>OOM</td>
<td>类太多或常量太多</td>
</tr>
<tr>
<td>堆</td>
<td>OOM</td>
<td>对象太多</td>
</tr>
</tbody>
</table>
<h1 id="四、参考地址"><a href="#四、参考地址" class="headerlink" title="四、参考地址"></a>四、参考地址</h1><p><a href="http://blog.csdn.net/renfufei/article/details/16344847" target="_blank" rel="external">http://blog.csdn.net/renfufei/article/details/16344847</a></p>
<p><a href="http://blog.csdn.net/hguisu/article/details/6155636" target="_blank" rel="external">http://blog.csdn.net/hguisu/article/details/6155636</a></p>
<p><a href="http://blog.csdn.net/ronawilliam/article/details/3299676" target="_blank" rel="external">http://blog.csdn.net/ronawilliam/article/details/3299676</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中的Object类与深浅克隆]]></title>
      <url>http://yoursite.com/2016/12/15/Java/Object%E7%B1%BB%E4%B8%8E%E6%B7%B1%E6%B5%85%E5%85%8B%E9%9A%86/</url>
      <content type="html"><![CDATA[<p>在Java中，Object类是所有类的父类，任何类都默认继承Object。</p>
<h1 id="一、Object的中的公有方法"><a href="#一、Object的中的公有方法" class="headerlink" title="一、Object的中的公有方法"></a>一、Object的中的公有方法</h1><p>1.8中的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> java.lang;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        registerNatives();</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">                                <span class="string">"nanosecond timeout value out of range"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</div><div class="line">            timeout++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        wait(timeout);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        wait(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="1、getClass-方法"><a href="#1、getClass-方法" class="headerlink" title="1、getClass()方法"></a>1、getClass()方法</h2><p>final方法，说明子类中不可重写。</p>
<p>获得运行时类型。</p>
<h2 id="2、hashCode-方法"><a href="#2、hashCode-方法" class="headerlink" title="2、hashCode()方法"></a>2、hashCode()方法</h2><p>该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。</p>
<p>Effective Java中提到：</p>
<blockquote>
<p>在每个覆盖了equals方法的类中，也必须覆盖hashCode方法。给不同的对象产生不同的hashCode，有助于提高散列表的性能。</p>
</blockquote>
<p>至于如何才能为不同的对象产生不同的散列码，先看一下String类中的hashCode方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h = hash;</div><div class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">char</span> val[] = value;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</div><div class="line">            h = <span class="number">31</span> * h + val[i];</div><div class="line">        &#125;</div><div class="line">        hash = h;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> h;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>计算方法为：s[0]*31^(n-1) + s[1]*31^(n-2) + … + s[n-1]。</p>
<p>这个书中给出的计算散列码的建议很相似，都是把关键的域乘31再相加。至于为什么是31，书中给出的解释如下：</p>
<blockquote>
<p>因为它是一个奇素数。如果乘的是偶数，并且乘法溢出的话，信息就会丢失，因为与2相乘等价于移位运算。使用素数的好处并不明显，但是习惯上都使用素数来计算散列结果。31有个很好的特性，即用移位和减法来替代乘法，可以得到更好的性能：</p>
<p>31 * i == (i &lt;&lt; 5) - i。现代的JVM可以自动完成这种优化。</p>
</blockquote>
<h2 id="3、equals方法"><a href="#3、equals方法" class="headerlink" title="3、equals方法"></a>3、equals方法</h2><p>该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。</p>
<h2 id="4、clone-方法"><a href="#4、clone-方法" class="headerlink" title="4、clone()方法"></a>4、clone()方法</h2><p>保护方法，实现对象的浅克隆，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。</p>
<p>主要是JAVA里除了8种基本类型传参数是值传递，其他的类对象传参数都是引用传递，我们有时候不希望在方法里讲参数改变，这是就需要在类中复写clone方法。</p>
<p>这里涉及到深克隆与浅克隆的问题。</p>
<h2 id="5、toString-方法"><a href="#5、toString-方法" class="headerlink" title="5、toString()方法"></a>5、toString()方法</h2><p>默认返回的是改对象的类名+@+内存地址，一般都会在子类中重写</p>
<h2 id="6、-notify-与notifyAll-方法"><a href="#6、-notify-与notifyAll-方法" class="headerlink" title="6、 notify()与notifyAll()方法"></a>6、 notify()与notifyAll()方法</h2><p>notify方法唤醒在该对象上等待的某个线程。</p>
<p>notifyAll方法唤醒在该对象上等待的所有线程。</p>
<p>两个方法都是final的，子类不可以重写</p>
<h2 id="7、wait方法"><a href="#7、wait方法" class="headerlink" title="7、wait方法"></a>7、wait方法</h2><p>wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。</p>
<p>调用该方法后当前线程进入睡眠状态，直到以下事件发生。</p>
<ol>
<li>其他线程调用了该对象的notify方法。</li>
<li>其他线程调用了该对象的notifyAll方法。</li>
<li>其他线程调用了interrupt中断该线程。</li>
<li>时间间隔到了。</li>
</ol>
<p>此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。</p>
<p>也是final的，不可重写</p>
<h2 id="8、finalize-方法"><a href="#8、finalize-方法" class="headerlink" title="8、finalize()方法"></a>8、finalize()方法</h2><p>当垃圾回收时用于释放资源，不建议使用</p>
<h1 id="二、wait与notify方法"><a href="#二、wait与notify方法" class="headerlink" title="二、wait与notify方法"></a>二、wait与notify方法</h1><p>关于这两个方法在生产着消费者模型和三个线程循环打印abc的文章中已经介绍了，前几天在腾讯面试的时候被问到一个线程执行notify之后后面的代码还会运行吗？ 当时没有答上来，回来实际运行了一下，在循环打印ABC的代码后面加了一句话：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">        <span class="keyword">synchronized</span>(lock)&#123;</div><div class="line">            <span class="keyword">while</span>(cnt%<span class="number">3</span>!=num)&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    lock.wait();</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            System.out.println((<span class="keyword">char</span>)(<span class="string">'A'</span>+num));</div><div class="line">            cnt++;</div><div class="line">            lock.notifyAll();</div><div class="line">            System.out.println(<span class="string">"aaaaa"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">A</div><div class="line">aaaaa</div><div class="line">B</div><div class="line">aaaaa</div><div class="line">C</div><div class="line">aaaaa</div></pre></td></tr></table></figure>
<p>可以看出后面的代码不但会运行，而且肯定在另一个线程运行直线被执行。</p>
<p>这里涉及到线程的几个状态，在一个线程wait之后，应该是处于阻塞状态。</p>
<p>而一个调用notify的线程肯定是处于运行状态的现在正在持有这个锁，他执行notify之后其实并不会让出线程，因为加锁的代码段还没有执行完毕，notify只是将一个等待队列中的线程唤醒，也就是说使这个线程从阻塞状态变为就绪状态，而不是运行状态。</p>
<p>只有代码段的所有代码执行完毕，包括notify下面的代码，该线程才会让出锁，使得过程那个被唤醒的线程去持有锁。</p>
<h1 id="三、深克隆与浅克隆"><a href="#三、深克隆与浅克隆" class="headerlink" title="三、深克隆与浅克隆"></a>三、深克隆与浅克隆</h1><p>Object类里定义了clone方法，关于对象的克隆，分为深克隆与浅克隆。</p>
<p>一个对象要被克隆，有两个前提：</p>
<ol>
<li>实现Cloneable接口，如果没有，会抛出CloneNotSupportedException异常</li>
<li>重写Object类中的clone()方法</li>
</ol>
<h2 id="1、复制对象与复制引用"><a href="#1、复制对象与复制引用" class="headerlink" title="1、复制对象与复制引用"></a>1、复制对象与复制引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Person p = <span class="keyword">new</span> Person(<span class="number">23</span>, <span class="string">"zhang"</span>);  </div><div class="line">Person p1 = p;  </div><div class="line">  </div><div class="line">System.out.println(p);  </div><div class="line">System.out.println(p1);</div></pre></td></tr></table></figure>
<p>从打印对象可以看出，p和p1的内存地址是相同的，也就是说他们只想相同的对象。</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/java/5.png?raw=true" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Person p = <span class="keyword">new</span> Person(<span class="number">23</span>, <span class="string">"zhang"</span>);  </div><div class="line">Person p1 = (Person) p.clone();  </div><div class="line">  </div><div class="line">System.out.println(p);  </div><div class="line">System.out.println(p1);</div></pre></td></tr></table></figure>
<p>这样才是真正的克隆了一下对象</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/java/6.png?raw=true" alt=""></p>
<h2 id="2、深克隆与浅克隆"><a href="#2、深克隆与浅克隆" class="headerlink" title="2、深克隆与浅克隆"></a>2、深克隆与浅克隆</h2><p>上面的代码中，Person类只有两个成员变量，分别是int型和String类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;  </div><div class="line">      </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age ;  </div><div class="line">    <span class="keyword">private</span> String name;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.age = age;  </div><div class="line">        <span class="keyword">this</span>.name = name;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;&#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> age;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> name;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;  </div><div class="line">        <span class="keyword">return</span> (Person)<span class="keyword">super</span>.clone();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>age是基本数据类型，所以对它的拷贝很简单，直接将值复制过来就可以。</p>
<p>但是name就不一样了，String是一个对象，对它的克隆就有两种</p>
<ul>
<li>直接将源对象中的name的引用值拷贝给新对象的name字段</li>
<li>根据原Person对象中的name指向的字符串对象创建一个新的相同的字符串对象，将这个新字符串对象的引用赋给新拷贝的Person对象的name字段</li>
</ul>
<p>这两种方法分别被称为浅克隆与深克隆</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/java/7.png?raw=true" alt=""></p>
<p>在Object类中的clone方法默认实现的是浅克隆</p>
<h2 id="3、重写clone方法实现深克隆"><a href="#3、重写clone方法实现深克隆" class="headerlink" title="3、重写clone方法实现深克隆"></a>3、重写clone方法实现深克隆</h2><p>现在为了要在clone对象时进行深拷贝， 那么就要Clonable接口，覆盖并实现clone方法，除了调用父类中的clone方法得到新的对象， 还要将该类中的引用变量也clone出来。如果只是用Object中默认的clone方法，是浅拷贝的</p>
<p>但是有一个问题：</p>
<blockquote>
<p>如果想要深拷贝一个对象， 这个对象必须要实现Cloneable接口，实现clone方法，并且在clone方法内部，把该对象引用的其他对象也要clone一份 ， 这就要求这个被引用的对象必须也要实现Cloneable接口并且实现clone方法。</p>
</blockquote>
<p>所以完全的深拷贝几乎是不可能的</p>
<h1 id="四、参考地址"><a href="#四、参考地址" class="headerlink" title="四、参考地址"></a>四、参考地址</h1><p><a href="http://www.cnblogs.com/dracohan/p/5383435.html" target="_blank" rel="external">http://www.cnblogs.com/dracohan/p/5383435.html</a></p>
<p><a href="http://blog.csdn.net/cws1214/article/details/52193341" target="_blank" rel="external">http://blog.csdn.net/cws1214/article/details/52193341</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中的死锁]]></title>
      <url>http://yoursite.com/2016/12/12/MultiThreading/Java%E4%B8%AD%E7%9A%84%E6%AD%BB%E9%94%81/</url>
      <content type="html"><![CDATA[<h1 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h1><p>关于死锁的经典描述就是哲学家就餐问题：</p>
<blockquote>
<p>假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌中间有一大碗意大利面，每两个哲学家之间有一只餐叉。因为用一只餐叉很难吃到意大利面，所以假设哲学家必须用两只餐叉吃东西。他们只能使用自己左右手边的那两只餐叉。哲学家就餐问题有时也用米饭和筷子而不是意大利面和餐叉来描述，因为很明显，吃米饭必须用两根筷子。</p>
<p>哲学家从来不交谈，这就很危险，可能产生死锁，每个哲学家都拿着左手的餐叉，永远都在等右边的餐叉（或者相反）。</p>
</blockquote>
<h1 id="二、产生"><a href="#二、产生" class="headerlink" title="二、产生"></a>二、产生</h1><h2 id="1、锁顺序死锁"><a href="#1、锁顺序死锁" class="headerlink" title="1、锁顺序死锁"></a>1、锁顺序死锁</h2><h3 id="产生"><a href="#产生" class="headerlink" title="产生"></a>产生</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object left=<span class="keyword">new</span> Object();</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object right=<span class="keyword">new</span> Object();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftRight</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(left)&#123;</div><div class="line">        <span class="keyword">synchronized</span>(right)&#123;</div><div class="line">            <span class="comment">//doSmoething</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RightLeft</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(right)&#123;</div><div class="line">        <span class="keyword">synchronized</span>(left)&#123;</div><div class="line">            <span class="comment">//doSmoethingElse</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者下面这种</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">(Object a, Object b)</span></span>&#123;	</div><div class="line">  	<span class="keyword">synchronized</span>(a)&#123;</div><div class="line">    <span class="keyword">synchronized</span>(b)&#123;</div><div class="line">        <span class="comment">//</span></div><div class="line">    &#125;</div><div class="line">&#125;    	</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>如果执行顺序不当，就会发生死锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">demo(a, b);</div><div class="line">demo(b, a);</div></pre></td></tr></table></figure>
<h3 id="解决方法-顺序加锁"><a href="#解决方法-顺序加锁" class="headerlink" title="解决方法-顺序加锁"></a>解决方法-顺序加锁</h3><p>解决这种问题的方法就是按顺序加锁，在制定锁的顺序的时候，可以使用System.identityHashCode()方法，该方法返回Object.hashCode返回的值，这样每次都先给hashCode值小的对象上锁就可以避免发生死锁的可能性。</p>
<p>有很小的概率，两个对象的hashCode返回值相同，为了避免这种情况，可以使用”加时赛锁”。在获得两个锁之前，先获得‘’加时赛‘锁，从而保证每次只有一个线程以未知的顺序获得这两个锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object tieLock=<span class="keyword">new</span> Object();</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">(Object a, Object b)</span></span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> aHash=System.identityHashCode(a);</div><div class="line">    <span class="keyword">int</span> bHash=System.identityHashCode(b);</div><div class="line">    <span class="keyword">if</span>(aHash&lt;bHash)&#123;</div><div class="line">        <span class="keyword">synchronized</span>(a)&#123;</div><div class="line">            <span class="keyword">synchronized</span>(b)&#123;</div><div class="line">                <span class="comment">//</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(aHash&gt;bHash)&#123;</div><div class="line">        <span class="keyword">synchronized</span>(b)&#123;</div><div class="line">            <span class="keyword">synchronized</span>(a)&#123;</div><div class="line">                <span class="comment">//</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(tieLock)&#123;</div><div class="line">            <span class="keyword">synchronized</span>(a)&#123;</div><div class="line">                <span class="keyword">synchronized</span>(b)&#123;</div><div class="line">                    <span class="comment">//</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;    	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2、协作对象之间死锁"><a href="#2、协作对象之间死锁" class="headerlink" title="2、协作对象之间死锁"></a>2、协作对象之间死锁</h2><h3 id="产生-1"><a href="#产生-1" class="headerlink" title="产生"></a>产生</h3><p>很多获取锁的操作并不像上面那么明显，这两个锁并不一定在用一个方法中被获取</p>
<blockquote>
<p>如果在持有锁时调用某个外部方法，在这个外部方法中可能或获取其他锁（可能造成死锁），或者阻塞时间过长，导致其他线程无法及时获得当前被持有的锁。</p>
</blockquote>
<h3 id="解决方法-开放调用"><a href="#解决方法-开放调用" class="headerlink" title="解决方法-开放调用"></a>解决方法-开放调用</h3><p>在调用某个方法时不需要持有锁，那么这种调用被称为<strong>开放调用</strong>。</p>
<p>是同步代码块仅被用于那些涉及共享状态的操作，而不是加在整个方法上。</p>
<blockquote>
<p>在程序中应尽量使用开放调用。与那些在持有锁时调用外部方法的程序相比，更容易对于依赖于开放性调用的程序进行死锁分析</p>
</blockquote>
<h1 id="三、避免"><a href="#三、避免" class="headerlink" title="三、避免"></a>三、避免</h1><p>除了上面的几种情况，还有一种方法可以检测死锁和从死锁中恢复过来。</p>
<p>可以使用显示锁来替代内置锁，Lock类的tryLock方法也能避免死锁，在另一篇中已经介绍过了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[线程安全与锁]]></title>
      <url>http://yoursite.com/2016/12/11/MultiThreading/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81/</url>
      <content type="html"><![CDATA[<p>线程安全：</p>
<blockquote>
<p>当多个线程访问某个类时，不管运行环境采用何种调度方式或者这些线程如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能正确表现出正确的行为，你们就称这个类是线程安全的</p>
</blockquote>
<h1 id="一、原子性与可见性"><a href="#一、原子性与可见性" class="headerlink" title="一、原子性与可见性"></a>一、原子性与可见性</h1><h2 id="1、可见性"><a href="#1、可见性" class="headerlink" title="1、可见性"></a>1、可见性</h2><p>可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线程马上就能看到。</p>
<p>例子就不举了，比较好理解直接写出结论</p>
<h3 id="1-1、主内存与工作内存"><a href="#1-1、主内存与工作内存" class="headerlink" title="1.1、主内存与工作内存"></a>1.1、主内存与工作内存</h3><p>根据Java Language Specification中的说明, jvm系统中存在一个主内存(Main Memory或Java Heap Memory)，Java中所有变量都储存在主存中，对于所有线程都是共享的。</p>
<p>每条线程都有自己的工作内存(Working Memory)，工作内存中保存的是主存中某些变量的拷贝，线程对所有变量的操作都是在工作内存中进行，线程之间无法相互直接访问，变量传递均需要通过主存完成。</p>
<h3 id="1-2、volatile关键字"><a href="#1-2、volatile关键字" class="headerlink" title="1.2、volatile关键字"></a>1.2、volatile关键字</h3><ul>
<li>能够保证volatile变量的可见性</li>
<li>不能保证volatile变量复合操作的原子性</li>
</ul>
<p>通俗地讲：volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值。</p>
<p>volatile关键字应该属于一种最轻量级的同步机制。</p>
<h3 id="1-3、volatile、long与原子性"><a href="#1-3、volatile、long与原子性" class="headerlink" title="1.3、volatile、long与原子性"></a>1.3、volatile、long与原子性</h3><p>关于volatile与原子性的问题，有一点绕。有一道面试就是volatile能不能把一个非原子操作变成原子操作？答案是有的。</p>
<p>要了解这个问题，首先知道一下它能把哪些非原子操作变成原子操作。</p>
<p>在JVM中，int等不大于32位的基本类型的操作都是原子操作，但是某些jvm对long和double类型的操作并不是原子操作，这样就会造成错误数据的出现。 因为这两种数据类型是64位的，在某些32位的虚拟机中，对一个变量的读写就可能分两步完成，这样可能会造成多线程的问题，也就说即使是对一个变量的读或者写操作，也不是原子操作。</p>
<p>而volatile把一个非原子操作变成原子操作的范围，也仅限于以上的这种情况。</p>
<p>而且，volatile保证的，也只是对于变量读或者写操作的原子性保证，对于变量的自加操作，还是无法保证的。</p>
<h2 id="2、原子性"><a href="#2、原子性" class="headerlink" title="2、原子性"></a>2、原子性</h2><p>虽然volatile关键字可以保证变量的可见性，但是并不能保证原子性，所以想要保证原子性，就必须采取其他措施：</p>
<ul>
<li>使用java.util.concurrent.atomic    包中的原子类</li>
<li>加锁</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>volatile</th>
<th>加锁</th>
</tr>
</thead>
<tbody>
<tr>
<td>可见性</td>
<td>可以</td>
<td>可以</td>
</tr>
<tr>
<td>原子性</td>
<td>不可以</td>
<td>可以</td>
</tr>
</tbody>
</table>
<h1 id="二、锁"><a href="#二、锁" class="headerlink" title="二、锁"></a>二、锁</h1><h2 id="2-1、内置锁-Synchronized"><a href="#2-1、内置锁-Synchronized" class="headerlink" title="2.1、内置锁-Synchronized"></a>2.1、内置锁-Synchronized</h2><p>Java提供了一种内置的锁机制来支持原子性：同步代码块(Synchronized Block)</p>
<p>当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码</p>
<ol>
<li>当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。</li>
<li>然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。</li>
<li>尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。</li>
<li>第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。</li>
<li>以上规则对其它对象锁同样适用.</li>
</ol>
<h2 id="2-2、锁的等级"><a href="#2-2、锁的等级" class="headerlink" title="2.2、锁的等级"></a>2.2、锁的等级</h2><p>从等级上，锁可以分为方法锁，对象锁，类锁。</p>
<p>这些概念很绕，花了很长时间才搞明白，首先，我觉得他们三个在概念上并不是同级的。</p>
<p>首先看一下synchronized的用法：synchronized修饰方法和synchronized修饰代码块。</p>
<p>而方法分为实例方法和静态方法，正是这两种方法的区别，才有了对象锁和类锁</p>
<h3 id="2-2-1、对象锁的synchronized修饰方法和代码块："><a href="#2-2-1、对象锁的synchronized修饰方法和代码块：" class="headerlink" title="2.2.1、对象锁的synchronized修饰方法和代码块："></a>2.2.1、对象锁的synchronized修饰方法和代码块：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronized</span> </span>&#123;    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;    </div><div class="line">         <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;    </div><div class="line">             <span class="comment">///</span></div><div class="line">         &#125;    </div><div class="line">    &#125;    </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;    </div><div class="line">         <span class="comment">///</span></div><div class="line">    &#125;       </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一个方法时用了同步代码块的方式进行同步，传入的对象实例是this，表明是当前对象，当然，如果需要同步其他对象实例，也不可传入其他对象的实例；</p>
<p>第二个方法是修饰方法的方式进行同步。在修饰方法的时候默认是当前对象作为锁的对象.</p>
<p><strong>所以两个同步代码所需要获得的对象锁都是同一个对象锁</strong></p>
<h3 id="2-2-2、类锁的synchronized修饰-静态-方法和代码块："><a href="#2-2-2、类锁的synchronized修饰-静态-方法和代码块：" class="headerlink" title="2.2.2、类锁的synchronized修饰(静态)方法和代码块："></a>2.2.2、类锁的synchronized修饰(静态)方法和代码块：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronized</span>   </span></div><div class="line">&#123;    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;    </div><div class="line">         <span class="keyword">synchronized</span>(TestSynchronized.class)&#123;    </div><div class="line">              <span class="comment">///</span></div><div class="line">         &#125;    </div><div class="line">    &#125;    </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;    </div><div class="line">         <span class="comment">///</span></div><div class="line">    &#125;    </div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一个方法时用了同步代码块的方式进行同步，传入的对象实例是TestSynchronized.class，表明是当前的类</p>
<p>在修饰类时候默认是当前类的Class对象作为锁的对象.</p>
<p>所以这两个方法获得的也是同一个锁。</p>
<h3 id="2-2-3、synchronized同时修饰静态和非静态方法"><a href="#2-2-3、synchronized同时修饰静态和非静态方法" class="headerlink" title="2.2.3、synchronized同时修饰静态和非静态方法"></a>2.2.3、synchronized同时修饰静态和非静态方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronized</span></span>&#123;    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;    </div><div class="line">    	<span class="comment">///</span></div><div class="line">    &#125;    </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;    </div><div class="line">         <span class="comment">///  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码synchronized同时修饰静态方法和实例方法，但是运行结果是交替进行的，这证明了类锁和对象锁是两个不一样的锁，控制着不同的区域，它们是互不干扰的。同样，线程获得对象锁的同时，也可以获得该类锁，即同时获得两个锁，这是允许的。</p>
<h3 id="2-2-4、总结"><a href="#2-2-4、总结" class="headerlink" title="2.2.4、总结"></a>2.2.4、总结</h3><p>通过以上几个例子可以看出，方法锁可以使用实例对象或者类对象，他们的关系如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>修饰方法</th>
<th>修饰代码块</th>
</tr>
</thead>
<tbody>
<tr>
<td>对象锁</td>
<td>synchronized void test1(){}</td>
<td>synchronized(this){}</td>
</tr>
<tr>
<td>类锁</td>
<td>static synchronized void test2(){}</td>
<td>synchronized(TestSynchronized.class){}</td>
</tr>
</tbody>
</table>
<p>有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，它只是用来帮助我们理解锁定实例方法和静态方法的区别的</p>
<h2 id="2-3、显式锁-ReetrantLock"><a href="#2-3、显式锁-ReetrantLock" class="headerlink" title="2.3、显式锁-ReetrantLock"></a>2.3、显式锁-ReetrantLock</h2><p>在Java5.0之前，协调对共享对象的访问时可使用的机制只有synchronized和volatile。Java5.0新增了一种新的机制：ReentrantLock。</p>
<p>在java.util.concurrent.locks包中定义了一个Lock接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与内置锁不同的是，Lock：</p>
<ul>
<li>可轮询的</li>
<li>定时的</li>
<li>可中断的</li>
</ul>
<p>锁获取操作，所有加锁和解锁的方法都是显示的。</p>
<h3 id="2-3-1、ReetrantLock"><a href="#2-3-1、ReetrantLock" class="headerlink" title="2.3.1、ReetrantLock"></a>2.3.1、ReetrantLock</h3><p>也叫重入锁，是一种递归无阻塞的同步机制（利用CAS机制）。ReentrantLock类实现了Lock接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();  </div><div class="line">lock.lock();  </div><div class="line"><span class="keyword">try</span> &#123;   </div><div class="line">  <span class="comment">// update object state  </span></div><div class="line">&#125;  </div><div class="line"><span class="keyword">finally</span> &#123;  </div><div class="line">  lock.unlock();   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Lock和 synchronized 有一点明显的区别 —— Lock 必须在 finally 块中释放</p>
<h3 id="2-3-2、轮询锁"><a href="#2-3-2、轮询锁" class="headerlink" title="2.3.2、轮询锁"></a>2.3.2、轮询锁</h3><p>在内置锁中，死锁是致命的——唯一的恢复方法是重新启动程序，唯一的预防方法是在构建程序时不要出错。</p>
<p>而可轮询的与可定时的锁提供了另一种选择：避免死锁的发生。</p>
<p>如果你不能获得所有需要的锁，那么使用可轮询的获取方式使你能够重新拿到控制权，它会释放你已经获得的这些锁，然后再重新尝试。可轮询的锁获取模式，由tryLock()方法实现。此方法仅在调用时锁为空闲状态才获取该锁。如果锁可用，则获取锁，并立即返回值true。如果锁不可用，则此方法将立即返回值false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(l1.tryLock())&#123;</div><div class="line">  <span class="keyword">try</span>&#123;</div><div class="line">    <span class="keyword">if</span>(l2.tryLock())&#123;</div><div class="line">      <span class="keyword">try</span>&#123;</div><div class="line">        <span class="comment">///</span></div><div class="line">      &#125;<span class="keyword">finally</span>&#123;</div><div class="line">        l2.unlock();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;<span class="keyword">finally</span>&#123;</div><div class="line">    l1.unlock();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-3-3、定时锁"><a href="#2-3-3、定时锁" class="headerlink" title="2.3.3、定时锁"></a>2.3.3、定时锁</h3><p>定时锁，当在带有时间限制的操作中调用了一个阻塞方法时，它能根据剩余时间来提供一个限时，如果操作不能在指定时间内给出结果，你们就会使程序提前结束。</p>
<p>可定时的锁获取模式，由tryLock(long, TimeUnit)方法实现。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!l.tryLock(time, unit))&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">  <span class="comment">///</span></div><div class="line">&#125;<span class="keyword">finally</span>&#123;</div><div class="line">  l.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-3-4、可中断的锁"><a href="#2-3-4、可中断的锁" class="headerlink" title="2.3.4、可中断的锁"></a>2.3.4、可中断的锁</h3><p>可中断的锁获取操作允许在可取消的活动中使用。lockInterruptibly()方法能够使你获得锁的时候响应中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">fun1</span><span class="params">(String s)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</div><div class="line">    l.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        <span class="keyword">return</span> fun2(s);</div><div class="line">    &#125;<span class="keyword">finally</span>&#123;</div><div class="line">        l.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">fun2</span><span class="params">(String s)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</div><div class="line">    <span class="comment">///		</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可定时的tryLock()方法同样能响应中断，因此当需要实现一个定时的和可中断的锁获取操作时，可以使用tryLock()方法</p>
<h3 id="2-3-5、ReentrantLock与synchronized比较"><a href="#2-3-5、ReentrantLock与synchronized比较" class="headerlink" title="2.3.5、ReentrantLock与synchronized比较"></a>2.3.5、ReentrantLock与synchronized比较</h3><p>ReentrantLock与synchronized比较优势：</p>
<ul>
<li>ReentrantLock在加锁和内存上提供的语义与内置锁相同</li>
<li>ReentrantLock提供一些额外的功能：可定时的、可轮询的与可中断的锁获取操作，公平队列以及非块结构的锁</li>
<li>性能上;ReentrantLock优于synchronized。Java5.0中远远胜出，6.0中略有胜出，因为6.0对synchronized进行了优化</li>
</ul>
<p>但是synchronized也有一些自己的优势：</p>
<ul>
<li>使用更简洁紧凑，很多现有程序中都使用了内置锁。</li>
<li>不用显示的释放锁，没有安全隐患</li>
</ul>
<p>因此：</p>
<blockquote>
<p>ReentrantLock可以作为是更高级的工具，只有synchronized无法满足的时候才使用它，否则还是优先使用synchronized。</p>
</blockquote>
<h2 id="2-4、读写锁-ReadWriteLock"><a href="#2-4、读写锁-ReadWriteLock" class="headerlink" title="2.4、读写锁-ReadWriteLock"></a>2.4、读写锁-ReadWriteLock</h2><p>Java中锁从加锁模式上可以分为<strong>独占锁</strong>和<strong>共享锁</strong>。</p>
<p>独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock就是以独占方式实现的互斥锁。</p>
<p>共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。</p>
<p>很显然，独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。 java的并发包中提供了ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，或者被一个 写操作访问，但两者不能同时进行。</p>
<h1 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h1><h2 id="1、信号量"><a href="#1、信号量" class="headerlink" title="1、信号量"></a>1、信号量</h2><p>Java中实现计数信号量的类为java.util.concurrent.Semaphore，是在1.5中引入的。</p>
<ul>
<li>Semaphore中管理着一组许可，许可的初始数量可以通过构造方法来指定。</li>
<li>在执行操作时需要先获得许可（acquire），并在使用完后释放许可（release）。</li>
<li>如果当前没有许可，那么acquire将阻塞下到有许可可用，或者直到被中断，或者操作超时。</li>
<li>当初始值为1时，该信号量就可以实现互斥锁的功能。</li>
</ul>
<p>Semaphore可以用于实现资源池，例如数据库的连接池。可以构建一个固定长度的资源池，当池为空时，请求资源就会失败，但Semaphore可以实现阻塞而非失败，并且当资源非空时解除阻塞。</p>
<p>可以使用Semaphore将任何容器变成有界的阻塞容器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedList</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;T&gt; list;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore semaphore;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedList</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;  </div><div class="line">        list = Collections.synchronizedList(<span class="keyword">new</span> LinkedList&lt;T&gt;());  </div><div class="line">        semaphore = <span class="keyword">new</span> Semaphore(bound);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T obj)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </div><div class="line">        semaphore.acquire();  </div><div class="line">        <span class="keyword">boolean</span> addedFlag = <span class="keyword">false</span>;  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            addedFlag = list.add(obj);  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">finally</span> &#123;  </div><div class="line">            <span class="keyword">if</span> (!addedFlag) &#123;  </div><div class="line">                semaphore.release();  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> addedFlag;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object obj)</span> </span>&#123;  </div><div class="line">        <span class="keyword">boolean</span> removedFlag = list.remove(obj);  </div><div class="line">        <span class="keyword">if</span> (removedFlag) &#123;  </div><div class="line">            semaphore.release();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> removedFlag;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2、Java中的各种锁"><a href="#2、Java中的各种锁" class="headerlink" title="2、Java中的各种锁"></a>2、Java中的各种锁</h2><p>到目前为止，我接触到的关于所的概念有：方法锁、对象锁、类锁、独占锁、共享锁、内置锁、显示锁、互斥锁、排它锁、读写锁、自旋锁(微笑脸)。</p>
<p>虽然看上去很多，但是真正理解了其实也不难，因为它们是从不同角度来描述锁的</p>
<h3 id="2-1、方法锁、对象锁与类锁"><a href="#2-1、方法锁、对象锁与类锁" class="headerlink" title="2.1、方法锁、对象锁与类锁"></a>2.1、方法锁、对象锁与类锁</h3><p>这三个在介绍synchronized的时候已经说过了</p>
<h3 id="2-2、独占锁与共享锁"><a href="#2-2、独占锁与共享锁" class="headerlink" title="2.2、独占锁与共享锁"></a>2.2、独占锁与共享锁</h3><p>这两个是从不同线程之间持有锁的方式上区分的，只是宏观上的概念，而不是具体的某种锁</p>
<ul>
<li>独占锁模式下每次只能有一个线程持有锁，比如synchronized、ReentrantLock肯定都属于独占锁</li>
<li>共享锁模式下可以有多个线程持有，比如读锁就可以多个线程同时读。</li>
</ul>
<h3 id="2-3、内置锁与显示锁"><a href="#2-3、内置锁与显示锁" class="headerlink" title="2.3、内置锁与显示锁"></a>2.3、内置锁与显示锁</h3><p>这两个应该从Java语言发展的角度来看，最开始的时候Java中只有一种加锁机制就是synchronized，后来才有了locks包中的Java对象形式的锁</p>
<ul>
<li>内置锁：指的就是synchronized，因为它是Java中最开始内置的</li>
<li>显示锁：指后来加入的locks包中的锁，因为使用的时候必须要显示的获取锁和释放锁，ReentrantLock和ReadWriteLock都是显示锁</li>
</ul>
<h3 id="2-4、互斥锁与自旋锁"><a href="#2-4、互斥锁与自旋锁" class="headerlink" title="2.4、互斥锁与自旋锁"></a>2.4、互斥锁与自旋锁</h3><p>互斥锁和自旋锁应该都属于独占锁，只是他们的实现方式不同</p>
<p>他们的区别在于自旋锁不会引起线程的休眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名</p>
<h1 id="四、参考地址"><a href="#四、参考地址" class="headerlink" title="四、参考地址"></a>四、参考地址</h1><p><a href="http://zhh9106.iteye.com/blog/2151791" target="_blank" rel="external">http://zhh9106.iteye.com/blog/2151791</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[多线程基础]]></title>
      <url>http://yoursite.com/2016/12/10/MultiThreading/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h1 id="一、线程的两种实现方式"><a href="#一、线程的两种实现方式" class="headerlink" title="一、线程的两种实现方式"></a>一、线程的两种实现方式</h1><p>Java提供了线程类Thread来创建多线程的程序。其实，创建线程与创建普通的类的对象的操作是一样的，而线程就是Thread类或其子类的实例对象。每个Thread对象描述了一个单独的线程。要产生一个线程，有两种方法：</p>
<p>举一个实际例子来说明:假设一个影院有三个售票口，分别用于向儿童、成人和老人售票。影院为每个窗口放有100张电影票，分别是儿童票、成人票和老人票。三个窗口需要同时卖票，而现在只有一个售票员，这个售票员就相当于一个CPU，三个窗口就相当于三个线程。</p>
<h2 id="1、通过扩展Thread类来创建多线程"><a href="#1、通过扩展Thread类来创建多线程" class="headerlink" title="1、通过扩展Thread类来创建多线程"></a>1、通过扩展Thread类来创建多线程</h2><ol>
<li>定义一个Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。</li>
<li>创建Thread子类的实例，即创建了线程对象。</li>
<li>调用线程对象的start()方法来启动该线程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutliThreadDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        MyThread m1=<span class="keyword">new</span> MyThread(<span class="string">"Window 1"</span>);</div><div class="line">        MyThread m2=<span class="keyword">new</span> MyThread(<span class="string">"Window 2"</span>);</div><div class="line">        MyThread m3=<span class="keyword">new</span> MyThread(<span class="string">"Window 3"</span>);</div><div class="line">        m1.start();</div><div class="line">        m2.start();</div><div class="line">        m3.start();		</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket=<span class="number">100</span>;<span class="comment">//每个线程都拥有100张票</span></div><div class="line">    MyThread(String name)&#123;</div><div class="line">        <span class="keyword">super</span>(name);<span class="comment">//调用父类带参数的构造方法</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">while</span>(ticket&gt;<span class="number">0</span>)&#123;</div><div class="line">            System.out.println(ticket--+<span class="string">" is saled by "</span>+Thread.currentThread().getName());</div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序中定义一个线程类，它扩展了Thread类。利用扩展的线程类在MutliThreadDemo类的主方法中创建了三个线程对象，并通过start()方法分别将它们启动。</p>
<p>从结果可以看到，每个线程分别对应100张电影票，之间并无任何关系，这就说明每个线程之间是平等的，没有优先级关系，因此都有机会得到CPU的处理。但是结果显示这三个线程并不是依次交替执行，而是在三个线程同时被执行的情况下，有的线程被分配时间片的机会多，票被提前卖完，而有的线程被分配时间片的机会比较少，票迟一些卖完。</p>
<p>可见，<strong>利用扩展Thread类创建的多个线程，虽然执行的是相同的代码，但彼此相互独立，且各自拥有自己的资源，互不干扰</strong>。 </p>
<h2 id="2、通过实现Runnable接口来创建多线程"><a href="#2、通过实现Runnable接口来创建多线程" class="headerlink" title="2、通过实现Runnable接口来创建多线程"></a>2、通过实现Runnable接口来创建多线程</h2><ol>
<li>定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li>
<li>创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</li>
<li>调用线程对象的start()方法来启动该线程。</li>
</ol>
<h3 id="1-1例子1"><a href="#1-1例子1" class="headerlink" title="1.1例子1"></a>1.1例子1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutliThreadDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        MyThread2 m1=<span class="keyword">new</span> MyThread2();</div><div class="line">        MyThread2 m2=<span class="keyword">new</span> MyThread2();</div><div class="line">        MyThread2 m3=<span class="keyword">new</span> MyThread2();</div><div class="line">        Thread t1=<span class="keyword">new</span> Thread(m1, <span class="string">"Window 1"</span>);</div><div class="line">        Thread t2=<span class="keyword">new</span> Thread(m2, <span class="string">"Window 2"</span>);</div><div class="line">        Thread t3=<span class="keyword">new</span> Thread(m3, <span class="string">"Window 3"</span>);</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t3.start();	</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">     <span class="keyword">private</span> <span class="keyword">int</span> ticket=<span class="number">100</span>;<span class="comment">//每个线程都拥有100张票</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">         <span class="keyword">while</span>(ticket&gt;<span class="number">0</span>)&#123;</div><div class="line">           	<span class="comment">//如果要访问当前线程，则必须使用Thread.currentThread()方法。</span></div><div class="line">             System.out.println(ticket--+<span class="string">" is saled by "</span>+Thread.currentThread().getName());</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于这三个线程也是彼此独立，各自拥有自己的资源，即100张电影票，因此程序输出的结果和（1）结果大同小异。均是各自线程对自己的100张票进行单独的处理，互不影响。</p>
<p>可见，只要现实的情况要求保证新建线程彼此相互独立，各自拥有资源，且互不干扰，采用哪个方式来创建多线程都是可以的。因为这两种方式创建的多线程程序能够实现相同的功能。</p>
<h3 id="1-2、例子2"><a href="#1-2、例子2" class="headerlink" title="1.2、例子2"></a>1.2、例子2</h3><p>现实中也存在这样的情况，比如模拟一个火车站的售票系统，假如当日从A地发往B地的火车票只有100张，且允许所有窗口卖这100张票，那么每一个窗口也相当于一个线程，但是这时和前面的例子不同之处就在于所有线程处理的资源是同一个资源，即100张车票。如果还用前面的方式来创建线程显然是无法实现的，这种情况该怎样处理呢？看下面这个程序，程序代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutliThreadDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        MyThread3 m1=<span class="keyword">new</span> MyThread3();</div><div class="line">        Thread t1=<span class="keyword">new</span> Thread(m1, <span class="string">"Window 1"</span>);</div><div class="line">        Thread t2=<span class="keyword">new</span> Thread(m1, <span class="string">"Window 2"</span>);</div><div class="line">        Thread t3=<span class="keyword">new</span> Thread(m1, <span class="string">"Window 3"</span>);</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t3.start();	</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread3</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket=<span class="number">100</span>;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span>(ticket&gt;<span class="number">0</span>)&#123;</div><div class="line">            System.out.println(ticket--+<span class="string">" is saled by "</span>+Thread.currentThread().getName());</div><div class="line">        &#125;		</div><div class="line">    &#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果正如前面分析的那样，程序在内存中仅创建了一个资源，而新建的三个线程都是基于访问这同一资源的，并且由于每个线程上所运行的是相同的代码，因此它们执行的功能也是相同的。</p>
<h2 id="3、Thread与Runnable"><a href="#3、Thread与Runnable" class="headerlink" title="3、Thread与Runnable"></a>3、Thread与Runnable</h2><p>通过上面例子的对比，可以看出两种方法都可以创建新的线程，但是后者与前者相比有着更多的优势：</p>
<ol>
<li>线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。</li>
<li>多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</li>
<li>几乎所有的多线程程序都是通过实现Runnable接口的方式来完成的。</li>
</ol>
<h2 id="4、Callable"><a href="#4、Callable" class="headerlink" title="4、Callable"></a>4、Callable</h2><p>除了以上两种方法，还有一个叫做Callable的接口，它和Runnable很相似，但也有几点不同：</p>
<ol>
<li>Callable需要实现call方法，而Runnable需要实现run方法</li>
<li>Callable方法可以返回任意类型的对象</li>
<li>Callable能够抛出异常，而runnable不能</li>
<li>Callable和Runnable都可以应用于executors。而Thread类只支持Runnable.</li>
<li>Callable与executors联合在一起，在任务完成时可立刻获得一个更新了的Future。而Runable却要自己处理</li>
</ol>
<p><strong>Future接口</strong>：一般都是取回Callable执行的状态用的。其中的主要方法：</p>
<ul>
<li>cancel，取消Callable的执行，当Callable还没有完成时</li>
<li>get，获得Callable的返回值</li>
<li>isCanceled，判断是否取消了</li>
<li>isDone，判断是否完成</li>
</ul>
<h1 id="二、用户线程与守护线程"><a href="#二、用户线程与守护线程" class="headerlink" title="二、用户线程与守护线程"></a>二、用户线程与守护线程</h1><p>百度面试的时候被问到怎么开一个守护线程，没有答上来。</p>
<p>在Java中有两类线程：</p>
<ul>
<li><p>User Thread(用户线程)：</p>
<p>非守护线程包括常规的用户线程或诸如用于处理GUI事件的事件调度线程，Java虚拟机在它所有非守护线程已经离开后自动离开。</p>
</li>
<li><p>Daemon Thread(守护线程) ：</p>
<p>守护线程则是用来服务用户线程的，比如说GC线程。如果没有其他用户线程在运行，那么就没有可服务对象，也就没有理由继续下去。</p>
</li>
</ul>
<h2 id="1、区别"><a href="#1、区别" class="headerlink" title="1、区别"></a>1、区别</h2><p>User和Daemon两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果 User Thread已经全部退出运行了，只剩下Daemon Thread存在了，虚拟机也就退出了。 因为没有了被守护者，Daemon也就没有工作可做了，也就没有继续运行程序的必要了。</p>
<h2 id="2、创建"><a href="#2、创建" class="headerlink" title="2、创建"></a>2、创建</h2><p> 守护线程与普通线程写法上基本没什么区别，调用线程对象的方法setDaemon(true)，则可以将其设置为守护线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Thread daemonTread = <span class="keyword">new</span> Thread();     </div><div class="line">  <span class="comment">// 设定 daemonThread 为 守护线程，default false(非守护线程)  </span></div><div class="line"> daemonThread.setDaemon(<span class="keyword">true</span>);     </div><div class="line"> <span class="comment">// 验证当前线程是否为守护线程，返回 true 则为守护线程  </span></div><div class="line"> daemonThread.isDaemon();</div></pre></td></tr></table></figure>
<ol>
<li>thread.setDaemon(true)必须在thread.start()之前设置，否则会抛出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。</li>
<li>在Daemon线程中产生的新线程也是Daemon的。 </li>
<li>不是所有的应用都可以分配给Daemon线程来进行服务，比如读写操作或者计算逻辑。因为在Daemon Thread还没来的及进行操作时，虚拟机可能已经退出了。 </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Thread threadA=<span class="keyword">new</span> Thread()&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">            System.out.println(<span class="string">"hello I am threadA"</span>);				</div><div class="line">            Thread threadB=<span class="keyword">new</span> Thread()&#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">                    System.out.println(<span class="string">"hello I am threadB"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            System.out.println(<span class="string">"threadB is deamon: "</span>+threadB.isDaemon());</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    System.out.println(<span class="string">"threadA is deamon: "</span>+threadA.isDaemon());</div><div class="line">    threadA.setDaemon(<span class="keyword">true</span>);</div><div class="line">    threadA.start();</div><div class="line">    System.out.println(<span class="string">"threadA is deamon: "</span>+threadA.isDaemon());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">threadA is deamon: false</div><div class="line">threadA is deamon: true</div><div class="line">hello I am threadA</div><div class="line">threadB is deamon: true</div></pre></td></tr></table></figure>
<p>可以看出，线程A初始状态下是非守护线程，设置后变成守护线程，而在线程A中产生的线程B，即使还没有start，但初始状态就已经是守护线程。</p>
<h1 id="三、线程的5种状态"><a href="#三、线程的5种状态" class="headerlink" title="三、线程的5种状态"></a>三、线程的5种状态</h1><p>关于线程状态不同书上有不同的说法，一般来说有5种状态：</p>
<ol>
<li><p><strong>新建(new)</strong>:</p>
<p>​    当用new操作符创建一个线程时， 例如new Thread(r)，线程还没有开始运行，此时线程处在新建状态。 当一个线程处于新生状态时，程序还没有开始运行线程中的代码</p>
</li>
<li><p><strong>就绪(Runnable)</strong>：</p>
<p>​    一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。</p>
<pre><code>处于就绪状态的线程并不一定立即运行run()方法，线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。因为在单CPU的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个线程处于就绪状态。对多个处于就绪状态的线程是由Java运行时系统的线程调度程序(*thread scheduler*)来调度的。
</code></pre></li>
<li><p><strong>运行(Running)</strong>：</p>
<p>​    当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法.</p>
</li>
<li><p><strong>阻塞(Blocked)</strong> ：</p>
<p>​    所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。线程运行过程中，可能由于各种原因进入阻塞状态:</p>
<ul>
<li><p>线程通过调用sleep方法进入睡眠状态；</p>
</li>
<li><p>线程通过wait()方法挂起，JVM会把该线程放入等待池中，直到线程得到了notify()或者notifyAll()消息，线程才会进入就绪状态</p>
</li>
<li><p>线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；</p>
</li>
<li><p>线程试图得到一个锁，而该锁正被其他线程持有；</p>
<p>​</p>
</li>
</ul>
</li>
<li><p><strong>死亡(Dead)</strong>：</p>
<p>​    该线程结束生命周期，可能是：</p>
<ul>
<li>从run方法返回</li>
<li>线程被中断</li>
</ul>
</li>
</ol>
<h1 id="三、参考地址"><a href="#三、参考地址" class="headerlink" title="三、参考地址"></a>三、参考地址</h1><p><a href="http://www.cnblogs.com/whgw/archive/2011/10/03/2198506.html" target="_blank" rel="external">http://www.cnblogs.com/whgw/archive/2011/10/03/2198506.html</a></p>
<p><a href="http://blog.csdn.net/longshengguoji/article/details/41126119" target="_blank" rel="external">http://blog.csdn.net/longshengguoji/article/details/41126119</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[464. Can I Win]]></title>
      <url>http://yoursite.com/2016/12/09/algorithm/464.%20Can%20I%20Win/</url>
      <content type="html"><![CDATA[<blockquote>
<p>In the “100 game,” two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins.</p>
<p>What if we change the game so that players cannot re-use integers?</p>
<p>For example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total &gt;= 100.</p>
<p>Given an integer <code>maxChoosableInteger</code> and another integer <code>desiredTotal</code>, determine if the first player to move can force a win, assuming both players play optimally.</p>
<p>You can always assume that <code>maxChoosableInteger</code> will not be larger than 20 and <code>desiredTotal</code> will not be larger than 300.</p>
<p><strong>Example</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt;Input:</div><div class="line">&gt;maxChoosableInteger = 10</div><div class="line">&gt;desiredTotal = 11</div><div class="line">&gt;</div><div class="line">&gt;Output:</div><div class="line">&gt;false</div><div class="line">&gt;</div><div class="line">&gt;Explanation:</div><div class="line">&gt;No matter which integer the first player choose, the first player will lose.</div><div class="line">&gt;The first player can choose an integer from 1 up to 10.</div><div class="line">&gt;If the first player choose 1, the second player can only choose integers from 2 up to 10.</div><div class="line">&gt;The second player will win by choosing 10 and get a total = 11, which is &gt;= desiredTotal.</div><div class="line">&gt;Same with other integers chosen by the first player, the second player will always win.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>最开始的方法就是深搜加回溯，用一个set来存储所有数组，然后每次选一个从set中删除，向下搜索，然后再回溯加上原来删除的元素。tag给的提示是DP，虽然知道应该把走过的路径记下来，但是set不知道怎么做。</p>
<p>看来网上的答案才知道，因为备选的数字是连续的，所以可以建一个数组，下标就是对应的数字，如何用数组的值记录这个数字是不是已经被使用过了，这样的话数组的不同状态对应不同的答案，就可以用一个map记录下来，避免重复搜索。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">format</span><span class="params">(<span class="keyword">boolean</span>[] state)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> re=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;state.length; i++)&#123;</div><div class="line">        re&lt;&lt;=<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(state[i])&#123;</div><div class="line">            re|=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> re;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOK</span><span class="params">(<span class="keyword">boolean</span>[] state, Map&lt;Integer, Boolean&gt; map, <span class="keyword">int</span> tar)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> key=format(state);</div><div class="line">    <span class="keyword">if</span>(map.containsKey(key))&#123;</div><div class="line">        <span class="keyword">return</span> map.get(key);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;state.length; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(!state[i])&#123;</div><div class="line">            state[i]=<span class="keyword">true</span>;</div><div class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>&gt;=tar||!isOK(state, map, tar-i-<span class="number">1</span>))&#123;</div><div class="line">                map.put(key, <span class="keyword">true</span>);</div><div class="line">                state[i]=<span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            state[i]=<span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    map.put(key, <span class="keyword">false</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canIWin</span><span class="params">(<span class="keyword">int</span> maxChoosableInteger, <span class="keyword">int</span> desiredTotal)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>((<span class="number">1</span>+maxChoosableInteger)*maxChoosableInteger&lt;desiredTotal*<span class="number">2</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">boolean</span>[] state=<span class="keyword">new</span> <span class="keyword">boolean</span>[maxChoosableInteger];</div><div class="line">    Map&lt;Integer, Boolean&gt; map=<span class="keyword">new</span> HashMap&lt;Integer, Boolean&gt;();       </div><div class="line">    <span class="keyword">return</span> isOK(state, map, desiredTotal);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[375. Guess Number Higher or Lower II]]></title>
      <url>http://yoursite.com/2016/12/08/algorithm/375.%20Guess%20Number%20Higher%20or%20Lower%20II/</url>
      <content type="html"><![CDATA[<blockquote>
<p>We are playing the Guess Game. The game is as follows:</p>
<p>I pick a number from <strong>1</strong> to <strong>n</strong>. You have to guess which number I picked.</p>
<p>Every time you guess wrong, I’ll tell you whether the number I picked is higher or lower.</p>
<p>However, when you guess a particular number x, and you guess wrong, you pay <strong>$x</strong>. You win the game when you guess the number I picked.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;n = 10, I pick 8.</div><div class="line">&gt;</div><div class="line">&gt;First round:  You guess 5, I tell you that it&apos;s higher. You pay $5.</div><div class="line">&gt;Second round: You guess 7, I tell you that it&apos;s higher. You pay $7.</div><div class="line">&gt;Third round:  You guess 9, I tell you that it&apos;s lower. You pay $9.</div><div class="line">&gt;</div><div class="line">&gt;Game over. 8 is the number I picked.</div><div class="line">&gt;</div><div class="line">&gt;You end up paying $5 + $7 + $9 = $21.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Given a particular <strong>n ≥ 1</strong>, find out how much money you need to have to guarantee a <strong>win</strong>.</p>
</blockquote>
<p><strong>题意</strong>：和上一道不一样，的是每次猜了以后要付出相应的金额，所以要用到DP。</p>
<p>提示里说到这是一个Minimax问题，也就是最小的最大值问题。</p>
<p><strong>分析</strong>：在1-n个数里面，我们任意猜一个数(设为i)，保证获胜所花的钱应该为 i + max(cost(1 ,i-1), cost(i+1 ,n))，这里cost(x,y))表示猜范围在(x,y)的数保证能赢应花的钱，则我们依次遍历 1-n作为猜的数，求出其中的最小值即为答案</p>
<p>我理解的，i为你在这个范围内猜的第一个数，这里的最小最大值问题中的最大值的意思就是考虑最坏的情况，所以猜i的最大值中答案肯定不是i，那么就要去找1-i-1和i+1-n这两个范围，而最小最大值的最小的意思是指取能使最后答案最小的i的值。</p>
<p><strong>代码</strong>： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">cost</span><span class="params">(<span class="keyword">int</span>[][] acount, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(start&gt;=end)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(acount[start][end]!=<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> acount[start][end];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> re=Integer.MAX_VALUE;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;=end; i++)&#123;</div><div class="line">        <span class="keyword">int</span> cost=i+Math.max(cost(acount, start, i-<span class="number">1</span>), cost(acount, i+<span class="number">1</span>, end));</div><div class="line">        re=Math.min(re, cost);</div><div class="line">    &#125;</div><div class="line">    acount[start][end]=re;</div><div class="line">    <span class="keyword">return</span> re;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoneyAmount</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[][] acount=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</div><div class="line">    <span class="keyword">return</span> cost(acount, <span class="number">1</span>, n);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>参考地址</strong>：<a href="http://blog.csdn.net/adfsss/article/details/51951658" target="_blank" rel="external">http://blog.csdn.net/adfsss/article/details/51951658</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Best Time to Buy and Sell Stock I II III IV]]></title>
      <url>http://yoursite.com/2016/12/08/algorithm/BestTimetoBuyandSellStock/</url>
      <content type="html"><![CDATA[<h1 id="1、Best-Time-to-Buy-and-Sell-Stock-I"><a href="#1、Best-Time-to-Buy-and-Sell-Stock-I" class="headerlink" title="1、Best Time to Buy and Sell Stock I"></a>1、Best Time to Buy and Sell Stock I</h1><blockquote>
<p><strong>Description:</strong> Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
</blockquote>
<p><strong>题意：</strong>用一个数组表示股票每天的价格，数组的第i个数表示股票在第i天的价格。 如果只允许进行一次交易，也就是说只允许买一支股票并卖掉，求最大的收益。</p>
<p><strong>分析：</strong>动态规划法。从前向后遍历数组，记录当前出现过的最低价格，作为买入价格，并计算以当天价格出售的收益，作为可能的最大收益，整个遍历过程中，出现过的最大收益就是所求。</p>
<p><strong>代码：</strong>O(n)时间，O(1)空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(prices.length==<span class="number">0</span>)&#123;</div><div class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> re=<span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> min=prices[<span class="number">0</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;prices.length; i++)&#123;</div><div class="line">        <span class="keyword">int</span> diff=prices[i]-min;</div><div class="line">        <span class="keyword">if</span>(diff&gt;<span class="number">0</span>)&#123;</div><div class="line">            re=Math.max(re, diff);</div><div class="line">        &#125;</div><div class="line">        min=Math.min(min, prices[i]);</div><div class="line">    &#125;    	</div><div class="line">    <span class="keyword">return</span> re;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="2、Best-Time-to-Buy-and-Sell-Stock-II"><a href="#2、Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="2、Best Time to Buy and Sell Stock II"></a>2、Best Time to Buy and Sell Stock II</h1><blockquote>
<p><strong>Description:</strong> Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
</blockquote>
<p><strong>题目：</strong>用一个数组表示股票每天的价格，数组的第i个数表示股票在第i天的价格。交易次数不限，但一次只能交易一支股票，也就是说手上最多只能持有一支股票，求最大收益。</p>
<p><strong>分析：</strong>贪心法。从前向后遍历数组，只要当天的价格高于前一天的价格，就算入收益。</p>
<p><strong>代码：</strong>时间O(n)，空间O(1)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit2</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(prices.length==<span class="number">0</span>)&#123;</div><div class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> re=<span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> last=prices[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;prices.length; i++)&#123;</div><div class="line">    	<span class="keyword">if</span>(prices[i]&gt;last)&#123;</div><div class="line">    		re+=prices[i]-last;        		</div><div class="line">    	&#125;</div><div class="line">    	last=prices[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> re;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3、Best-Time-to-Buy-and-Sell-Stock-III"><a href="#3、Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="3、Best Time to Buy and Sell Stock III"></a>3、Best Time to Buy and Sell Stock III</h2><blockquote>
<p><strong>Description:</strong> Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
</blockquote>
<p><strong>题意：</strong>用一个数组表示股票每天的价格，数组的第i个数表示股票在第i天的价格。最多交易两次，手上最多只能持有一支股票，求最大收益。</p>
<p><strong>分析：</strong>动态规划法。以第i天为分界线，计算第i天之前进行一次交易的最大收益pre[i]，和第i天之后进行一次交易的最大收益post[i]，最后遍历一遍，max{pre[i] + post[i]} (0≤i≤n-1)就是最大收益。第i天之前和第i天之后进行一次的最大收益求法同Best Time to Buy and Sell Stock I。</p>
<p><strong>代码：</strong>时间O(n)，空间O(n)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit3</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(prices.length&lt;<span class="number">2</span>)&#123;</div><div class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> len=prices.length;</div><div class="line">    <span class="keyword">int</span>[] pre=<span class="keyword">new</span> <span class="keyword">int</span>[len];</div><div class="line">    <span class="keyword">int</span>[] post=<span class="keyword">new</span> <span class="keyword">int</span>[len];</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> min=prices[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</div><div class="line">        min=Math.min(min, prices[i]);</div><div class="line">        pre[i]=Math.max(pre[i-<span class="number">1</span>], prices[i]-min);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> max=prices[len-<span class="number">1</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</div><div class="line">        max=Math.max(max, prices[i]);</div><div class="line">        post[i]=Math.max(post[i+<span class="number">1</span>], max-prices[i]);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> re=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</div><div class="line">        re=Math.max(re, pre[i]+post[i]);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> re;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4、Best-Time-to-Buy-and-Sell-Stock-IV"><a href="#4、Best-Time-to-Buy-and-Sell-Stock-IV" class="headerlink" title="4、Best Time to Buy and Sell Stock IV"></a>4、Best Time to Buy and Sell Stock IV</h2><blockquote>
<p><strong>Description:</strong> Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
</blockquote>
<p><strong>题意：</strong>用一个数组表示股票每天的价格，数组的第i个数表示股票在第i天的价格。最多交易k次，手上最多只能持有一支股票，求最大收益。</p>
<p><strong>分析：</strong>特殊动态规划法。传统的动态规划我们会这样想，到第i天时进行j次交易的最大收益，要么等于到第i-1天时进行j次交易的最大收益（第i天价格低于第i-1天的价格），要么等于到第i-1天时进行j-1次交易，然后第i天进行一次交易（第i天价格高于第i-1天价格时）。于是得到动规方程如下（其中diff = prices[i] – prices[i – 1]）：</p>
<blockquote>
<p>profit[i][j] = max(profit[i – 1][j], profit[i – 1][j – 1] + diff)</p>
</blockquote>
<p>看起来很有道理，但其实不对，为什么不对呢？因为diff是第i天和第i-1天的差额收益，如果第i-1天当天本身也有交易呢（也就是说第i-1天刚卖出了股票，然后又买入等到第i天再卖出），那么这两次交易就可以合为一次交易，这样profit[i – 1][j – 1] + diff实际上只进行了j-1次交易，而不是最多可以的j次，这样得到的最大收益就小了。</p>
<p>那么怎样计算第i天进行交易的情况的最大收益，才会避免少计算一次交易呢？我们用一个局部最优解和全局最有解表示到第i天进行j次的收益，这就是该动态规划的特殊之处。</p>
<p>用local[i][j]表示到达第i天时，最多进行j次交易的局部最优解；用global[i][j]表示到达第i天时，最多进行j次的全局最优解。它们二者的关系如下（其中diff = prices[i] – prices[i – 1]）：</p>
<blockquote>
<p>local[i][j] = max(global[i – 1][j – 1] , local[i – 1][j] + diff)<br>global[i][j] = max(global[i – 1][j], local[i][j])</p>
</blockquote>
<p>local[i][j]和global[i][j]的区别是：local[i][j]意味着在第i天一定有交易（卖出）发生，当第i天的价格高于第i-1天（即diff &gt; 0）时，那么可以把这次交易（第i-1天买入第i天卖出）跟第i-1天的交易（卖出）合并为一次交易，即local[i][j]=local[i-1][j]+diff；当第i天的价格不高于第i-1天（即diff&lt;=0）时，那么local[i][j]=global[i-1][j-1]+diff，而由于diff&lt;=0，所以可写成local[i][j]=global[i-1][j-1]。global[i][j]就是我们所求的前i天最多进行k次交易的最大收益，可分为两种情况：如果第i天没有交易（卖出），那么global[i][j]=global[i-1][j]；如果第i天有交易（卖出），那么global[i][j]=local[i][j]。</p>
<p><strong>代码：</strong>时间O(nk)，空间O(nk)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(prices.length&lt;<span class="number">2</span>)&#123;</div><div class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> len=prices.length;</div><div class="line">    <span class="keyword">if</span>(k&gt;=len)&#123;</div><div class="line">    	<span class="keyword">return</span> maxProfit2(prices);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span>[][] local=<span class="keyword">new</span> <span class="keyword">int</span>[len][k+<span class="number">1</span>];</div><div class="line">    <span class="keyword">int</span>[][] global=<span class="keyword">new</span> <span class="keyword">int</span>[len][k+<span class="number">1</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</div><div class="line">    	<span class="keyword">int</span> diff=prices[i]-prices[i-<span class="number">1</span>];</div><div class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=k; j++)&#123;</div><div class="line">    		local[i][j]=Math.max(local[i-<span class="number">1</span>][j]+diff, global[i-<span class="number">1</span>][j-<span class="number">1</span>]);</div><div class="line">    		global[i][j]=Math.max(local[i][j], global[i-<span class="number">1</span>][j]);</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> global[len-<span class="number">1</span>][k];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>补充：</strong>这道题还有一个陷阱，就是当k大于天数时，其实就退化成 <strong>Best Time to Buy and Sell Stock II</strong> 了。就不能用动规来做了，为什么？（请思考） 另外，<strong>Best Time to Buy and Sell Stock III</strong> 就是本题k=2的情况，所以说IV是II和III的综合。</p>
<p>[转自来自梁佳宾的网络日志][<a href="http://liangjiabin.com/blog/2015/04/leetcode-best-time-to-buy-and-sell-stock.html" target="_blank" rel="external">http://liangjiabin.com/blog/2015/04/leetcode-best-time-to-buy-and-sell-stock.html</a>]</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java NIO与反应器模式]]></title>
      <url>http://yoursite.com/2016/11/28/DesignPattern/%E5%8F%8D%E5%BA%94%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8EJava%20NIO/</url>
      <content type="html"><![CDATA[<p>Java NIO是1.4中出现的重要更新，其中几个重要概念简单理解以下，并且学习其中用到的Reactor模式，即反应器模式。</p>
<h1 id="一、缓冲区-Buffer"><a href="#一、缓冲区-Buffer" class="headerlink" title="一、缓冲区 Buffer"></a>一、缓冲区 Buffer</h1><p>缓冲区是NIO中最重要的一个概念，最上面的是Buffer接口，下面有：</p>
<ul>
<li>CharBuffer</li>
<li>IntBuffer</li>
<li>DoubleBuffer</li>
<li>ShortBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>ByteBuffer   MappedBuffer</li>
</ul>
<p>有7个主要的Buffer类，每个都对应一种Java语言中非布尔类型的原始类型数据</p>
<h2 id="1、基本属性与方法"><a href="#1、基本属性与方法" class="headerlink" title="1、基本属性与方法"></a>1、基本属性与方法</h2><p>Buffer是包在一个对象内的基本数据元素数组。还有四个属性来提供包含的信息：</p>
<ol>
<li>容量 Capacity</li>
<li>上届 Limit</li>
<li>位置 Position</li>
<li>标价 Mark</li>
</ol>
<p>这四个属性分别指向数组的某个位置，从而方便实现不同的方法，方法有很多不一一列举，用的多了自然就熟悉了。</p>
<h2 id="2、Buffer的创建"><a href="#2、Buffer的创建" class="headerlink" title="2、Buffer的创建"></a>2、Buffer的创建</h2><p>上面说的7个Buffer类都是抽象类，无法直接实例化对象，包含静态工厂方法来创建相应的实例。主要有几下两种方法来创建实例：</p>
<h3 id="2-1、分配-allocate"><a href="#2-1、分配-allocate" class="headerlink" title="2.1、分配 allocate"></a>2.1、分配 allocate</h3><p>分配就是在堆中分配一个指定的大小的缓存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CharBuffer charbuffer=CharBuffer.allocate(<span class="number">100</span>);</div></pre></td></tr></table></figure>
<p>意义为从堆中创建一个char型数组来存储100个char型变量。</p>
<h3 id="2-2、包装-wrap"><a href="#2-2、包装-wrap" class="headerlink" title="2.2、包装 wrap"></a>2.2、包装 wrap</h3><p>还可以将已经存在的数组包装为Buffer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span>[] charArray=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1000</span>];</div><div class="line">CharBuffer charbuffer=CharBuffer.wrap(charArray);</div><div class="line">CharBuffer charbuffer2=CharBuffer.wrap(charArray, <span class="number">12</span>, <span class="number">42</span>);</div></pre></td></tr></table></figure>
<p>重载方法可以指定offset和length</p>
<h3 id="2-3、直接缓冲区"><a href="#2-3、直接缓冲区" class="headerlink" title="2.3、直接缓冲区"></a>2.3、直接缓冲区</h3><p>直接缓冲区是IO的最佳选择，因为它使用的内存是通过调用本地操作系统的代码分配的，可能建立的成本会更高，但是效率也更高。</p>
<p>这部分内存是独立于JVM之外的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ByteBuffer byteBuffer=ByteBuffer.allocateDirect(<span class="number">7</span>);</div></pre></td></tr></table></figure>
<h2 id="3、ByteBuffer"><a href="#3、ByteBuffer" class="headerlink" title="3、ByteBuffer"></a>3、ByteBuffer</h2><p>在7中Buffer中，ByteBuffer与其他6个最明显的区别就是：<strong>它可以成为通道执行IO的源头或目标</strong>。</p>
<p>因为操作系统上的IO操作本质上也是对连续字节的操作。</p>
<h3 id="字节顺序"><a href="#字节顺序" class="headerlink" title="字节顺序"></a>字节顺序</h3><p>除了布尔不管是什么数据类型，它在内存中肯定都是连续的字节。只不过不同的数据类型由不同的字节表示。</p>
<p>比如int型有四个字节，而这四个字节的排列顺序就是<strong>字节顺序</strong>，有<strong>大端字节顺序</strong>和<strong>小端字节顺序</strong>。</p>
<h3 id="视图缓冲区"><a href="#视图缓冲区" class="headerlink" title="视图缓冲区"></a>视图缓冲区</h3><p>视图缓冲区通过已经存在的缓冲区对象实例的工厂方法来创建。这种视图：</p>
<ul>
<li>有自己的属性，容量、位置上届和标记</li>
<li>和原来的缓冲区共享数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ByteBuffer byteBuffer=ByteBuffer.allocate(<span class="number">7</span>).order(ByteOrder.BIG_ENDIAN);</div><div class="line">CharBuffer charBuffer=byteBuffer.asCharBuffer();</div></pre></td></tr></table></figure>
<h2 id="4、MappedBuffer"><a href="#4、MappedBuffer" class="headerlink" title="4、MappedBuffer"></a>4、MappedBuffer</h2><p>映射缓冲区是带有存储在文件，通过内存映射来存取数据元素的字节缓冲区。在后面讨论。</p>
<h1 id="二、通道-Channel"><a href="#二、通道-Channel" class="headerlink" title="二、通道 Channel"></a>二、通道 Channel</h1><p>通道是访问IO服务的导管。IO分为文件IO和套接字IO两大类，对应的通道也分为两大类</p>
<ul>
<li>文件IO<ul>
<li>FileChannel</li>
</ul>
</li>
</ul>
<ul>
<li>套接字IO<ul>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
<li>DatagramChannel</li>
</ul>
</li>
</ul>
<h2 id="1、Channel的创建"><a href="#1、Channel的创建" class="headerlink" title="1、Channel的创建"></a>1、Channel的创建</h2><h3 id="1-1、FileChannel的创建"><a href="#1-1、FileChannel的创建" class="headerlink" title="1.1、FileChannel的创建"></a>1.1、FileChannel的创建</h3><p>FileChannel对象只能通过在一个打开的：</p>
<ul>
<li>RandomAccessFile</li>
<li>FileInputStream</li>
<li>FileOutputStream</li>
</ul>
<p>对象上调用getChannel()方法来获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RandomAccessFile raf=<span class="keyword">new</span> RandomAccessFile(<span class="string">"somefile"</span>, <span class="string">"r"</span>);</div><div class="line">FileChannel fc=raf.getChannel();</div></pre></td></tr></table></figure>
<h3 id="1-2、Socket通道的创建"><a href="#1-2、Socket通道的创建" class="headerlink" title="1.2、Socket通道的创建"></a>1.2、Socket通道的创建</h3><p>Socket通道可以直接调用工厂方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SocketChannel sc=SocketChannel.open();        </div><div class="line">ServerSocketChannel ssc=ServerSocketChannel.open();</div><div class="line">DatagramChannel dc=DatagramChannel.open();</div></pre></td></tr></table></figure>
<h2 id="2、Channel的使用"><a href="#2、Channel的使用" class="headerlink" title="2、Channel的使用"></a>2、Channel的使用</h2><h3 id="2-1、read与write"><a href="#2-1、read与write" class="headerlink" title="2.1、read与write"></a>2.1、read与write</h3><p>两个接口分别定义了读写的方法，可以看出，都是只能对ByteBuffer进行读写的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span> <span class="keyword">throws</span> IOException</span>;</div></pre></td></tr></table></figure>
<h3 id="2-2、Scatter与Gather"><a href="#2-2、Scatter与Gather" class="headerlink" title="2.2、Scatter与Gather"></a>2.2、Scatter与Gather</h3><p>该功能可以支持Channel在多个Buffer上顺序抽取进入通道。</p>
<h2 id="3、文件通道"><a href="#3、文件通道" class="headerlink" title="3、文件通道"></a>3、文件通道</h2><p>关于文件通道：</p>
<ul>
<li>FileChannel总是阻塞式的，不能被置于非阻塞模式。</li>
<li>文件锁定，锁与文件关联而不是与通道关联。文件锁不适用于判断同意虚拟机上多个线程发起的访问。也就是说，同一Java虚拟机的不同线程公用同一个文件锁。</li>
</ul>
<h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>传统的文件IO的通过用户进程发布read()和write()系统调用来传输数据的，为了在内核空间与用户空间的内存区之间移动数据，一次以上的拷贝操作是避免不了的。</p>
<p>为了解决这一问题，有了内存映射文件。用户可以把文件数据当做内存，无需发布read或write的系统调用。</p>
<h4 id="FileChannel中的内存映射文件"><a href="#FileChannel中的内存映射文件" class="headerlink" title="FileChannel中的内存映射文件"></a>FileChannel中的内存映射文件</h4><p>上面提到过MappedByteBuffer，就是FileChannel中对内存映射文件的支持。</p>
<p>FileChannel类提供一个map()方法，改方法可以在一个打开的文件和一个特殊类型的ByteBuffer之间建立一个虚拟内存映射。</p>
<p>该方法会创建一个有磁盘文件支持的虚拟内存映射并在那块内存空间外部封装MappedByteBuffer对象。</p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>创建映射的时候可以指定参数mode、position和size。mode代表映射模式。文件的映射模式有三种：</p>
<ul>
<li>READ_ONLY</li>
<li>WRITE_ONLY</li>
<li>PRIVATE</li>
</ul>
<p>前面两个很好理解，而第三个PRIVATE表示要建立一个<strong>写时拷贝</strong>的映射。</p>
<blockquote>
<p>这意味着通过put()方法所做的任何修改都会导致产生一个私有的数据拷贝并且该拷贝中的数据只有MappedByteBuffer实例可以看到。该过程不会对底层文件做任何修改，而且一旦缓冲区被垃圾回收，那些修改都会丢失。</p>
<p>假设一个文件被多个MappedByteBuffer对象映射并且每个映射都是PRIVATE模式，你们这个文件的大部分内容都可以被所有映射共享</p>
</blockquote>
<h2 id="4、Socket通道"><a href="#4、Socket通道" class="headerlink" title="4、Socket通道"></a>4、Socket通道</h2><p>Socket通道最重要的就是可以设置为非阻塞模式。相关操作在一个公有超类SelectableChannel中定义，这个类也与后面的Selector类是实现反应器模式的关键，后面会有更多介绍。</p>
<h3 id="4-1、ServerSocketChannel"><a href="#4-1、ServerSocketChannel" class="headerlink" title="4.1、ServerSocketChannel"></a>4.1、ServerSocketChannel</h3><p>ServerSocketChannel对应的是java.net.ServerSocket类。并在其基础上增加了通道语义，能够在非阻塞模式下运行。</p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>使用静态工厂方法可以新建ServerSocketChannel对象，并有一个与之关联的未绑定的ServerSocket。该关联的ServerSocket实例可以通过ServerSocketChannel的socket()方法获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ServerSocketChannel ssc=ServerSocketChannel.open();</div><div class="line">ServerSocket sc=ssc.socket();</div></pre></td></tr></table></figure>
<h4 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h4><p>ServerSocketChannel上并没有bind()方法，因此必须取出关联的ServerSocket并用它来绑定到一个端口以开始监听。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">1234</span>));</div></pre></td></tr></table></figure>
<h4 id="accept"><a href="#accept" class="headerlink" title="accept()"></a>accept()</h4><p>ServerSocketChannel与ServerSocket都用accept()方法。</p>
<ul>
<li>调用ServerSocket的accept()方法会和其他的ServerSocket一样，<strong>阻塞</strong>地返回一个java.net.Socket对象。</li>
<li>调用ServerSocketChannel的accept()方法则会返回一个SocketChannel对象，并且能够在<strong>非阻塞</strong>模式下运行。</li>
</ul>
<h3 id="4-2、SocketChannel"><a href="#4-2、SocketChannel" class="headerlink" title="4.2、SocketChannel"></a>4.2、SocketChannel</h3><p>与ServerSocketChannel的逻辑很类似，SocketChannel对应的是java.net.Socket类</p>
<h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><p>调用open()方法可以创建SocketChannel对象，在SocketChannel对象上调用socket()方法可以返回对等的Socket对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SocketChannel sc=SocketChannel.open();</div><div class="line">Socket s=sc.socket();</div></pre></td></tr></table></figure>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>新创建的SocketChannel是未连接的，直接进行IO操作会抛出异常。</p>
<p>连接也是可以通过SocketChannel上直接调用connect()方法或这在关联的Socket对象调用connect()方法。</p>
<ul>
<li>在Socket对象上调用connect()方法，与传统语义一样，在连接建立好之前都将<strong>阻塞</strong>。 </li>
<li>在SocketChannel上调用connect()方法，如果默认的通道处于阻塞模式，那么会和上面的情况一样。</li>
<li>Channel在非阻塞模式下调用connect()方法会提供并发连接：发起对请求地址的连接并且立即返回：<ul>
<li>如果是true说明连接已经建立</li>
<li>如果没有建立连接会立即返回false并继续连接过程</li>
</ul>
</li>
</ul>
<p>与连接有关的方法使得我们可以对一个通道进行<strong>轮询</strong>并在连接过程中判断通道所处的状态。而在下面的选择器中，则可以使用选择器来避免轮询并在异步建立连接之后收到通知。</p>
<h1 id="三、选择器-Selector"><a href="#三、选择器-Selector" class="headerlink" title="三、选择器 Selector"></a>三、选择器 Selector</h1><p>在传统的Java解决方案中，会为每个Socket都创建一个线程使得线程在read()的时候阻塞，直到数据可用，但是这样的效率并不高，而且线程的上下文切换也需要消耗资源。</p>
<p>有了非阻塞模式之后，有了一种方案就是使用非阻塞功能检测就绪功能。但是也有一个问题，当非阻塞方法执行成功后，就必须要读进这些数据并进行处理了。这使得检查就绪的代码和处理数据的代码不能分离开。</p>
<p>而非阻塞方法最优雅的使用就是这里要介绍的选择器。</p>
<ul>
<li>将之前创建的一个或多个可选择的通道注册到选择器对象中，一个表示通道和选择器的选择键将会被返回</li>
<li>选择键会记住关心的通道，追踪通道是否已经就绪</li>
<li>调用选择器的select()方法时，相关的键会被更新，用来检查注册的通道</li>
<li>可以选择一个键的集合，从而找到已经就绪的通道，遍历这个集合，就可以选择出每个从上次调用select()方法之后到现在已经准备就绪的通道。</li>
</ul>
<h2 id="1、关键类"><a href="#1、关键类" class="headerlink" title="1、关键类"></a>1、关键类</h2><h3 id="1-1、选择器-Selector"><a href="#1-1、选择器-Selector" class="headerlink" title="1.1、选择器 Selector"></a>1.1、选择器 Selector</h3><p>管理着一个被注册的通道集合的信息和它们的就绪状态</p>
<h3 id="1-2、可选择通道-SelectableChannel"><a href="#1-2、可选择通道-SelectableChannel" class="headerlink" title="1.2、可选择通道 SelectableChannel"></a>1.2、可选择通道 SelectableChannel</h3><ul>
<li>继承自这个类的通道都是可选择通道</li>
<li>它可以SelectableChannel.register()方法被注册到Slector对象上，并且可以初测到多个通道。</li>
<li>被注册到一个选择器之前，必须设置为非阻塞模式</li>
</ul>
<h3 id="1-3、选择键-SelectionKey"><a href="#1-3、选择键-SelectionKey" class="headerlink" title="1.3、选择键 SelectionKey"></a>1.3、选择键 SelectionKey</h3><p>选择器键封装了特定通道与特定选择器的注册关系。该对象被SelectableChannel.register()方法返回。</p>
<p>包含两个集合(以整数形式编码)：</p>
<ul>
<li><p>interest集：表示注册关系所关心的通道操作，它是在调用register()方法的时候指定的，有四种可选操作</p>
<ul>
<li>read</li>
<li>write</li>
<li>connect</li>
<li>accept</li>
</ul>
<p>通过调用interestOps()方法可以可以获取集合。</p>
</li>
</ul>
<ul>
<li><p>ready集：表示已经准备好的操作，interest集合的子集。通过readyOps()方法可以获取，比较方便的是直接调用相应的</p>
<ul>
<li>isReadable()</li>
<li>isWritable()</li>
<li>isConnectable()</li>
<li>isAcceptable()</li>
</ul>
<p>方法来直接测试</p>
</li>
</ul>
<h2 id="2、使用选择器"><a href="#2、使用选择器" class="headerlink" title="2、使用选择器"></a>2、使用选择器</h2><h3 id="2-1、Selector类"><a href="#2-1、Selector类" class="headerlink" title="2.1、Selector类"></a>2.1、Selector类</h3><p>选择器内部有三个集合：</p>
<p><strong>已注册的键的集合 Registered key set</strong> </p>
<ul>
<li>与选择器关联的已注册的键的集合</li>
<li>并不是所有注册过的键都有效</li>
<li>通过keys()方法返回，可能为空</li>
</ul>
<p><strong>已选择的键的集合 Selected key set</strong></p>
<ul>
<li>上面集合的子集</li>
<li>该集合中每个键对应的通道都是已经准备好的</li>
<li>通过selectdKeys()方法返回</li>
<li>与ready集合不一样，该集合是一个选择键的集合，其中的每个选择键都关联一个已经准别好至少一种操作的通道</li>
</ul>
<p><strong>已取消的键的集合 Cancelled key set</strong></p>
<ul>
<li>也是已注册的键的子集</li>
<li>包含cancel()方法被调用过的键</li>
<li>私有成员，无法直接访问</li>
</ul>
<h3 id="2-2、选择过程"><a href="#2-2、选择过程" class="headerlink" title="2.2、选择过程"></a>2.2、选择过程</h3><p>Selector类的select()方法有三种形式</p>
<p><strong>无限阻塞：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Selector selector=Selector.open();</div><div class="line"><span class="keyword">int</span> n=selector.select();</div></pre></td></tr></table></figure>
<ul>
<li>这种调用在没有通道就绪时将无限阻塞</li>
<li>一旦至少有一个通道就绪，选择器的选择键集合就会被更新，并且每个就绪通道的ready集合也被更新。</li>
<li>返回值将会是已经确定就绪通道的数量</li>
</ul>
<p><strong>限制等待时间：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Selector selector=Selector.open();</div><div class="line"><span class="keyword">int</span> n=selector.select(<span class="number">1000</span>);</div></pre></td></tr></table></figure>
<ul>
<li>可以指定一个参数，以毫秒计算</li>
<li>如果在指定时间内没有通道就绪，将返回0值</li>
<li>如果在时间内有至少一个通道就绪，将更新键表并立即返回。</li>
<li>如果时间设置为0说明无限制等待，与上面方法相同。</li>
</ul>
<p><strong>非阻塞：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Selector selector=Selector.open();</div><div class="line"><span class="keyword">int</span> n=selector.selectNow();</div></pre></td></tr></table></figure>
<ul>
<li>方法不会阻塞</li>
<li>如果没有通道就绪，立即返回0</li>
</ul>
<h3 id="2-3、停止过程"><a href="#2-3、停止过程" class="headerlink" title="2.3、停止过程"></a>2.3、停止过程</h3><p>有三种方法可以唤醒在select()方法中睡眠的线程</p>
<p><strong>wakeup()方法</strong></p>
<p><strong>close()方法</strong></p>
<p><strong>interrupt()方法</strong></p>
<h1 id="四、Reactor模式"><a href="#四、Reactor模式" class="headerlink" title="四、Reactor模式"></a>四、Reactor模式</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>Reactor设计模式，是一种基于事件驱动的设计模式。Reactor框架是ACE各个框架中最基础的一个框架，其他框架都或多或少地用到了Reactor框架。 </p>
<p>在事件驱动的应用中，将一个或多个客户的服务请求分离（demultiplex）和调度（dispatch）给应用程序。在事件驱动的应用中，同步地、有序地处理同时接收的多个服务请求。 </p>
<p>Reactor模式与观察者模式有点像。不过，观察者模式与单个事件源关联，而反应器模式则与多个事件源关联 。当一个主体发生改变时，所有依属体都得到通知。</p>
<h2 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h2><p><strong>优点</strong></p>
<ol>
<li><p>响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的； </p>
</li>
<li><p>编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销； </p>
</li>
<li><p>可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源； </p>
</li>
<li><p>可复用性，reactor框架本身与具体事件处理逻辑无关，具有很高的复用性；</p>
<p>​</p>
</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>相比传统的简单模型，Reactor增加了一定的复杂性，因而有一定的门槛，并且不易于调试。 </li>
<li>Reactor模式需要底层的Synchronous Event Demultiplexer支持，比如Java中的Selector支持，操作系统的select系统调用支持，如果要自己实现Synchronous Event Demultiplexer可能不会有那么高效。 </li>
<li>Reactor模式在IO读写数据时还是在同一个线程中实现的，即使使用多个Reactor机制的情况下，那些共享一个Reactor的Channel如果出现一个长时间的数据读写，会影响这个Reactor中其他Channel的相应时间，比如在大文件传输时，IO操作就会影响其他Client的相应时间，因而对这种操作，使用传统的Thread-Per-Connection或许是一个更好的选择，或则此时使用Proactor模式。</li>
</ol>
<h2 id="3、架构模式"><a href="#3、架构模式" class="headerlink" title="3、架构模式"></a>3、架构模式</h2><p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/DesignPattern/1.png?raw=true" alt=""></p>
<h2 id="4、构成"><a href="#4、构成" class="headerlink" title="4、构成"></a>4、构成</h2><ul>
<li><p><strong>Handles</strong> :即操作系统中的句柄，是对资源在操作系统层面上的一种抽象，它可以是打开的文件、一个连接(Socket)、Timer等。由于Reactor模式一般使用在网络编程中，因而这里一般指Socket Handle，即一个网络连接（Connection，在Java NIO中的Channel）。这个Channel注册到Synchronous Event Demultiplexer中，以监听Handle中发生的事件，对ServerSocketChannnel可以是CONNECT事件，对SocketChannel可以是READ、WRITE、CLOSE事件等。</p>
</li>
<li><p><strong>Synchronous Event Demultiplexer</strong>:阻塞等待一系列的Handle中的事件到来，如果阻塞等待返回，即表示在返回的Handle中可以不阻塞的执行返回的事件类型。这个模块一般使用操作系统的select来实现。在Java NIO中用Selector来封装，当Selector.select()返回时，可以调用Selector的selectedKeys()方法获取Set<selectionkey>，一个SelectionKey表达一个有事件发生的Channel以及该Channel上的事件类型。</selectionkey></p>
</li>
<li><p><strong>Initiation Dispatcher</strong>:用于管理Event Handler，即EventHandler的容器，用以注册、移除EventHandler等；另外，它还作为Reactor模式的入口调用Synchronous Event Demultiplexer的select方法以阻塞等待事件返回，当阻塞等待返回时，根据事件发生的Handle将其分发给对应的Event Handler处理，即回调EventHandler中的handle_event()方法。</p>
</li>
<li><p><strong>Event Handler</strong>:定义事件处理方法：handle_event()，以供InitiationDispatcher回调使用。</p>
</li>
<li><p><strong>Concrete Event Handler</strong>:事件EventHandler接口，实现特定事件处理逻辑。</p>
<p>​</p>
<p>​</p>
</li>
</ul>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> designpattern.reactor;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Reactor reactor;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Acceptor</span><span class="params">(Reactor reactor)</span></span>&#123;  </div><div class="line">        <span class="keyword">this</span>.reactor=reactor;  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            SocketChannel socketChannel=reactor.serverSocketChannel.accept();  </div><div class="line">            <span class="keyword">if</span>(socketChannel!=<span class="keyword">null</span>)<span class="comment">//调用Handler来处理channel  </span></div><div class="line">                <span class="keyword">new</span> SocketReadHandler(reactor.selector, socketChannel);  </div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> designpattern.reactor;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.net.InetAddress;</div><div class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</div><div class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</div><div class="line"><span class="keyword">import</span> java.nio.channels.Selector;</div><div class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.Set;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * </div><div class="line"> * 反应器模式</div><div class="line"> * </div><div class="line"> * Java NIO中</div><div class="line"> * 可注册的ServerSocketChannnel相当于Handles </div><div class="line"> * Slector就相当于Synchronous Event Demultiplexer</div><div class="line"> * Reactor类，相当于一个Initiation Dispatcher，负责最开始的注册</div><div class="line"> * Acceptor类相当于Event Handler</div><div class="line"> *</div><div class="line"> */</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * </div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reactor</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Selector selector;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ServerSocketChannel serverSocketChannel;  </div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Reactor</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException</span>&#123;  </div><div class="line">        selector=Selector.open();  </div><div class="line">        serverSocketChannel=ServerSocketChannel.open();  </div><div class="line">        InetSocketAddress inetSocketAddress=<span class="keyword">new</span> InetSocketAddress(InetAddress.getLocalHost(),port);  </div><div class="line">        serverSocketChannel.socket().bind(inetSocketAddress);  </div><div class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);  </div><div class="line"></div><div class="line">        <span class="comment">//向selector注册该channel    </span></div><div class="line">        SelectionKey selectionKey=serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);  </div><div class="line"></div><div class="line">        <span class="comment">//利用selectionKey的attache功能绑定Acceptor 如果有事情，触发Acceptor   </span></div><div class="line">        selectionKey.attach(<span class="keyword">new</span> Acceptor(<span class="keyword">this</span>));  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            <span class="keyword">while</span>(!Thread.interrupted())&#123;  </div><div class="line">                selector.select();  </div><div class="line">                Set&lt;SelectionKey&gt; selectionKeys= selector.selectedKeys();  </div><div class="line">                Iterator&lt;SelectionKey&gt; it=selectionKeys.iterator();  </div><div class="line">                <span class="comment">//Selector如果发现channel有OP_ACCEPT或READ事件发生，下列遍历就会进行。  </span></div><div class="line">                <span class="keyword">while</span>(it.hasNext())&#123;  </div><div class="line">                    <span class="comment">//来一个事件 第一次触发一个accepter线程    </span></div><div class="line">                    <span class="comment">//以后触发SocketReadHandler  </span></div><div class="line">                    SelectionKey selectionKey=it.next();  </div><div class="line">                    <span class="comment">//这相当于Event_handlerd的回调</span></div><div class="line">                    dispatch(selectionKey);  </div><div class="line">                    selectionKeys.clear();  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;          </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 当阻塞等待返回时，根据事件发生的Handle将其分发给对应的Event Handler处理</div><div class="line">     * 这里的Event Handler被定义为一个线程绑定到对于的SelectionKey上面</div><div class="line">     * </div><div class="line">     * 这里的attachment第一次是accepter线程，后面是SocketReadHandler线程</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(SelectionKey selectionKey)</span> </span>&#123;</div><div class="line">        Runnable r = (Runnable)(selectionKey.attachment());    </div><div class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>)&#123;    </div><div class="line">            r.run();  </div><div class="line">        &#125;         </div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> designpattern.reactor;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</div><div class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</div><div class="line"><span class="keyword">import</span> java.nio.channels.Selector;</div><div class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketReadHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> SocketChannel socketChannel;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketReadHandler</span><span class="params">(Selector selector,SocketChannel socketChannel)</span> <span class="keyword">throws</span> IOException</span>&#123;  </div><div class="line">        <span class="keyword">this</span>.socketChannel=socketChannel;  </div><div class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);  </div><div class="line"></div><div class="line">        SelectionKey selectionKey=socketChannel.register(selector, <span class="number">0</span>);  </div><div class="line"></div><div class="line">        <span class="comment">//将SelectionKey绑定为本Handler 下一步有事件触发时，将调用本类的run方法。    </span></div><div class="line">        <span class="comment">//参看dispatch(SelectionKey key)    </span></div><div class="line">        selectionKey.attach(<span class="keyword">this</span>);  </div><div class="line"></div><div class="line">        <span class="comment">//同时将SelectionKey标记为可读，以便读取。    </span></div><div class="line">        selectionKey.interestOps(SelectionKey.OP_READ);    </div><div class="line">        selector.wakeup();  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 处理读取数据 </div><div class="line">     */  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">        ByteBuffer inputBuffer=ByteBuffer.allocate(<span class="number">1024</span>);  </div><div class="line">        inputBuffer.clear();  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            socketChannel.read(inputBuffer);  </div><div class="line">            <span class="comment">//激活线程池 处理这些request  </span></div><div class="line">            <span class="comment">//requestHandle(new Request(socket,btt));   </span></div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="五、参考地址"><a href="#五、参考地址" class="headerlink" title="五、参考地址"></a>五、参考地址</h1><p><a href="http://www.blogjava.net/DLevin/archive/2015/09/02/427045.html" target="_blank" rel="external">http://www.blogjava.net/DLevin/archive/2015/09/02/427045.html</a></p>
<p><a href="http://blog.csdn.net/u010168160/article/details/53019039" target="_blank" rel="external">http://blog.csdn.net/u010168160/article/details/53019039</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java单例模式]]></title>
      <url>http://yoursite.com/2016/11/28/DesignPattern/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>单例模式一个是设计模式中最常见的一种了，网上有n多中写法。顾名思义单例模式就是只有一个该类的实例。实现方式大概有一下几类：</p>
<ol>
<li>饿汉式</li>
<li>懒汉式</li>
<li>枚举模式</li>
</ol>
<p>首先最基本的肯定是将构造函数设为私有，在此基础上几种写法各有特点，主要是因为三个性能指标的影响：</p>
<ul>
<li>lazy loading</li>
<li>线程安全</li>
<li>序列化攻击</li>
</ul>
<h1 id="1、懒汉式-不可用"><a href="#1、懒汉式-不可用" class="headerlink" title="1、懒汉式[不可用]"></a>1、懒汉式[不可用]</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;</div><div class="line">            singleton=<span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>优点：实现了Lazy Loading，第一次使用的时候才真正实例化</li>
<li>缺点：无法保证线程安全</li>
</ul>
<h1 id="2、饿汉式-可用"><a href="#2、饿汉式-可用" class="headerlink" title="2、饿汉式[可用]"></a>2、饿汉式[可用]</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton INSTANCE=<span class="keyword">new</span> Singleton();</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> INSTANCE;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>优点：这种写法的优点就是线程安全，利用类加载机制避免了多线程问题</li>
<li>缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。</li>
</ul>
<h1 id="3、懒汉式改进-双重检查-还是不安全"><a href="#3、懒汉式改进-双重检查-还是不安全" class="headerlink" title="3、懒汉式改进-双重检查(还是不安全)"></a>3、懒汉式改进-双重检查(还是不安全)</h1><p>针对懒汉式的线程不安全，可以通过双重加锁检查(DCL)的机制来避免：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;<span class="comment">//1</span></div><div class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;<span class="comment">//2</span></div><div class="line">                <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;<span class="comment">//3</span></div><div class="line">                    singleton=<span class="keyword">new</span> Singleton();<span class="comment">//4</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将singleton声明volatile保证可见性，再通过加锁实现线程安全，最大限度的减少了加锁带来的性能损耗。</p>
<p>更新一下：</p>
<p>在小米面试的时候面试官指出：<strong>即使是双重检测，也还是无法保证线程安全。</strong> </p>
<p>后来上网找了一下，确实发现了这个以前没有注意到的细节。比如下面这种情况：</p>
<ol>
<li>步骤1中线程1检测到singleton为null，于是进入步骤2获取锁，到步骤4中，开始实例化一个实例。</li>
<li>这里问题出来了，在实例化的过程中，执行构造方法之前，singleton就已经是非null的了</li>
<li>这个时候如果线程2执行到步骤1，检测到singleton为非null，那么就直接返回这个对象了，这个对象有可能还并没有执行构造函数，也就是说这里检测singleton是否为null，只能保证是否有这个实例了，但是却没法保证这个实例的构造过程是否已经完全执行完毕。</li>
</ol>
<p>这里涉及到JVM的一个无序写入的问题，总之这个问题以前一直被忽略，直到面试官提出。所以自己闭门造车还是有局限性的，多和牛人交流，也是提升自己的一个办法。</p>
<p>再次更新：</p>
<p>在Java并发编程实战的最后一章倒数第三页上也介绍了这个问题，奈何当时面试的时候还没看到这个部分。</p>
<p>首先否定了这个方法的正确性：<strong>线程可能看到一个仅被部分构造的实例。</strong></p>
<p>下面再引用一段书中的总结：</p>
<blockquote>
<p>在JVM(书上写的是JMM，我怀疑是写错了)的后续版本中，如果将单例声明为volatile类型，你们就能启动DCL，并且这种方式对性能的影响很小。因为volatile变量读取操作的性能通常只是略高于非volatile变量。</p>
<p>然而，DCL这种使用方法已经被广泛地废弃了，因为促使该模式出现的原因（无竞争同步的执行速度很慢，以及JVM启动时很慢）已经不复存在，因而它不再是一种高效的优化措施。延迟初始化占位类模式能带来同样的优势，并且更容易理解。</p>
</blockquote>
<p>书中说的延迟初始化占位类模式，也就是下面要介绍的静态内部类。</p>
<h1 id="4、饿汉式改进-静态内部类"><a href="#4、饿汉式改进-静态内部类" class="headerlink" title="4、饿汉式改进-静态内部类"></a>4、饿汉式改进-静态内部类</h1><p>饿汉式主要缺点就是无法实现Lazy Loading，可以通过静态内部类来解决这一问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE=<span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与上面的直接定义final实例不同的是定义一个静态的内部类，在内部类中持有这个实例，这样只有在第一次获取实例的时候才会加载这个内部类，从而实现Lazy Loading。</p>
<h1 id="5、枚举实现"><a href="#5、枚举实现" class="headerlink" title="5、枚举实现"></a>5、枚举实现</h1><p>方法3和方法4都实现了Lazy Loading也保证了线程安全，但单例攻击还会面临一个问题就是序列化。于是就有了枚举类型的单例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSingleton</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EnumSingleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">enum</span> Singleton&#123;</div><div class="line">        INSTANCE;</div><div class="line">        </div><div class="line">        <span class="keyword">private</span> EnumSingleton singleton;		</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</div><div class="line">            singleton=<span class="keyword">new</span> EnumSingleton();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> singleton;</div><div class="line">        &#125;		</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        EnumSingleton a=EnumSingleton.getInstance();</div><div class="line">        EnumSingleton b=EnumSingleton.getInstance();</div><div class="line">        System.out.println(a==b);<span class="comment">//true</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ArrayList源码分析]]></title>
      <url>http://yoursite.com/2016/11/12/Java/JDK/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>ArrayList是Java集合中最常用的，基于一个数组实现的，容量可以动态增长。</p>
<p>ArrayList不是线程安全的，只能在单线程环境下使用。        </p>
<p>本文以jdk1.8的源码为例，分析其实现机制。</p>
<h1 id="一、基本属性与构造函数"><a href="#一、基本属性与构造函数" class="headerlink" title="一、基本属性与构造函数"></a>一、基本属性与构造函数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;  </span></div><div class="line">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;<span class="comment">//序列版本号  </span></div><div class="line">  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;<span class="comment">//默认的初始容量  </span></div><div class="line">     </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;; <span class="comment">//公有的空数组  </span></div><div class="line">      </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<span class="comment">//也是空数组，和上面区别在于在第一次add元素的时候会判断  </span></div><div class="line">  </div><div class="line">      </div><div class="line">    <span class="comment">/* </span></div><div class="line">     * ArrayList的两个私有属性 </div><div class="line">     */  </div><div class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// 基于该数组实现，用于保存数据  </span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;<span class="comment">//size表示容器内元素的个数  </span></div><div class="line">      </div><div class="line">      </div><div class="line">    <span class="comment">/* </span></div><div class="line">     * 三个构造函数 </div><div class="line">     */  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;<span class="comment">//指定容量大小  </span></div><div class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;  </div><div class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];  </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;  </div><div class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;  </div><div class="line">        &#125; <span class="keyword">else</span> &#123;  </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+  </div><div class="line">                                               initialCapacity);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;<span class="comment">//无参构造函数，  </span></div><div class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<span class="comment">//创建一个包含collection的ArrayList  </span></div><div class="line">        elementData = c.toArray();  </div><div class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;  </div><div class="line">            <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)  </span></div><div class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)  </div><div class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);  </div><div class="line">        &#125; <span class="keyword">else</span> &#123;  </div><div class="line">            <span class="comment">// replace with empty array.  </span></div><div class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;  </div><div class="line">        &#125;  </div><div class="line">    &#125;     </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="1、私有属性"><a href="#1、私有属性" class="headerlink" title="1、私有属性"></a>1、私有属性</h2><p>可以看出ArrayList只有两个私有属性，即用于存储元素的数组elementData和表示元素个数的size</p>
<ol>
<li>elementData数组是Object类型的而不是泛型。</li>
<li>size表示元素的个数，它与数组的长度是有区别的。在没有添加元素的时候，虽然有数组，但是它的size却是0</li>
</ol>
<h2 id="2、DEFAULT-CAPACITY与EMPTY-ELEMENTDATA"><a href="#2、DEFAULT-CAPACITY与EMPTY-ELEMENTDATA" class="headerlink" title="2、DEFAULT_CAPACITY与EMPTY_ELEMENTDATA"></a>2、DEFAULT_CAPACITY与EMPTY_ELEMENTDATA</h2><p>DEFAULT_CAPACITY = 10表示默认的初始容量，而下面有两个final的空数组：</p>
<ul>
<li><p>EMPTY_ELEMENTDATA空数组表示在构造函数中制定初始化容量为0时，指向这个数组。</p>
<p>即List\<integer> list=new ArrayList\<integer>(0);</integer></integer></p>
</li>
<li><p>而DEFAULTCAPACITY_EMPTY_ELEMENTDATA是用于无参构造函数的默认大小的空数组。</p>
<p>即List\<integer> list=new ArrayList\<integer>();</integer></integer></p>
</li>
<li><p>这两者的关系在说明中给出了解释，We distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when first element is added. 即在第一次添加元素的时候。</p>
</li>
</ul>
<h2 id="3、构造函数"><a href="#3、构造函数" class="headerlink" title="3、构造函数"></a>3、构造函数</h2><ol>
<li>第一个构造函数用initialCapacity来初始化elementData数组，<ul>
<li>如果initialCapacity为0，则直接指向EMPTY_ELEMENTDATA。</li>
<li>如果不为0，那么直接新建数组。</li>
</ul>
</li>
<li>第二个是无参构造函数，elementData指向默认的空数组DEFAULTCAPACITY_EMPTY_ELEMENTDATA。貌似以前的版本是this(10)，即默认初始化大小为10，但是1.8版本清清楚楚写明白了是指向空数组，很多博客都乱写，虽然新版本默认大小也是10，但那是在第一次添加元素时才初始化的长度为10的数组，而不是在构造函数直接初始化数组。</li>
<li>第三个构造函数可以指定一个Collection&lt;? extends E&gt; c，说明类型必须是继承自前面泛型的类型。转换成数组并返回给elementData，如果不是Object[]将会调用 Arrays.copyOf方法将其转换为Object[]，因为上面提到elementData是Object类型的数组。</li>
</ol>
<h2 id="4、初始化"><a href="#4、初始化" class="headerlink" title="4、初始化"></a>4、初始化</h2><p>在新建一个list的时候，经常需要将一个数组包装进去，这时候就可以用到第三个构造函数。但是构造函数中的参数必须是一个list，所以就需要用到Arrays.asList方法，将一个数组转换为List。关于这个返回List的类型，根据getClass方法的输出class java.util.Arrays$ArrayList可以看出是Arrays中的内部类，而根据源码可以发现，这个内部类是继承自AbstractList。（注意，它和java.util.ArrayList是不一样的，如果直接对它进行操作会抛出异常）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>));</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 因为int数组本身就是一个类型，所以该方法会把它当作只有一个int数组类型的参数</div><div class="line"> * 而如果前面泛型定义为Integer的话，自然就会报错，所以在数组初始化的时候要定义为Integer[]类型的</div><div class="line"> */</div><div class="line">Integer[] num=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;  </div><div class="line"> 	List&lt;Integer&gt; list2=<span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(num));</div></pre></td></tr></table></figure>
<p>在阿里开源的阿里巴巴Java开发手册中也提到，使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。<br>说明： asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。Arrays.asList体现的是<strong>适配器模式</strong>，只是转换接口，后台的数据仍是数组 。</p>
<h1 id="二、数组大小的调整"><a href="#二、数组大小的调整" class="headerlink" title="二、数组大小的调整"></a>二、数组大小的调整</h1><p>ArrayList其实就是一个可以自动调整大小的数组，下面来看一下它是如何自动调节数组大小的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * 确保数组的大小 </div><div class="line"> * 根据现有数组的大小计算出minCapacity </div><div class="line"> * 二者最终都会调用ensureExplicitCapacity(minCapacity); </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;  </div><div class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)  </div><div class="line">        <span class="comment">// any size if not default element table  </span></div><div class="line">        ? <span class="number">0</span>  </div><div class="line">        <span class="comment">// larger than default for default empty table. It's already  </span></div><div class="line">        <span class="comment">// supposed to be at default size.  </span></div><div class="line">        : DEFAULT_CAPACITY;  </div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;  </div><div class="line">        ensureExplicitCapacity(minCapacity);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;  </div><div class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    ensureExplicitCapacity(minCapacity);  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;<span class="comment">//如果现有elementData的长度不够满足需求的大小，那么就扩大现有的数组  </span></div><div class="line">    modCount++;  </div><div class="line">  </div><div class="line">    <span class="comment">// overflow-conscious code  </span></div><div class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)  </div><div class="line">        grow(minCapacity);  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">  </div><div class="line">  </div><div class="line">  </div><div class="line"><span class="comment">/* </span></div><div class="line"> * 增加数组的长度以确保minCapacity个存储空间 </div><div class="line"> */  </div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;<span class="comment">// 数组的最大长度  </span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;<span class="comment">//计算出新的数组长度，并将原有数组复制过去  </span></div><div class="line">    <span class="comment">// overflow-conscious code  </span></div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;  </div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);  </div><div class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)  </div><div class="line">        newCapacity = minCapacity;  </div><div class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)  </div><div class="line">        newCapacity = hugeCapacity(minCapacity);  </div><div class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:  </span></div><div class="line">    elementData = Arrays.copyOf(elementData, newCapacity);  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow  </span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();  </div><div class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?  </div><div class="line">        Integer.MAX_VALUE :  </div><div class="line">        MAX_ARRAY_SIZE;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>主要分为两部分，前部分的三个函数主要用于计算，ensureCapacity与ensureCapacityInternal函数，根据传来的minCapacity，计算出需要的最小空间，然后调用ensureExplicitCapacity，如果现有的elementData数组的长度能够满足计算出的最小空间，那么就什么都不用做，但是如果不能满足，那么就必须调用下面的grow函数来进行扩容了。</li>
<li>grow函数用于扩展数组的长度，根据代码可以看出它的扩容机制。首先获取原有elementData数组的长度，并将其乘以1.5，然后再判断是否能满足给定的需求，如果还是不能满足，那么直接创建一个给定需求的数组。然后再将缘由元素拷贝到新数组中。</li>
<li>由此我们可以看出，随着向ArrayList中不断加入元素，当现有数组存满以后，就会自动将数组容量扩大1.5倍，当然每次扩容都会有数组的拷贝，因此这也是影响性能的关键因素。</li>
</ol>
<h1 id="三、基本操作"><a href="#三、基本操作" class="headerlink" title="三、基本操作"></a>三、基本操作</h1><p>接下来就是最基本的增删改查操作</p>
<h2 id="1、增"><a href="#1、增" class="headerlink" title="1、增"></a>1、增</h2><p>向ArrayList中增加新的元素。主要是add与addAll方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在指定位置插入元素或集合中元素时，首先调用该方法判断指定的位置是否合法  </span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">outOfBoundsMsg</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> <span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+size;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="comment">/* </span></div><div class="line"> * add与addAll </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;<span class="comment">//在容器末尾加入一个指定新的元素  </span></div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!  </span></div><div class="line">    elementData[size++] = e;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;<span class="comment">//在指定位置插入一个指定的元素  </span></div><div class="line">    rangeCheckForAdd(index);  </div><div class="line">  </div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!  </span></div><div class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,  </div><div class="line">                     size - index);  </div><div class="line">    elementData[index] = element;  </div><div class="line">    size++;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<span class="comment">//在容器末尾加入一个指定集合中的所有的元素  </span></div><div class="line">    Object[] a = c.toArray();  </div><div class="line">    <span class="keyword">int</span> numNew = a.length;  </div><div class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount  </span></div><div class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);  </div><div class="line">    size += numNew;  </div><div class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;<span class="comment">//在指定位置插入一个指定集合的所有的元素  </span></div><div class="line">    rangeCheckForAdd(index);  </div><div class="line">  </div><div class="line">    Object[] a = c.toArray();  </div><div class="line">    <span class="keyword">int</span> numNew = a.length;  </div><div class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount  </span></div><div class="line">  </div><div class="line">    <span class="keyword">int</span> numMoved = size - index;  </div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)  </div><div class="line">        System.arraycopy(elementData, index, elementData, index + numNew,  </div><div class="line">                         numMoved);  </div><div class="line">  </div><div class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);  </div><div class="line">    size += numNew;  </div><div class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，向ArrayList中加入元素的效率并不是很高，向指定位置插入的时候，会调用System.arraycopy()方法将该元素后面的元素整体向后移动。</p>
<h2 id="2、读"><a href="#2、读" class="headerlink" title="2、读"></a>2、读</h2><p>get方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;<span class="comment">//在set、get和remove方法之前调用该方法检查给定位置是否合法  </span></div><div class="line">    <span class="keyword">if</span> (index &gt;= size)  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)  </div><div class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> (E) elementData[index];  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;<span class="comment">//返回指定位置的元素  </span></div><div class="line">    rangeCheck(index);  </div><div class="line">  </div><div class="line">    <span class="keyword">return</span> elementData(index);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>读即获取指定位置的元素，由于ArrayList是基于数组实现的，所以该操作可以在O(1)的时间内完成。上面提到过，用于存储元素的elementData的数组是Object数组，所以返回的时候会加上类型转换，向下转型。</p>
<h2 id="3、查"><a href="#3、查" class="headerlink" title="3、查"></a>3、查</h2><p>ArrayList的查主要是查找容器中是否包含某个元素，这里也加入了一些容器基本信息的查询</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//返回容器中持有元素的个数  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> size;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="comment">//返回容器是否为空，即没有元素  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="comment">/* </span></div><div class="line"> * 查找给定元素 </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;<span class="comment">//返回容器中是否包含某个元素  </span></div><div class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;  </div><div class="line">&#125;      </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;<span class="comment">//返回某个元素第一次出现的位置，如果没有则返回-1  </span></div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;<span class="comment">//注意null和非null元素相等是不一样的  </span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)  </div><div class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)  </div><div class="line">                <span class="keyword">return</span> i;  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)  </div><div class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))  </div><div class="line">                <span class="keyword">return</span> i;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;<span class="comment">//返回某个元素从后向前第一次出现的位置  </span></div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  </div><div class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)  </div><div class="line">                <span class="keyword">return</span> i;  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  </div><div class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))  </div><div class="line">                <span class="keyword">return</span> i;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4、改"><a href="#4、改" class="headerlink" title="4、改"></a>4、改</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;<span class="comment">//将指定位置的元素改为输入的元素  </span></div><div class="line">    rangeCheck(index);  </div><div class="line">  </div><div class="line">    E oldValue = elementData(index);  </div><div class="line">    elementData[index] = element;  </div><div class="line">    <span class="keyword">return</span> oldValue;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法同样也只需要O(1)的时间。</p>
<h2 id="5、删"><a href="#5、删" class="headerlink" title="5、删"></a>5、删</h2><p>删除操作，包括remove、clear等方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;<span class="comment">//删除指定位置的元素，并作为返回值返回  </span></div><div class="line">    rangeCheck(index);  </div><div class="line">  </div><div class="line">    modCount++;  </div><div class="line">    E oldValue = elementData(index);  </div><div class="line">  </div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;  </div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)  </div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,  </div><div class="line">                         numMoved);  </div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work  </span></div><div class="line">  </div><div class="line">    <span class="keyword">return</span> oldValue;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;<span class="comment">//快速删除指定位置的元素，与上面的相比跳过了检查位置合法性并且没有返回值  </span></div><div class="line">    modCount++;  </div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;  </div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)  </div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,  </div><div class="line">                         numMoved);  </div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work  </span></div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;<span class="comment">//首先查找指定元素是否存在，如果存在将其删除并返回true，如果不存在返回false  </span></div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)  </div><div class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;  </div><div class="line">                fastRemove(index);  </div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">            &#125;  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)  </div><div class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;  </div><div class="line">                fastRemove(index);  </div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">            &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;<span class="comment">//删除容器内所有的元素，将其变为空  </span></div><div class="line">    modCount++;  </div><div class="line">  </div><div class="line">    <span class="comment">// clear to let GC do its work  </span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)  </div><div class="line">        elementData[i] = <span class="keyword">null</span>;  </div><div class="line">  </div><div class="line">    size = <span class="number">0</span>;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;<span class="comment">//删除指定区间内的所有元素  </span></div><div class="line">    modCount++;  </div><div class="line">    <span class="keyword">int</span> numMoved = size - toIndex;  </div><div class="line">    System.arraycopy(elementData, toIndex, elementData, fromIndex,  </div><div class="line">                     numMoved);  </div><div class="line">  </div><div class="line">    <span class="comment">// clear to let GC do its work  </span></div><div class="line">    <span class="keyword">int</span> newSize = size - (toIndex-fromIndex);  </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize; i &lt; size; i++) &#123;  </div><div class="line">        elementData[i] = <span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">    size = newSize;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，两个remove方法都需要调用System.arraycopy方法将删除元素后面的元素向前移，效率同样不高。</p>
<h2 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h2><p>本节介绍了ArrayList的常用基本操作。</p>
<ol>
<li>在这些操作中，不管是add还是remove方法，只要是数组中增加或者减少一个或多个元素，就要调用System.arraycopy方法来拷贝大量元素。</li>
<li>查找元素采用最原始的顺序查找，所以效率为O(n)。</li>
<li>而get和set方法则只需要O(1)时间就可以直接读取或者更改数组中的元素。</li>
<li>综上所述，ArrayLis使用与读取与修改频繁而插入删除操作较少的情况。</li>
</ol>
<h1 id="四、其他方法"><a href="#四、其他方法" class="headerlink" title="四、其他方法"></a>四、其他方法</h1><h2 id="1、System-arraycopy与Arrays-copyOf"><a href="#1、System-arraycopy与Arrays-copyOf" class="headerlink" title="1、System.arraycopy与Arrays.copyOf"></a>1、System.arraycopy与Arrays.copyOf</h2><p>在源码中，出现了很多次System.arraycopy和Arrays.copyOf方法，在此总结一下他们之间的关系。</p>
<h3 id="1-1、System-arraycopy"><a href="#1-1、System-arraycopy" class="headerlink" title="1.1、System.arraycopy"></a>1.1、System.arraycopy</h3><p>上面提到，不管是add还是remove方法，只要是数组中增加或者减少一个或多个元素，就要调用System.arraycopy方法来拷贝大量元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,  </span></span></div><div class="line">                                    Object dest, <span class="keyword">int</span> destPos,  </div><div class="line">                                    <span class="keyword">int</span> length);</div></pre></td></tr></table></figure>
<p>可以看出，该方法就将制定长度的数组复制到另一个数组中。声明为native关键字，调用的为C++编写的底层函数，在JDK中看不到源码。</p>
<p> 貌似在openJDK中可以看见源码，实际上调用了c语言的memmove()函数，可以保证同一个数组内元素的正确复制和移动，比一般复制方法的效率高很多，适合用来批量处理数组。java强烈推荐在复制大量数组元素时使用该方法，在次也再次意识到C和C++对于底层操作的优越性。</p>
<h3 id="1-2、Arrays-copyOf"><a href="#1-2、Arrays-copyOf" class="headerlink" title="1.2、Arrays.copyOf"></a>1.2、Arrays.copyOf</h3><p>Arrays.copyOf是Arrays类中的静态方法，它有很多重载版本，但是最后都调用了一个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;  </div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)  </div><div class="line">    T[] copy = ((Object)newType == (Object)Object[].class)  </div><div class="line">        ? (T[]) <span class="keyword">new</span> Object[newLength]  </div><div class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);  </div><div class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,  </div><div class="line">                     Math.min(original.length, newLength));  </div><div class="line">    <span class="keyword">return</span> copy;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>T为指定的类型，他的原理就是在内部创建一个新的指定类型的数组，然后调用System.arraycopy方法将原数组中的元素复制过去，然后返回新建的数组。</p>
<h2 id="2、toArray方法"><a href="#2、toArray方法" class="headerlink" title="2、toArray方法"></a>2、toArray方法</h2><p>ArrayList有两个转化为静态数组的toArray方法。</p>
<h3 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Object[] toArray() &#123;  </div><div class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, size);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一个，直接调用Arrays.copyOf方法，将elementData内元素全部复制到一个新的数组然后返回新数组，因为elementData是Object的，所以返回的数组也是Object的，需要自己转换类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Integer[] num=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;  </div><div class="line">List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(num)); </div><div class="line"></div><div class="line">Object[] o=list.toArray();</div><div class="line">Integer[] i=(Integer[]) list.toArray();</div></pre></td></tr></table></figure>
<h3 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)  </div><div class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;  </div><div class="line">    <span class="keyword">if</span> (a.length &lt; size)  </div><div class="line">        <span class="comment">// Make a new array of a's runtime type, but my contents:  </span></div><div class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());  </div><div class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);  </div><div class="line">    <span class="keyword">if</span> (a.length &gt; size)  </div><div class="line">        a[size] = <span class="keyword">null</span>;  </div><div class="line">    <span class="keyword">return</span> a;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二个，可以传入一个指定的数组</p>
<p>如果数组的长度小于size也就是说不足够容纳elementData中的元素，那么就会创建一个新的数组并将size个元素拷贝到新的数组中然后返回新建的数组。</p>
<ul>
<li>如果数组长度与size相等，那么直接将elementData中元素拷贝到传入的数组中。</li>
<li>如果数组长度大于size，复制以后还会把第size个元素置为null。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Integer[] num=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;  <span class="comment">//</span></div><div class="line">List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(num)); </div><div class="line">Integer[] i=<span class="keyword">new</span> Integer[<span class="number">0</span>];</div><div class="line">i=list.toArray(i);</div><div class="line">System.out.println(Arrays.toString(i));</div></pre></td></tr></table></figure>
<blockquote>
<p> output: [2, 3, 4, 5]</p>
</blockquote>
<p>该方法与第一个方法的区别就是，无论是返回新建的数组还是复制到传入的数组，返回的数组类型都是和传入数组相同的，而不是上面的Object。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LinkedHashMap源码分析]]></title>
      <url>http://yoursite.com/2016/11/12/Java/JDK/LinkedHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>LinkedHashMap是前面分析过的HashMap的子类，主要的作用就是在HashMap的基础上可以保证元素的插入顺序或访问顺序，内存访问算法中很经典的LRU算法就可以基于LinkedHashMap实现，在面试中也很常见。</p>
<p>LinkedHashMap继承自HashMap，关于map的操作基本一样，只是加入了维护访问顺序加入了一些新的特性。</p>
<ol>
<li>重写HashMap.Node，加入了before和after两个属性，用于表示双向链表中的前后结点。</li>
<li>关键方法如put()、get()、remove等基本与父类操作相同，只是有少量的改动或者直接调用父类方法。</li>
<li>三个关键方法：afterNodeInsertion()、afterNodeAccess()、afterNodeRemoval()在执行完可能会影响插入或访问顺序的操作后调用这三个方法，来维持顺序。</li>
</ol>
<h1 id="一、基本构造函数"><a href="#一、基本构造函数" class="headerlink" title="一、基本构造函数"></a>一、基本构造函数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></div><div class="line">    <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</div><div class="line">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</div><div class="line">&#123;  </div><div class="line">    <span class="comment">//继承HashMap.Node，加入了before和after两个属性，用于表示双向链表中的前后结点</span></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">        Entry&lt;K,V&gt; before, after;</div><div class="line">        Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</div><div class="line">            <span class="keyword">super</span>(hash, key, value, next);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//双向链表的头结点</span></div><div class="line">    <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</div><div class="line"></div><div class="line">    <span class="comment">//双向链表的尾结点</span></div><div class="line">    <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</div><div class="line"></div><div class="line">    <span class="comment">// false: 基于插入顺序     true:  基于访问顺序 </span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 构造函数</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);</div><div class="line">        accessOrder = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(initialCapacity);</div><div class="line">        accessOrder = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        accessOrder = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        accessOrder = <span class="keyword">false</span>;</div><div class="line">        putMapEntries(m, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//通过accessOrder，来设置LinkedHashMap是保证插入顺序还是访问顺序</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></div><div class="line">                         <span class="keyword">float</span> loadFactor,</div><div class="line">                         <span class="keyword">boolean</span> accessOrder) &#123;</div><div class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);</div><div class="line">        <span class="keyword">this</span>.accessOrder = accessOrder;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="1、加入双向链表"><a href="#1、加入双向链表" class="headerlink" title="1、加入双向链表"></a>1、加入双向链表</h2><p>可以看出，LinkedHashMap对结点加入了新的属性，before和after，用以表示形成双向链表。</p>
<p>同时加入了head和tail结点，表示双向链表的头结点和尾结点，通过链表头结点到尾结点的顺序来表示map中元素的插入顺序或访问顺序。</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/java/10.png?raw=true" alt=""></p>
<h2 id="2、accessOrder"><a href="#2、accessOrder" class="headerlink" title="2、accessOrder"></a>2、accessOrder</h2><p>accessOrder是LinkedHashMap中一个关键的属性。</p>
<p>上面说到LinkedHashMap能够保存元素的插入顺序或者是访问顺序，就是通过accessOrder这一变量来决定的。</p>
<p>accessOrder默认为false，即保存插入顺序。</p>
<p>accessOrder为true时，保存访问顺序，其实访问顺序只是在插入顺序的基础上，在每次访问元素时，对链表顺序进行修改。</p>
<h2 id="3、构造函数"><a href="#3、构造函数" class="headerlink" title="3、构造函数"></a>3、构造函数</h2><p>从构造函数可以看出，LinkedHashMap的构造函数都是调用父类的，默认将accessOrder设置为false。</p>
<p>最后一个构造函数可以自己指定accessOrder。</p>
<p>下面来看一下map最常用的几个方法是如何实现的。</p>
<h1 id="二、put-方法"><a href="#二、put-方法" class="headerlink" title="二、put()方法"></a>二、put()方法</h1><p>首先还是put方法，看过源码才知道原来LinkedHashMap并没有重写父类的put方法，所以还是要再回到前面分析的HashMap的put方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;  </div><div class="line">     <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);  </div><div class="line"> &#125;      </div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;  </div><div class="line">     <span class="keyword">int</span> h;  </div><div class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);  </div><div class="line"> &#125;  </div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;  </div><div class="line">    Node&lt;K, V&gt;[] tab;</div><div class="line">    Node&lt;K, V&gt; p;</div><div class="line">    <span class="keyword">int</span> n, i;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">        n = (tab = resize()).length;        </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) </div><div class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);<span class="comment">//新建结点</span></div><div class="line"></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        Node&lt;K, V&gt; e;</div><div class="line">        K k;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))  </div><div class="line">            e = p;  </div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)  </div><div class="line">            e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);  </div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">else</span> &#123;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>;; ++binCount) &#123;</div><div class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) </div><div class="line">                        treeifyBin(tab, hash);</div><div class="line">                    <span class="keyword">break</span>;  </div><div class="line">                &#125;  </div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; </div><div class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))  </div><div class="line">                    <span class="keyword">break</span>;  </div><div class="line"></div><div class="line">                p = e;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </div><div class="line">            V oldValue = e.value;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)  </div><div class="line">                e.value = value;  </div><div class="line">            afterNodeAccess(e);  </div><div class="line">            <span class="keyword">return</span> oldValue;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line"></div><div class="line">    ++modCount;  </div><div class="line">    <span class="keyword">if</span> (++size &gt; threshold) </div><div class="line">        resize();  </div><div class="line">    afterNodeInsertion(evict);  <span class="comment">//调用函数</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码是直接从上篇分析中粘下来的，去掉了所有的注释，又新加入了两个注释，这两个也是唯一与LinkedHashMap相关的地方。</p>
<h2 id="1、newNode"><a href="#1、newNode" class="headerlink" title="1、newNode"></a>1、newNode</h2><p>LinkedHashMap与HashMap在map的存储方式上实现过程是一样的，区别在于LinkedHashMap需要通过双向链表来保存map的插入顺序，所以，区别之一就是新建的结点肯定不能是父类中原有的结点，所以LinkedHashMap重写了父类的newNode方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</div><div class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</div><div class="line">    linkNodeLast(p);</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</div><div class="line">    tail = p;</div><div class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</div><div class="line">        head = p;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        p.before = last;</div><div class="line">        last.after = p;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，在新建一个node之后，又调用了linkNodeLast方法，目的在于把这个新建的结点加入到双向链表的尾结点上，这样就保证了插入的顺序。</p>
<h2 id="2、afterNodeInsertion-方法"><a href="#2、afterNodeInsertion-方法" class="headerlink" title="2、afterNodeInsertion()方法"></a>2、afterNodeInsertion()方法</h2><p>上面的put方法中第二个注释的地方，调用了afterNodeInsertion方法，</p>
<p>在父类HashMap中，afterNodeInsertion和其他两个方法并没有具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</div></pre></td></tr></table></figure>
<p>注释写的很明白，是为了LinkedHashMap准备的。方法名也很清楚，就是插入一个结点之后要做的事。下面是LinkedHashMap中重写的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</div><div class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</div><div class="line">        K key = first.key;</div><div class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">&#125;    </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正常来说，在插入结点的时候通过链表保存插入顺序，这就足够了，那么为什么还要调用这个方法呢，插入之后还有什么需要做的呢？</p>
<p>注释里面写了，这个方法可能的作用就是删除掉最老的元素，也就是离当前访问最远的元素。没错，这也是实现LRU时要重写的一个方法。下面的removeEldestEntry给出了判断的条件，重写时可以自由指定，比如当size大于指定的值后，就返回true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> size() &gt; capacity;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>返回true后，就会删除掉head结点，也就是链表中的第一个结点。</p>
<h1 id="三、get方法"><a href="#三、get方法" class="headerlink" title="三、get方法"></a>三、get方法</h1><h2 id="1、重写get方法"><a href="#1、重写get方法" class="headerlink" title="1、重写get方法"></a>1、重写get方法</h2><p>与put方法不一样的是LinkedHashMap直接重写了get方法，原因在于在get的过程中需要判断accessOrder，这是子类的属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (accessOrder)</div><div class="line">        afterNodeAccess(e);</div><div class="line">    <span class="keyword">return</span> e.value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看一下父类的get方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>子类中并没有重写getNode方法，所以两个get方法唯一的区别就在于，子类在getNode之后会判断accessOrder，以判断是否调用afterNodeAccess方法。</p>
<p>也就是说，get方法正常来说是不会影响map的结构的也不会影响插入的顺序，但是这个操作会影响访问的顺序，所以如果accessOrder为true，那么在调用get方法之后，访问顺序就发生了变化，就需要调用afterNodeAccess方法来改变访问顺序。</p>
<h2 id="2、afterNodeAccess-方法"><a href="#2、afterNodeAccess-方法" class="headerlink" title="2、afterNodeAccess()方法"></a>2、afterNodeAccess()方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</div><div class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</div><div class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</div><div class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</div><div class="line">        p.after = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</div><div class="line">            head = a;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            b.after = a;</div><div class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</div><div class="line">            a.before = b;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            last = b;</div><div class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</div><div class="line">            head = p;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            p.before = last;</div><div class="line">            last.after = p;</div><div class="line">        &#125;</div><div class="line">        tail = p;</div><div class="line">        ++modCount;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>afterNodeAccess做的很简单，当访问元素e之后，它就成了最新访问的，所以需要把它移动到链表的尾部。</p>
<h1 id="四、remove方法"><a href="#四、remove方法" class="headerlink" title="四、remove方法"></a>四、remove方法</h1><h2 id="1、直接调用父类remove方法"><a href="#1、直接调用父类remove方法" class="headerlink" title="1、直接调用父类remove方法"></a>1、直接调用父类remove方法</h2><p>remove方法与put方法基本类似，子类都没有重写，再来看一下父类中的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;  </div><div class="line">       Node&lt;K,V&gt; e;  </div><div class="line">       <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?  </div><div class="line">           <span class="keyword">null</span> : e.value;  </div><div class="line">   &#125;  </div><div class="line"></div><div class="line">   <span class="comment">/* </span></div><div class="line">    * 实现Map.remove及相关方法 </div><div class="line">    */  </div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K, V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,   </span></span></div><div class="line">        <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable) &#123;  </div><div class="line">    Node&lt;K, V&gt;[] tab;</div><div class="line">    Node&lt;K, V&gt; p;</div><div class="line">    <span class="keyword">int</span> n, index; </div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;   </div><div class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;              </div><div class="line">        Node&lt;K, V&gt; node = <span class="keyword">null</span>, e;  </div><div class="line">        K k;  </div><div class="line">        V v;  </div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))  </div><div class="line">            node = p;  </div><div class="line"></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)  </div><div class="line">                node = ((TreeNode&lt;K, V&gt;) p).getTreeNode(hash, key);  </div><div class="line">            <span class="keyword">else</span> &#123;  </div><div class="line">                <span class="keyword">do</span> &#123;  </div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;  </div><div class="line">                        node = e;  </div><div class="line">                        <span class="keyword">break</span>;  </div><div class="line">                    &#125;  </div><div class="line">                    p = e;  </div><div class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue ||  </div><div class="line">            (v = node.value) == value || (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;  </div><div class="line"></div><div class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                ((TreeNode&lt;K, V&gt;) node).removeTreeNode(<span class="keyword">this</span>, tab, movable);  </div><div class="line"></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</div><div class="line">                tab[index] = node.next;</div><div class="line"></div><div class="line">            <span class="keyword">else</span> </div><div class="line">                p.next = node.next; </div><div class="line">            ++modCount;  </div><div class="line">            --size;</div><div class="line">            afterNodeRemoval(node); <span class="comment">//调用函数</span></div><div class="line">            <span class="keyword">return</span> node;  </div><div class="line">        &#125;  </div><div class="line">    &#125;   </div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这也是从上篇分析中粘下来的，由于不用新建结点，所以remove方法只是在后面调用了afterNodeRemoval方法，这是唯一的区别</p>
<h2 id="2、afterNodeRemoval-方法"><a href="#2、afterNodeRemoval-方法" class="headerlink" title="2、afterNodeRemoval()方法"></a>2、afterNodeRemoval()方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</div><div class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</div><div class="line">    p.before = p.after = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</div><div class="line">        head = a;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        b.after = a;</div><div class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</div><div class="line">        tail = b;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        a.before = b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>afterNodeRemoval方法也很简单，就是更新删除的结点e的前后结点的指针，以保证链表的结构。</p>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><ol>
<li><p>了解HashMap之后再来看LinkedHashMap就会快很多。</p>
</li>
<li><p>两个类是父子关系，所以大部分实现方法都是相同的。</p>
</li>
<li><p>子类是父类的扩展，扩展的地方就是保证插入或访问的顺序，而扩展的方式就是通过加入一个双向链表来维持。</p>
</li>
<li><p>子类主要重写了几个可能会影响到插入或访问顺序的方法，比如put，get，remove</p>
</li>
<li><p>重写的方法主要就是加入了对链表的维护</p>
<ul>
<li>put方法，新建结点时指定前后结点，超过了某范围后可以进行删除 </li>
<li>get方法在访问元素时更新链表结构来更新访问顺序</li>
<li>remove方法也是在删除结点后更新链表的结构</li>
</ul>
</li>
</ol>
<p>   ​</p>
<p>   ​</p>
<p>   ​</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HashMap源码分析]]></title>
      <url>http://yoursite.com/2016/11/12/Java/JDK/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>Hashmap是Java中非常常用的容器，在网上看见很多源码分析都是以前版本的，本文章结合JDK1.8的源码对HashMap进行简单的分析，在学习的过程中发现HashMap的源码远比前面的List要复杂的多，花了好长时间才理清关系。</p>
<h1 id="O、哈希函数的构造方法与冲突处理"><a href="#O、哈希函数的构造方法与冲突处理" class="headerlink" title="O、哈希函数的构造方法与冲突处理"></a>O、哈希函数的构造方法与冲突处理</h1><p>在面试的时候经常见到哈希冲突的解决方法，所以在分析HashMap之前，加入了这部分。</p>
<p>哈希法又称<strong>散列法、杂凑法以及关键字地址计算法</strong>等，相应的表称为<strong>哈希表。</strong>这种方法的基本思想是：首先在元素的关键字k和元素的存储位置p之间建立一个对应关系f，使得p=f(k)，f称为<strong>哈希函数</strong>。创建哈希表时，把关键字为k的元素直接存入地址为f(k)的单元；以后当查找关键字为k的元素时，再利用哈希函数计算出该元素的存储位置p=f(k)，从而达到按关键字直接存取元素的目的。</p>
<h2 id="1、哈希函数的构造方法"><a href="#1、哈希函数的构造方法" class="headerlink" title="1、哈希函数的构造方法"></a>1、哈希函数的构造方法</h2><p>构造哈希函数的原则是：</p>
<ol>
<li>函数本身便于计算</li>
<li>计算出来的地址分布均匀，即对任一关键字k，f(k) 对应不同地址的概率相等，目的是尽可能减少冲突。</li>
</ol>
<p>主要有一下集中方法：</p>
<ol>
<li>数字分析法</li>
<li>平方取中法</li>
<li>分段叠加法</li>
<li>除留余数法</li>
<li>伪随机数法</li>
</ol>
<h3 id="1-1、数字分析法"><a href="#1-1、数字分析法" class="headerlink" title="1.1、数字分析法"></a>1.1、数字分析法</h3><p>如果事先知道关键字集合，并且每个关键字的位数比哈希表的地址码位数多时，可以从关键字中选出分布较均匀的若干位，构成哈希地址。例如，有80个记录，关键字为8位十进制整数d1d2d3…d7d8，如哈希表长取100，则哈希表的地址空间为：00~99。假设经过分析，各关键字中 d4和d7的取值分布较均匀，则哈希函数为：h(key)=h(d1d2d3…d7d8)=d4d7。例如，h(81346532)=43，h(81301367)=06。相反，假设经过分析，各关键字中 d1和d8的取值分布极不均匀， d1 都等于5，d8 都等于2，此时，如果哈希函数为：h(key)=h(d1d2d3…d7d8)=d1d8，则所有关键字的地址码都是52，显然不可取。</p>
<h3 id="1-2、平方取中法"><a href="#1-2、平方取中法" class="headerlink" title="1.2、平方取中法"></a>1.2、平方取中法</h3><p>当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址。</p>
<p>例：我们把英文字母在字母表中的位置序号作为该英文字母的内部编码。例如K的内部编码为11，E的内部编码为05，Y的内部编码为25，A的内部编码为01, B的内部编码为02。由此组成关键字“KEYA”的内部代码为11052501，同理我们可以得到关键字“KYAB”、“AKEY”、“BKEY”的内部编码。之后对关键字进行平方运算后，取出第7到第9位作为该关键字哈希地址 </p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>内部编码</th>
<th>内部编码的平方值</th>
<th>H(k)关键字的哈希地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>KEYA</td>
<td>11050201</td>
<td>122157778355001</td>
<td>778</td>
</tr>
<tr>
<td>KYAB</td>
<td>11250102</td>
<td>126564795010404</td>
<td>795</td>
</tr>
<tr>
<td>AKEY</td>
<td>01110525</td>
<td>001233265775625</td>
<td>265</td>
</tr>
<tr>
<td>BKEY</td>
<td>02110525</td>
<td>004454315775625</td>
<td>315</td>
</tr>
</tbody>
</table>
<h3 id="1-3、分段叠加法"><a href="#1-3、分段叠加法" class="headerlink" title="1.3、分段叠加法"></a>1.3、分段叠加法</h3><p>这种方法是按哈希表地址位数将关键字分成位数相等的几部分（最后一部分可以较短），然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。具体方法有<strong>折叠法</strong>与<strong>移位法。</strong>移位法是将分割后的每部分低位对齐相加，折叠法是从一端向另一端沿分割界来回折叠（奇数段为正序，偶数段为倒序），然后将各段相加。例如：key=12360324711202065,哈希表长度为1000，则应把关键字分成3位一段，在此舍去最低的两位65，分别进行移位叠加和折叠叠加，求得哈希地址为1105和907</p>
<p>​        1   2   3                        1   2   3</p>
<p>​        6   0   3                        3   0   6</p>
<p>​        2   4   7                            2   4   7</p>
<p>​        1   1   2                        2   1   1</p>
<p>​     +)    0   2   0                    +)  0   2   0</p>
<pre><code>————————            —————————

      1   1   0   5                         9   0   7
</code></pre><p>​       (a)移位叠加                    (b) 折叠叠加</p>
<h3 id="1-4、除留余数法"><a href="#1-4、除留余数法" class="headerlink" title="1.4、除留余数法"></a>1.4、除留余数法</h3><p>假设哈希表长为m，p为小于等于m的最大素数，则哈希函数为</p>
<p>h（k）=k  %  p ，其中%为模p取余运算。</p>
<p>例如，已知待散列元素为（18，75，60，43，54，90，46），表长m=10，p=7，则有</p>
<pre><code>h(18)=18 % 7=4    h(75)=75 % 7=5    h(60)=60 % 7=4   

h(43)=43 % 7=1    h(54)=54 % 7=5    h(90)=90 % 7=6   

h(46)=46 % 7=4
</code></pre><p>此时冲突较多。为减少冲突，可取较大的m值和p值，如m=p=13，结果如下：</p>
<pre><code>h(18)=18 % 13=5    h(75)=75 % 13=10    h(60)=60 % 13=8    

h(43)=43 % 13=4    h(54)=54 % 13=2    h(90)=90 % 13=12   

h(46)=46 % 13=7
</code></pre><h3 id="1-5、伪随机数法"><a href="#1-5、伪随机数法" class="headerlink" title="1.5、伪随机数法"></a>1.5、伪随机数法</h3><p>采用一个伪随机函数做哈希函数，即h(key)=random(key)。</p>
<p>在实际应用中，应根据具体情况，灵活采用不同的方法，并用实际数据测试它的性能，以便做出正确判定。通常应考虑以下五个因素 ：</p>
<p>l         计算哈希函数所需时间 （简单）。</p>
<p>l         关键字的长度。</p>
<p>l         哈希表大小。</p>
<p>l         关键字分布情况。</p>
<p>l         记录查找频率</p>
<h2 id="2、哈希冲突的解决方法"><a href="#2、哈希冲突的解决方法" class="headerlink" title="2、哈希冲突的解决方法"></a>2、哈希冲突的解决方法</h2><p>通过构造性能良好的哈希函数，可以减少冲突，但一般不可能完全避免冲突，因此解决冲突是哈希法的另一个关键问题。创建哈希表和查找哈希表都会遇到冲突，两种情况下解决冲突的方法应该一致。下面以创建哈希表为例，说明解决冲突的方法。常用的解决冲突方法有以下四种：</p>
<ol>
<li>开放地址法</li>
<li>再哈希法</li>
<li>链地址法</li>
<li>建立公共溢出区</li>
</ol>
<h3 id="2-1、开放地址法"><a href="#2-1、开放地址法" class="headerlink" title="2.1、开放地址法"></a>2.1、开放地址法</h3><p>其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。</p>
<h3 id="2-2、再哈希法"><a href="#2-2、再哈希法" class="headerlink" title="2.2、再哈希法"></a>2.2、再哈希法</h3><p>这种方法是同时构造多个不同的哈希函数：</p>
<pre><code>Hi=RH1（key）  i=1，2，…，k
</code></pre><p>当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。</p>
<h3 id="2-3、链地址法"><a href="#2-3、链地址法" class="headerlink" title="2.3、链地址法"></a>2.3、链地址法</h3><p>这种方法的基本思想是将所有哈希地址为i的元素构成一个称为<strong>同义词链</strong>的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。</p>
<p>下面要介绍的HashMap采用的就是这种方法</p>
<h3 id="3-4、建立公共溢出区"><a href="#3-4、建立公共溢出区" class="headerlink" title="3.4、建立公共溢出区"></a>3.4、建立公共溢出区</h3><p>这种方法的基本思想是：将哈希表分为<strong>基本表</strong>和<strong>溢出表</strong>两部分，凡是和基本表发生冲突的元素，一律填入溢出表</p>
<p>参考地址<a href="http://blog.sina.com.cn/s/blog_6fd335bb0100v1ks.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_6fd335bb0100v1ks.html</a></p>
<p>下面开始正式分析Java中的HashMap源码</p>
<h1 id="一、基本参数与构造函数"><a href="#一、基本参数与构造函数" class="headerlink" title="一、基本参数与构造函数"></a>一、基本参数与构造函数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;  </div><div class="line">      </div><div class="line">      </div><div class="line">    <span class="comment">/* ---------------- Fields -------------- */</span>  </div><div class="line">  </div><div class="line">    <span class="comment">//存储节点的table数组，第一次使用的时候初始化，必要时resize，长度总是2的幂 </span></div><div class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;  </div><div class="line">  </div><div class="line">    <span class="comment">//缓存entrySet，用于keySet() and values()  </span></div><div class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;  </div><div class="line">  </div><div class="line">    <span class="comment">//容器中元素的个数  </span></div><div class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;  </div><div class="line">  </div><div class="line">    <span class="comment">//每次扩容和更改map结构的计数器  </span></div><div class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;  </div><div class="line">  </div><div class="line">    <span class="comment">//阈值，当实际大小超过阈值时，会进行扩容  </span></div><div class="line">    <span class="keyword">int</span> threshold;  </div><div class="line">  </div><div class="line">    <span class="comment">//装载因子  </span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;      </div><div class="line">      </div><div class="line">      </div><div class="line">  </div><div class="line">    <span class="comment">//默认的初始容量，必须是2的幂次，出于优化考虑，默认16  </span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;   </div><div class="line">  </div><div class="line">    <span class="comment">//默认的最大容量  </span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;  </div><div class="line">  </div><div class="line">    <span class="comment">//默认的装载因子，在无参构造器中默认设为该值  </span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;  </div><div class="line">  </div><div class="line">    <span class="comment">//阈值，当链表中节点数大于该阈值后就会转变成红黑树  </span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;  </div><div class="line">  </div><div class="line">    <span class="comment">//与上一个阈值相反，当小于这个阈值后转变回链表  </span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;  </div><div class="line">  </div><div class="line">    <span class="comment">// 看源码注释里说是：树的最小的容量，至少是 4 x TREEIFY_THRESHOLD = 32 然后为了避免(resizing 和 treeification thresholds) 设置成64  </span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;  </div><div class="line">  </div><div class="line">  </div><div class="line">  </div><div class="line">    <span class="comment">//基本哈希容器节点 实现Map.Entry接口  </span></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;  </div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;<span class="comment">//不可变的哈希值，由关键字key得来  </span></div><div class="line">        <span class="keyword">final</span> K key;<span class="comment">//不可变的关键字  </span></div><div class="line">        V value;  </div><div class="line">        Node&lt;K,V&gt; next;  </div><div class="line">  </div><div class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;  </div><div class="line">            <span class="keyword">this</span>.hash = hash;  </div><div class="line">            <span class="keyword">this</span>.key = key;  </div><div class="line">            <span class="keyword">this</span>.value = value;  </div><div class="line">            <span class="keyword">this</span>.next = next;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;  </div><div class="line">  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;<span class="comment">//Node对象的哈希值，关键字key的hashCode()与值value的hashCode()做异或运算    </span></div><div class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;  </div><div class="line">            V oldValue = value;  </div><div class="line">            value = newValue;  </div><div class="line">            <span class="keyword">return</span> oldValue;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;<span class="comment">//对象相同或同类型且key-value均相同，则返回true    </span></div><div class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)  </div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;  </div><div class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;  </div><div class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;  </div><div class="line">                    Objects.equals(value, e.getValue()))  </div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="comment">/* </span></div><div class="line">     * 构造函数 </div><div class="line">     */  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;<span class="comment">//给定初始容量和装载因子，构造一个空的HashMap  </span></div><div class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)  </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +  </div><div class="line">                                               initialCapacity);  </div><div class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)  </div><div class="line">            initialCapacity = MAXIMUM_CAPACITY;  </div><div class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))  </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +  </div><div class="line">                                               loadFactor);  </div><div class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;  </div><div class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);<span class="comment">//根据指定的容量计算容量，因为必须是2的幂次，虽然将该值赋给threshold，但表示的依然是容量，到时候会重新计算阈值  </span></div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;<span class="comment">//指定初始容量，和默认装载因子0.75构造空HashMap  </span></div><div class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;<span class="comment">//无参，使用默认的初始容量16,和装载因子0.75构造空的HashMap  </span></div><div class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;   </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;<span class="comment">//构造一个和给定Map映射相同的HashMap，默认装载因子，初始空间以足够存放给定Map中的映射为准   </span></div><div class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;  </div><div class="line">        putMapEntries(m, <span class="keyword">false</span>);  </div><div class="line">    &#125;      </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面给出了HashMap的定义，和前面的基本参数，内部节点类的定义和4个构造函数。</p>
<h2 id="1、table数组"><a href="#1、table数组" class="headerlink" title="1、table数组"></a>1、table数组</h2><p>该数组类似于一个桶，通过对key值hash运算得到index值，就该节点在数组中的下标，所有index值相同的节点形成链表或者红黑树，而table[index]则指向该链表或者红黑树的头节点。最理想的状态就是每个index中只有一个元素，这样查找一个key的时候，通过O(1)时间计算出index，就可以直接找到该key对应的节点。</p>
<h2 id="2、容量、装载因子和阈值"><a href="#2、容量、装载因子和阈值" class="headerlink" title="2、容量、装载因子和阈值"></a>2、容量、装载因子和阈值</h2><p>个人人为这三个参数是HashMap中最重要的三个参数。</p>
<h3 id="2-1、容量Capacity"><a href="#2-1、容量Capacity" class="headerlink" title="2.1、容量Capacity"></a>2.1、容量Capacity</h3><ol>
<li><p>table数组的大小，一定是2的幂。</p>
</li>
<li><p>如果在构造函数中指定了容量，会调用tableSizeFor()方法来计算出保证是2的倍数的容量:</p>
<blockquote>
<p>this.threshold = tableSizeFor(initialCapacity); </p>
</blockquote>
<p>虽然将该值赋给threshold，但表示的依然是容量，到时候会重新计算阈值。</p>
</li>
<li><p>如果没有指定容量，会使用默认的16，在第一次加入元素的时候会通过resize方法来创建该数组。</p>
</li>
<li><p>初始化之后，每次map中元素超过阈值，容量都会*2，直到达到设定的最大容量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//返回大于指定容量且是2的幂次的值，比如给定999，返回1024  </span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;  </div><div class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;  </div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;  </div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;  </div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;  </div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;  </div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;  </div><div class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>阿里的Java开发手册中提到，【推荐】集合初始化时，指定集合初始值的大小。</p>
<blockquote>
<p>说明： HashMap 使用 HashMap(int initialCapacity) 初始化，</p>
<p>正例：initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即 loader factor） 默认为 0.75， 如果暂时无法确定初始值大小， 请设置为 16。</p>
<p>反例： HashMap 需要放置 1024 个元素， 由于没有设置容量初始大小，随着元素不断增加，容量 7 次被迫扩大， resize 需要重建 hash 表，严重影响性能。 </p>
</blockquote>
<h3 id="2-2、阈值threshold"><a href="#2-2、阈值threshold" class="headerlink" title="2.2、阈值threshold"></a>2.2、阈值threshold</h3><ol>
<li><p>一个临界值，当map中的节点个数超过这个临界值的时候，就要调用resize方法来将table数组扩大2倍，同时阈值也会扩大2倍。</p>
</li>
<li><p>默认情况下threshold=DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY，之后在每次容量翻倍的时候，阈值也跟着翻倍。</p>
</li>
<li><p>如果在构造函数中指定了容量，那么会调用tableSizeFor方法来计算然后把计算结构赋值给阈值。最后初始化之后再重新计算阈值。</p>
<blockquote>
<p>float ft = (float)newCap * loadFactor;</p>
</blockquote>
<p>​</p>
</li>
</ol>
<h3 id="2-3、装载因子loadFactor"><a href="#2-3、装载因子loadFactor" class="headerlink" title="2.3、装载因子loadFactor"></a>2.3、装载因子loadFactor</h3><p>用来计算阈值。举个例子:</p>
<p>如果装载因子是默认的0.75，HashMap(16)的时候，占16个内存空间，实际上只用到了12个，超过12个就扩容。如果负载因子是1的话，HashMap(16)的时候，占16个内存空间，实际上会填满16个以后才会扩容。</p>
<h2 id="3、构造函数"><a href="#3、构造函数" class="headerlink" title="3、构造函数"></a>3、构造函数</h2><p>一共有4个构造函数，前面三个都是构造一个空的HashMap,可以指定容量和装载因子，或者直接使用默认值。第四个构造一个和给定Map映射相同的HashMap，默认装载因子，初始空间以足够存放给定Map中的映射为准，调用putMapEntries方法下面再详细分析。</p>
<h1 id="二、关键方法"><a href="#二、关键方法" class="headerlink" title="二、关键方法"></a>二、关键方法</h1><p>个人人为HashMap最关键的两个方法就是hash函数的实现和resize方法。每次put元素的时候都要先调用hash函数来去诶的那个元素存储的位置，而resize方法用于新建或扩大table的容量，下面主要分析这两个方法。</p>
<h2 id="1、hash函数的实现和put-方法"><a href="#1、hash函数的实现和put-方法" class="headerlink" title="1、hash函数的实现和put()方法"></a>1、hash函数的实现和put()方法</h2><p>put()方法的完整过程为：</p>
<ol>
<li>如果table数组为空，那么调用resize()方法新建数组</li>
<li>对key的hashCode()做hash，然后再计算index;</li>
<li>如果没碰撞直接放到bucket里；</li>
<li>如果碰撞了，放在以链表的形式存在buckets后；</li>
<li>如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；</li>
<li>如果节点已经存在就替换old value(保证key的唯一性)</li>
<li>如果bucket满了(超过load factor*current capacity)，就要resize</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;  </div><div class="line">     <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);  </div><div class="line"> &#125;      </div><div class="line">   </div><div class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;  </div><div class="line">     <span class="keyword">int</span> h;  </div><div class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);  </div><div class="line"> &#125;  </div><div class="line"></div><div class="line"> <span class="comment">/* </span></div><div class="line">  * 实现Map.put以及相关方法 </div><div class="line">  * 向map中加入个节点 </div><div class="line">  * 没有分析onlyIfAbsent和evict </div><div class="line">  */       </div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;  </div><div class="line">    Node&lt;K, V&gt;[] tab;<span class="comment">//指向table数组  </span></div><div class="line">    Node&lt;K, V&gt; p;<span class="comment">//对应下标中的第一个节点，为null说明没有碰撞，不为null代表链表第一个元素或红黑树根节点  </span></div><div class="line">    <span class="keyword">int</span> n, i;<span class="comment">//n为table数组的长度，2的幂次; i表示对应的下标index  </span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="comment">// 如果table为空即第一次添加元素，则进行初始化  </span></div><div class="line">        n = (tab = resize()).length;  </div><div class="line"></div><div class="line">    <span class="comment">/* </span></div><div class="line">     * 计算下标，根据hash与n计算index </div><div class="line">     * 公式:i = (n - 1) &amp; hash; </div><div class="line">     */  </div><div class="line"></div><div class="line">    <span class="comment">// p=table[i]; 对应下标中的第一个节点  </span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">// p为null说明没有碰撞，  </span></div><div class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);<span class="comment">//直接新建一个节点加入就可以了  </span></div><div class="line"></div><div class="line">    <span class="keyword">else</span> &#123;<span class="comment">// p不为null，说明有碰撞  </span></div><div class="line">        Node&lt;K, V&gt; e;<span class="comment">//e，代表map中与给定key值相同的节点  </span></div><div class="line">        K k;<span class="comment">//代表e的key  </span></div><div class="line"></div><div class="line">        <span class="comment">// p的关键字与要加入的关键字相同，则p就是要找的e  </span></div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))  </div><div class="line">            e = p;  </div><div class="line"></div><div class="line">        <span class="comment">// 如果p的类型是红黑树，则向红黑树中查找e  </span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)  </div><div class="line">            e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);  </div><div class="line"></div><div class="line">        <span class="comment">// 否则就是链表  </span></div><div class="line">        <span class="keyword">else</span> &#123;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>;; ++binCount) &#123;<span class="comment">//遍历链表查找e，如果找不到就新建一个  </span></div><div class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;<span class="comment">// 如果next为null，说明没有找到  </span></div><div class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);<span class="comment">// 那么新创建一个节点  </span></div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// 加入节点后如果超出树形化阈值  </span></div><div class="line">                        treeifyBin(tab, hash);<span class="comment">// 则转换为红黑树  </span></div><div class="line">                    <span class="keyword">break</span>;  </div><div class="line">                &#125;  </div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; <span class="comment">// 找到关键字相同的节点，退出循环  </span></div><div class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))  </div><div class="line">                    <span class="keyword">break</span>;  </div><div class="line"></div><div class="line">                p = e;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">//e不为null，说明原来存在对应的key，那么返回原来的值  </span></div><div class="line">            V oldValue = e.value;<span class="comment">// 保留原来的值，用于返回  </span></div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)  </div><div class="line">                e.value = value;  </div><div class="line">            afterNodeAccess(e);  </div><div class="line">            <span class="keyword">return</span> oldValue;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="comment">//说明新插入了一个节点，返回null  </span></div><div class="line">    ++modCount;  </div><div class="line">    <span class="keyword">if</span> (++size &gt; threshold) <span class="comment">// 超过临界值，则resize  </span></div><div class="line">        resize();  </div><div class="line">    afterNodeInsertion(evict);  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1-1、第一次加入元素"><a href="#1-1、第一次加入元素" class="headerlink" title="1.1、第一次加入元素"></a>1.1、第一次加入元素</h3><p>在构造函数中虽然指定了容量，但是并不会初始化table数组，该数组的初始化是在第一次加入元素的时候通过resize()方法完成的:</p>
<blockquote>
<p>if ((tab = table) == null || (n = tab.length) == 0) // 如果table为空即第一次添加元素，则进行初始化  </p>
<p>​     n = (tab = resize()).length; </p>
</blockquote>
<h3 id="1-2、index的计算"><a href="#1-2、index的计算" class="headerlink" title="1.2、index的计算"></a>1.2、index的计算</h3><p>   index值决定了加入的元素要放到table数组中的下标.</p>
<p>在调用put(key, value)方法后会首先调用hash(key)计算出key的hash值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;  </div><div class="line">    <span class="keyword">int</span> h;  </div><div class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>先得到key的hashcode即一个int型32为的整数</li>
<li>然后将它的高16位不变，低16位和高16为做异或操作，得到key的hash值。</li>
</ol>
<p>将hash值传入到putVal()方法中，计算index值：</p>
<blockquote>
<p>i = (n - 1) &amp; hash;  </p>
</blockquote>
<p>其中n为table数组的长度，也就是说它肯定是2的幂次，举个例子，加入n=16，那么n-1=15的二进制表示就是0x0000 1111，可以看出，任何一个2的幂次减1后二进制肯定都是这种形式，它的意义在于，任何一个值和它做&amp;操作，得到的结构肯定都在0~(n-1)之间，也就是说计算出来的下标值肯定数组的合法下标。hash函数的计算过程如下图</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/java/9.png?raw=true" alt=""></p>
<h2 id="2、resize-方法"><a href="#2、resize-方法" class="headerlink" title="2、resize()方法"></a>2、resize()方法</h2><p>从上面可以看到，每次加入元素如果table数组为空或者加入之后元素个数超出阈值，都会调用调用resize()方法来进行扩容，它的意义在于使节点均匀分布尽量避免碰撞，这样才能实现较好的查找性能。</p>
<ol>
<li>先根据容量和阈值确定新的容量和阈值 </li>
<li>更新阈值和新容量的table </li>
<li>如果原来的table中元素，那么把原来的元素加入到新的table中 </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * 第一次加入元素或者size超过阈值的时候都会调用该方法初始化或者扩大table的容量 </div><div class="line"> */  </div><div class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;  </div><div class="line">    Node&lt;K,V&gt;[] oldTab = table;  </div><div class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;  </div><div class="line">    <span class="keyword">int</span> oldThr = threshold;  </div><div class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;  </div><div class="line"></div><div class="line">    <span class="comment">/* </span></div><div class="line">     * step1: 先根据容量和阈值确定新的容量和阈值 </div><div class="line">     */  </div><div class="line"></div><div class="line">    <span class="comment">//case1: 如果table已经被初始化，说明不是第一次加入元素  </span></div><div class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;              </div><div class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="comment">//如果table的容量已经达到最大值，那么就不再扩容了，碰撞也没办法  </span></div><div class="line">            threshold = Integer.MAX_VALUE;<span class="comment">//那么扩大阈值到最大值  </span></div><div class="line">            <span class="keyword">return</span> oldTab;<span class="comment">//原来的table不变  </span></div><div class="line">        &#125;  </div><div class="line"></div><div class="line">        <span class="comment">//不然的话table的容量扩大2倍，newCap = oldCap &lt;&lt; 1            大部分情况下肯定都是这种情况              </span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;  </div><div class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)  </div><div class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">//阈值也扩大2倍  </span></div><div class="line">    &#125;          </div><div class="line"></div><div class="line">    <span class="comment">//case2: table没有被初始化，但是阈值大于0，说明在构造函数中指定了容量，但是容量存在阈值那个变量上  </span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)  </div><div class="line">        newCap = oldThr;<span class="comment">//那么将阈值设置为table的容量，下面还会重新计算阈值  </span></div><div class="line"></div><div class="line">    <span class="comment">//case3: table和阈值都没有初始化，说明是无参构造函数  </span></div><div class="line">    <span class="keyword">else</span> &#123;                 </div><div class="line">        newCap = DEFAULT_INITIAL_CAPACITY;<span class="comment">//使用默认的初始容量  </span></div><div class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<span class="comment">//计算默认的阈值，threshold=load_factor*capacity  </span></div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="comment">//重新计算阈值  </span></div><div class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;  </div><div class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;  </div><div class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?  </div><div class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="comment">/* </span></div><div class="line">     * step2: 更新阈值和新容量的table </div><div class="line">     */  </div><div class="line">    threshold = newThr;  </div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)  </div><div class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];  </div><div class="line">    table = newTab;  </div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* </span></div><div class="line">     * step3: 如果原来的table中元素，那么把原来的元素加入到新的table中 </div><div class="line">     */               </div><div class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;  </div><div class="line">            Node&lt;K,V&gt; e;  <span class="comment">//e = oldTab[j]</span></div><div class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;  </div><div class="line">                oldTab[j] = <span class="keyword">null</span>;  </div><div class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)  <span class="comment">//e所在位置没有哈希冲突，只有一个元素，直接计算</span></div><div class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;  </div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)  <span class="comment">//e所在位置是一颗红黑树</span></div><div class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);  </div><div class="line">                <span class="keyword">else</span> &#123;<span class="comment">// e所在位置是一个链表，则遍历链表</span></div><div class="line">                  	<span class="comment">// 根据e.hash &amp; oldCap) == 0，确定放入lo还是hi两个链表</span></div><div class="line">                  	<span class="comment">// 其实就是判断e.hash是否大于oldCap</span></div><div class="line">                  	<span class="comment">// lo和hi两个链表放分别放在在newTab[j]和newTab[j + oldCap]</span></div><div class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;  </div><div class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;  </div><div class="line">                    Node&lt;K,V&gt; next;  </div><div class="line">                    <span class="keyword">do</span> &#123;  </div><div class="line">                        next = e.next;  </div><div class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;  </div><div class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)  </div><div class="line">                                loHead = e;  </div><div class="line">                            <span class="keyword">else</span>  </div><div class="line">                                loTail.next = e;  </div><div class="line">                            loTail = e;  </div><div class="line">                        &#125;  </div><div class="line">                        <span class="keyword">else</span> &#123;  </div><div class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)  </div><div class="line">                                hiHead = e;  </div><div class="line">                            <span class="keyword">else</span>  </div><div class="line">                                hiTail.next = e;  </div><div class="line">                            hiTail = e;  </div><div class="line">                        &#125;  </div><div class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);  </div><div class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;  </div><div class="line">                        loTail.next = <span class="keyword">null</span>;  </div><div class="line">                        newTab[j] = loHead;  </div><div class="line">                    &#125;  </div><div class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;  </div><div class="line">                        hiTail.next = <span class="keyword">null</span>;  </div><div class="line">                        newTab[j + oldCap] = hiHead;  </div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> newTab;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="三、常用方法"><a href="#三、常用方法" class="headerlink" title="三、常用方法"></a>三、常用方法</h1><p>上面介绍了两个比较复杂的方法，接下来继续分析Map中比较常见的方法和内部的实现。</p>
<h2 id="1、get-方法和containsKey-方法"><a href="#1、get-方法和containsKey-方法" class="headerlink" title="1、get()方法和containsKey()方法"></a>1、get()方法和containsKey()方法</h2><p>这两个方法是最常用的，都是根据给定的key值，一个获取对应的value，一个判断是否存在于Map中，在内部这两个方法都会调用一个finall方法，就是getNode()，也就是查找对应key值的节点。</p>
<p>getNode方法的大致过程：</p>
<ol>
<li><p>table里的第一个节点，直接命中；</p>
</li>
<li><p>如果有冲突，则遍历链表或二叉树去查找相同节点</p>
</li>
<li><p>查找节点时先判断hash值是否相等</p>
</li>
<li><p>如果hash值相等，再判断key值是否相等</p>
</li>
<li><p>判断key值相等时，用==或equals或，整个判断条件为：</p>
<blockquote>
<p>(e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</p>
</blockquote>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;  </div><div class="line">    Node&lt;K,V&gt; e;  </div><div class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">/* </span></div><div class="line"> * 实现Map.get以及相关方法 </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;  </div><div class="line">    Node&lt;K,V&gt;[] tab; <span class="comment">//指向table数组  </span></div><div class="line">    Node&lt;K,V&gt; first, e; <span class="comment">//first为table[index]，即所在数组下标中第一个节点；e用于遍历节点  </span></div><div class="line">    <span class="keyword">int</span> n; K k;<span class="comment">//n为table的长度，k用于指向节点的key  </span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;<span class="comment">//首先必须保证table数组不为空                 </span></div><div class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;<span class="comment">//计算下标，保证数组下标中第一个节点不为null不然就肯定找不到直接返回null  </span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// 先检查第一个节点hash值是否相等  </span></div><div class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))<span class="comment">//再判断key，如果相等直接返回  </span></div><div class="line">            <span class="keyword">return</span> first;  </div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123; <span class="comment">//第一个不符合，就从下一个开始找  </span></div><div class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)<span class="comment">//红黑树 O(logn)  </span></div><div class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);  </div><div class="line">            <span class="keyword">do</span> &#123;<span class="comment">//不然就是链表O(n)  </span></div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;  </div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))  </div><div class="line">                    <span class="keyword">return</span> e;  </div><div class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2、putAll-方法"><a href="#2、putAll-方法" class="headerlink" title="2、putAll()方法"></a>2、putAll()方法</h2><p>putAll方法用于将一个已有的Map加入现有的Map中，在内部也是调用一个final方法putMapEntries，这个方法也实现了最后一个构造函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;  </div><div class="line">    putMapEntries(m, <span class="keyword">true</span>);  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//用于实现Map.putAll和上面的那个构造函数  </span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;  </div><div class="line">    <span class="keyword">int</span> s = m.size();<span class="comment">//s代表要加入的元素个数  </span></div><div class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;  </div><div class="line"></div><div class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// 如果table为null，说明还没有进行初始化  </span></div><div class="line"></div><div class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;<span class="comment">//根据s计算容量和阈值  </span></div><div class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?  </div><div class="line">                     (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);  </div><div class="line">            <span class="keyword">if</span> (t &gt; threshold)  </div><div class="line">                threshold = tableSizeFor(t);  </div><div class="line">        &#125;  </div><div class="line"></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)<span class="comment">//如果超出阈值，则进行扩容  </span></div><div class="line">            resize();  </div><div class="line"></div><div class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;<span class="comment">//逐个将节点加入  </span></div><div class="line">            K key = e.getKey();  </div><div class="line">            V value = e.getValue();  </div><div class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出这大致过程就是先根据已有元素进行容量和阈值的计算，类似和初始化过程差不多，然后遍历Map，将其中元素逐个加入，加入的过程就是调用putVal，上面已经分析过。</p>
<h2 id="3、remove-方法"><a href="#3、remove-方法" class="headerlink" title="3、remove()方法"></a>3、remove()方法</h2><p>remove方法用于删除给定key值对应的节点并返回，如果不存在就返回null。在内部也是调用一个final方法 removeNode。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;  </div><div class="line">     Node&lt;K,V&gt; e;  </div><div class="line">     <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?  </div><div class="line">         <span class="keyword">null</span> : e.value;  </div><div class="line"> &#125;  </div><div class="line">   </div><div class="line"> <span class="comment">/* </span></div><div class="line">  * 实现Map.remove及相关方法 </div><div class="line">  */  </div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K, V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,   </span></span></div><div class="line">        <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable) &#123;  </div><div class="line">    Node&lt;K, V&gt;[] tab;<span class="comment">//指向table数组  </span></div><div class="line">    Node&lt;K, V&gt; p;<span class="comment">//table[index]，链表第一个元素或红黑树根节点  </span></div><div class="line">    <span class="keyword">int</span> n, index;<span class="comment">//n为table数组的长度。index为hash值对应的下标  </span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;   </div><div class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;              </div><div class="line">        Node&lt;K, V&gt; node = <span class="keyword">null</span>, e;  </div><div class="line">        K k;  </div><div class="line">        V v;  </div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))  </div><div class="line">            node = p;  </div><div class="line"></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)  </div><div class="line">                node = ((TreeNode&lt;K, V&gt;) p).getTreeNode(hash, key);  </div><div class="line">            <span class="keyword">else</span> &#123;  </div><div class="line">                <span class="keyword">do</span> &#123;  </div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;  </div><div class="line">                        node = e;  </div><div class="line">                        <span class="keyword">break</span>;  </div><div class="line">                    &#125;  </div><div class="line">                    p = e;  </div><div class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line"></div><div class="line">        <span class="comment">//上面的过程和getNode基本一样  </span></div><div class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue ||<span class="comment">//如果找到了该节点   </span></div><div class="line">            (v = node.value) == value || (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;  </div><div class="line"></div><div class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)<span class="comment">//如果是红黑树，在红黑树中删除节点  </span></div><div class="line">                ((TreeNode&lt;K, V&gt;) node).removeTreeNode(<span class="keyword">this</span>, tab, movable);  </div><div class="line"></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)<span class="comment">//如果是链表第一个节点  </span></div><div class="line">                tab[index] = node.next;<span class="comment">//直接指向next  </span></div><div class="line"></div><div class="line">            <span class="keyword">else</span><span class="comment">//  </span></div><div class="line">                p.next = node.next;<span class="comment">//  </span></div><div class="line">            ++modCount;  </div><div class="line">            --size;<span class="comment">//  </span></div><div class="line">            afterNodeRemoval(node);  </div><div class="line">            <span class="keyword">return</span> node;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">//节点不存在，返回null  </span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，remove过程和get过程有很多相同的操作，都是先找到对应的元素，remove在查找之后会进行删除操作。</p>
<h2 id="4、size-和isEmpty-方法"><a href="#4、size-和isEmpty-方法" class="headerlink" title="4、size()和isEmpty()方法"></a>4、size()和isEmpty()方法</h2><p>这两个方法很简单，一个返回元素个数，一个返回是否有元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> size;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="5、clear-方法"><a href="#5、clear-方法" class="headerlink" title="5、clear()方法"></a>5、clear()方法</h2><p>清空整个Map。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;  </div><div class="line">    Node&lt;K,V&gt;[] tab;  </div><div class="line">    modCount++;  </div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;  </div><div class="line">        size = <span class="number">0</span>;  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)  </div><div class="line">            tab[i] = <span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>size置0，直接遍历table数组，全部置为null，节点不用管，交给垃圾回收。       </p>
<p>可以看出，clear方法后，Map的容量和阈值都是不变的，只是其中的元素被清空了。</p>
<h2 id="6、containsValue-方法"><a href="#6、containsValue-方法" class="headerlink" title="6、containsValue()方法"></a>6、containsValue()方法</h2><p>这个方法虽然看上去和containsKey差不多，而且作用也确实都是判断Map中是否含有某key或某value，但是内部的实现却是完全不一样的，containsKey会调用getNode方法进行查找，而containsKey是直接遍历所有元素逐个对比的。二者查找方式与性能都有着很大的差别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;  </div><div class="line">    Node&lt;K,V&gt;[] tab; V v;  </div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;  </div><div class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;  </div><div class="line">                <span class="keyword">if</span> ((v = e.value) == value ||  </div><div class="line">                    (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))  </div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，有两层循环，是挨个查找的，所以效率并不高。</p>
<h2 id="7、JDK1-8扩展方法"><a href="#7、JDK1-8扩展方法" class="headerlink" title="7、JDK1,8扩展方法"></a>7、JDK1,8扩展方法</h2><h1 id="四、返回Set的相关方法"><a href="#四、返回Set的相关方法" class="headerlink" title="四、返回Set的相关方法"></a>四、返回Set的相关方法</h1><p>HashMap类实现了Map接口，在Map中，定义了三个views相关的方法(源码注释里就是这么写的)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Views  </span></div><div class="line"><span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;  </div><div class="line"><span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>;  </div><div class="line">Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</div></pre></td></tr></table></figure>
<p>顾名思义，这三个方法分别返回Map中的关键字集合，值集合和节点集合。在HashMap中实现了这三个方法。</p>
<h2 id="1、keySet-方法"><a href="#1、keySet-方法" class="headerlink" title="1、keySet()方法"></a>1、keySet()方法</h2><p>返回包含Map中所有key值的Set，定义了一个继承自AbstractSet的内部类，它只会被new一次，因为在new之后会有一个全局变量keySet指向它，keySet变量是父类AbstractMap中定义的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;  </div><div class="line">    Set&lt;K&gt; ks;<span class="comment">//ks=keySet  </span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> (ks = keySet) == <span class="keyword">null</span> ? (keySet = <span class="keyword">new</span> KeySet()) : ks;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator(); &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsKey(o); &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KeySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;  </div><div class="line">        Node&lt;K,V&gt;[] tab;  </div><div class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)  </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </div><div class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="keyword">int</span> mc = modCount;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;  </div><div class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)  </div><div class="line">                    action.accept(e.key);  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">if</span> (modCount != mc)  </div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，返回的keySet对象和Map是向关联的，而不是一个复制，对返回Set的操作也会对应到相应的Map节点中。下面是我测试的一个小例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">    Map&lt;Integer, String&gt; map=<span class="keyword">new</span> HashMap&lt;Integer, String&gt;();  </div><div class="line">    map.put(<span class="number">1</span>, <span class="string">"1"</span>);  </div><div class="line">    map.put(<span class="number">2</span>, <span class="string">"2"</span>);  </div><div class="line">    Set&lt;Integer&gt; keySet=map.keySet();  </div><div class="line">    System.out.println(keySet.contains(<span class="number">1</span>));<span class="comment">//true  </span></div><div class="line">    map.remove(<span class="number">1</span>);  </div><div class="line">    System.out.println(keySet.contains(<span class="number">1</span>));<span class="comment">//false  </span></div><div class="line">    keySet.remove(<span class="number">2</span>);  </div><div class="line">    System.out.println(map.size());<span class="comment">//0  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2、values-方法"><a href="#2、values-方法" class="headerlink" title="2、values()方法"></a>2、values()方法</h2><p>values方法与keySet基本类似，返回Map中包含的所有的value集合。很多操作的原理和上面都基本一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;  </div><div class="line">    Collection&lt;V&gt; vs;  </div><div class="line">    <span class="keyword">return</span> (vs = values) == <span class="keyword">null</span> ? (values = <span class="keyword">new</span> Values()) : vs;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ValueIterator(); &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsValue(o); &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;V&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ValueSpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;  </div><div class="line">        Node&lt;K,V&gt;[] tab;  </div><div class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)  </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </div><div class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="keyword">int</span> mc = modCount;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;  </div><div class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)  </div><div class="line">                    action.accept(e.value);  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">if</span> (modCount != mc)  </div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有几点不同之处：</p>
<ol>
<li>keySet返回的是Set，而values返回的是Collections，我觉得是因为Map中key是唯一的，Set也是不包含重复元素的。</li>
<li>返回的values中没有remove操作，因为Map可以对指定的key删除，却不可以对指定的value删除。</li>
</ol>
<h2 id="3、entrySet-方法"><a href="#3、entrySet-方法" class="headerlink" title="3、entrySet()方法"></a>3、entrySet()方法</h2><p>该方法返回的也是set，不过它返回的直接是键值对，其他的和上面两个也差不多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;  </div><div class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;  </div><div class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;  </div><div class="line">        Object key = e.getKey();  </div><div class="line">        Node&lt;K,V&gt; candidate = getNode(hash(key), key);  </div><div class="line">        <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;  </div><div class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;  </div><div class="line">            Object key = e.getKey();  </div><div class="line">            Object value = e.getValue();  </div><div class="line">            <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntrySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;  </div><div class="line">        Node&lt;K,V&gt;[] tab;  </div><div class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)  </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </div><div class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="keyword">int</span> mc = modCount;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;  </div><div class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)  </div><div class="line">                    action.accept(e);  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">if</span> (modCount != mc)  </div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有个区别就是entrySet是在HashMap中定义的，而不是继承自父类。在最上面第一部分代码中就列出了。</p>
<h2 id="4、Map的遍历"><a href="#4、Map的遍历" class="headerlink" title="4、Map的遍历"></a>4、Map的遍历</h2><p>关于Map的遍历，阿里的Java开发手册中同样提到【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。 </p>
<blockquote>
<p>说明： keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK8，使用 Map.foreach 方法。</p>
<p>正例： values()返回的是 V 值集合，是一个 list 集合对象； keySet()返回的是 K 值集合，是一个 Set 集合对象； entrySet()返回的是 K-V 值组合集合。 </p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java的fail-fast机制]]></title>
      <url>http://yoursite.com/2016/11/12/Java/JDK/Java%E7%9A%84fail-fast%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="一、fail-fast机制"><a href="#一、fail-fast机制" class="headerlink" title="一、fail-fast机制"></a>一、fail-fast机制</h1><p>本来准备看一下concurrentHashMap，但是发现对多线程的一些机制还不是很清楚，比如fail-fast机制，在List和HashMap中都遇到了，但是当时都是直接略过，所以在此总结一下该机制。</p>
<h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><p>“快速失败”也就是fail-fast，它是Java集合的一种错误检测机制。当多个线程对集合进行<strong>结构</strong>上的改变的操作时，有可能会产生fail-fast机制。记住是有可能，而不是一定。 </p>
<p>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（<strong>是结构上面的修改，而不是简单的修改集合元素的内容</strong>），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。 </p>
<h2 id="2、产生原因"><a href="#2、产生原因" class="headerlink" title="2、产生原因"></a>2、产生原因</h2><p>要了解fail-fast机制，我们首先要对ConcurrentModificationException 异常有所了解。当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常。同时需要注意的是，该异常不会始终指出对象已经由不同线程并发修改，如果单线程违反了规则，同样也有可能会抛出该异常。</p>
<p>诚然，迭代器的快速失败行为无法得到保证，它不能保证一定会出现该错误，但是快速失败操作会尽最大努力抛出ConcurrentModificationException异常，所以因此，为提高此类操作的正确性而编写一个依赖于此异常的程序是错误的做法，正确做法是：ConcurrentModificationException 应该仅用于检测 bug。</p>
<p>下面看一下List和HashMap中是如何实现这一机制的</p>
<h1 id="二、List中的fail-fast机制"><a href="#二、List中的fail-fast机制" class="headerlink" title="二、List中的fail-fast机制"></a>二、List中的fail-fast机制</h1><p>最常用的ArrayList和LinkedList都继承自AbstractList（LinkedList继承自AbstractSequentialList，而AbstractSequentialList继承自AbstractList）。</p>
<h2 id="1、modCount"><a href="#1、modCount" class="headerlink" title="1、modCount"></a>1、modCount</h2><p>在AbstractList中定义了变量modCount，顾名思义，它表示的就是修改次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</div></pre></td></tr></table></figure>
<p>这个变量是实现这一机制的关键，在子类中都会通过判断它来判断集合是否被修改。</p>
<h2 id="2、ArrayList中的实现"><a href="#2、ArrayList中的实现" class="headerlink" title="2、ArrayList中的实现"></a>2、ArrayList中的实现</h2><h3 id="2-1、modCount"><a href="#2-1、modCount" class="headerlink" title="2.1、modCount++"></a>2.1、modCount++</h3><p>这个变量什么时候会改变呢，直接在源码中搜索modCount++：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</div><div class="line">      modCount++;</div><div class="line">      <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">      modCount++;</div><div class="line">     <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">      rangeCheck(index);</div><div class="line">      modCount++;</div><div class="line">      <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">      <span class="keyword">return</span> oldValue;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">      modCount++;</div><div class="line">      <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">      modCount++;</div><div class="line"><span class="comment">/** 省略此处代码 */</span>  </div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</div><div class="line">      modCount++;</div><div class="line">      <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; filter)</span> </span>&#123;</div><div class="line">      <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">          modCount++;</div><div class="line">     <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;</div><div class="line">      <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">      modCount++;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</div><div class="line">      <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">      modCount++;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>以上就是修改modCount的所有操作了，可以看出，在add、remove、clear等涉及改变ArrayList元素个数的操作是，modCount都会+1。</p>
<p>注意一点，就是set方法的时候并没有改变这个值，也就是说是这个变量的修改指的是结构上面的修改，而不是简单的修改集合元素的内容。</p>
<h3 id="2-2、listIterator"><a href="#2-2、listIterator" class="headerlink" title="2.2、listIterator"></a>2.2、listIterator</h3><p>接下来就看一下什么时候回产生这个异常，ail-fast是在操作迭代器时产生的，下面看一下ArrayList的迭代器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">new</span> ListItr(<span class="number">0</span>);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">     ListItr(<span class="keyword">int</span> index) &#123;</div><div class="line">         <span class="keyword">super</span>();</div><div class="line">         cursor = index;</div><div class="line">     &#125;</div><div class="line">     <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">     <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</div><div class="line">         checkForComodification();</div><div class="line">         <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">     &#125;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">         <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">         checkForComodification();</div><div class="line">         <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">     &#125;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">         checkForComodification();</div><div class="line"><span class="comment">/** 省略此处代码 */</span>  </div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">     <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></div><div class="line">     <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></div><div class="line">     <span class="keyword">int</span> expectedModCount = modCount;</div><div class="line"></div><div class="line">     <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">     <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">         checkForComodification();</div><div class="line">         <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">     &#125;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">         <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">         checkForComodification();</div><div class="line">         <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">     &#125;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</div><div class="line">         <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">         checkForComodification();</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</div><div class="line">         <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>可以看出，迭代器在调用next、remove、add、set等方法时，都会先调用checkForComodification方法，该方法和很简单，判断modCount != expectedModCount的话就抛出异常，而expectedModCount在迭代器初始化的时候就指定了等于modCount，在迭代过程中如果有其他线程改变结构导致modCount发生变化，这里就会抛出异常。</p>
<p>有两个线程（线程A，线程B），其中线程A负责遍历list、线程B修改list。线程A在遍历list过程的某个时候（此时expectedModCount = modCount=N），线程启动，同时线程B增加一个元素，这是modCount的值发生改变（modCount + 1 = N + 1）。线程A继续遍历执行next方法时，通告checkForComodification方法发现expectedModCount  = N  ，而modCount = N + 1，两者不等，这时就抛出ConcurrentModificationException 异常，从而产生fail-fast机制。</p>
<h2 id="2、LinkedList中的实现"><a href="#2、LinkedList中的实现" class="headerlink" title="2、LinkedList中的实现"></a>2、LinkedList中的实现</h2><p>与ArrayList的实现基本一致，只是方法上上有不同，就不再贴代码了。</p>
<h2 id="3、遍历List删除元素的方法"><a href="#3、遍历List删除元素的方法" class="headerlink" title="3、遍历List删除元素的方法"></a>3、遍历List删除元素的方法</h2><p>有一道面试题就是：如何在遍历ArrayList的时候删除一个元素？</p>
<p>这个问题看似很简单，但其实暗藏玄机。比如，正常来讲用for-each直接遍历并删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">list.add(<span class="string">"a"</span>);</div><div class="line">list.add(<span class="string">"b"</span>);</div><div class="line">list.add(<span class="string">"c"</span>);</div><div class="line">list.add(<span class="string">"d"</span>);</div><div class="line"><span class="keyword">for</span>(String s: list)&#123;</div><div class="line">    <span class="keyword">if</span>(s.equals(<span class="string">"a"</span>))&#123;</div><div class="line">        list.remove(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>会直接抛出java.util.ConcurrentModificationException。因为for-each实际上使用的是List的迭代器，而在迭代过程中，删除了一个元素就相当于List的结构发生了变化，就会抛出上文所说的ConcurrentModificationException。</p>
<p>那么怎样才能正确的遍历并且删除元素呢，必须得用到Iterator的remove方法，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">list.add(<span class="string">"a"</span>);</div><div class="line">list.add(<span class="string">"b"</span>);</div><div class="line">list.add(<span class="string">"c"</span>);</div><div class="line">list.add(<span class="string">"d"</span>);</div><div class="line">Iterator&lt;String&gt; i=list.iterator();</div><div class="line"><span class="keyword">while</span>(i.hasNext())&#123;</div><div class="line">    String s=i.next();</div><div class="line">    <span class="keyword">if</span>(s.equals(<span class="string">"a"</span>))&#123;</div><div class="line">        i.remove();<span class="comment">//必须的迭代器的remove方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么为什么迭代器的remove方法就不会抛出异常呢？再来看一下源码就知道了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></div><div class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></div><div class="line">    <span class="keyword">int</span> expectedModCount = modCount;</div><div class="line"></div><div class="line">    <span class="comment">//省略</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">        checkForComodification();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ArrayList.<span class="keyword">this</span>.remove(lastRet);</div><div class="line">            cursor = lastRet;</div><div class="line">            lastRet = -<span class="number">1</span>;</div><div class="line">            expectedModCount = modCount;</div><div class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，调用remove方法之后，通过<code>expectedModCount = modCount;</code>来修改了expectedModCount 的值，这样就相当于迭代器自己遍历的时候，是可以对List的结构进行修改的。</p>
<h1 id="三、HashMap中的fail-fast机制"><a href="#三、HashMap中的fail-fast机制" class="headerlink" title="三、HashMap中的fail-fast机制"></a>三、HashMap中的fail-fast机制</h1><p>通过ArrayList的分析可以了解到fail-fast机制的原理，其实在各个类的实现中应该都是差不多的，只是细节上略有不同。</p>
<h2 id="1、modCount-1"><a href="#1、modCount-1" class="headerlink" title="1、modCount"></a>1、modCount</h2><p>HashMaP的modCount 变量是直接定义在本类中的，而不是像ArrayList一样在父类的抽象类中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</div></pre></td></tr></table></figure>
<p>还有一个比较奇葩的地方就是，在ArrayList中，modCount改变的时候都是modCount++; </p>
<p>而在HashMap中，既有modCount++; 又有++modCount; 这点不是很理解</p>
<h2 id="2、HashIterator"><a href="#2、HashIterator" class="headerlink" title="2、HashIterator"></a>2、HashIterator</h2><p>HashMap与List的另一点重要的不同在于，HashMap无法直接返回迭代器，因为它存储的是键值对，在源码分析的时候说过它可以返回三类Collection的集合，而这些集合才可以产生迭代器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Views  </span></div><div class="line"><span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;  </div><div class="line"><span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>;  </div><div class="line">Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</div></pre></td></tr></table></figure>
<p>再看看他们如何返回迭代器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</div><div class="line">    Set&lt;K&gt; ks;</div><div class="line">    <span class="keyword">return</span> (ks = keySet) == <span class="keyword">null</span> ? (keySet = <span class="keyword">new</span> KeySet()) : ks;</div><div class="line">&#125;</div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator(); &#125;</div><div class="line">    <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</div><div class="line">    Collection&lt;V&gt; vs;</div><div class="line">    <span class="keyword">return</span> (vs = values) == <span class="keyword">null</span> ? (values = <span class="keyword">new</span> Values()) : vs;</div><div class="line">&#125;</div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ValueIterator(); &#125;</div><div class="line">    <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</div><div class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</div><div class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</div><div class="line">&#125;</div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</div><div class="line">    <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();<span class="comment">//为什么这里要另起一行！！！！！！！！！！！！！！！</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，三个方法返回的迭代分别是新建的一个KeyIterator、ValueIterator、EntryIterator。</p>
<p>那么再来看一下这三个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">   </div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></div><div class="line">       <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; &#123;</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().key; &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></div><div class="line">       <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">V</span>&gt; &#123;</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().value; &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></div><div class="line">       <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; &#123;</div><div class="line">       <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>又都同时继承同一个父类HashIterator，只是对自己相关的方法进行了重写，那么再看这个最终的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></div><div class="line">    Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></div><div class="line">    <span class="keyword">int</span> expectedModCount;  <span class="comment">// for fast-fail</span></div><div class="line">    <span class="keyword">int</span> index;             <span class="comment">// current slot</span></div><div class="line"></div><div class="line">    HashIterator() &#123;</div><div class="line">        expectedModCount = modCount;</div><div class="line">        <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个就和上面的ArrayList很像了，在最开始的时候指定expectedModCount，并且每次nextNode和remove的时候检查，如果modCount != expectedModCount不相等则抛出异常。</p>
<h2 id="3、-modCount"><a href="#3、-modCount" class="headerlink" title="3、++modCount"></a>3、++modCount</h2><p>接下来也看一下map中的哪些操作会导致modCount值的改变</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line">               <span class="keyword">boolean</span> evict) &#123;</div><div class="line">    <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">    ++modCount;</div><div class="line">    <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></div><div class="line">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable) &#123;</div><div class="line">    <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">            ++modCount;</div><div class="line">   <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">computeIfAbsent</span><span class="params">(K key,</span></span></div><div class="line">                         Function&lt;? <span class="keyword">super</span> K, ? extends V&gt; mappingFunction) &#123;</div><div class="line">    <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">    ++modCount;</div><div class="line">    <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(K key,</span></span></div><div class="line">                 BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction) &#123;</div><div class="line">    <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">        ++modCount;</div><div class="line">    <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">merge</span><span class="params">(K key, V value,</span></span></div><div class="line">               BiFunction&lt;? <span class="keyword">super</span> V, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction) &#123;</div><div class="line">    <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">        ++modCount;</div><div class="line">        ++size;</div><div class="line">    <span class="comment">/** 省略此处代码 */</span>  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有一个就是下面这个，我这强迫症真是没法忍了，上面的三个迭代器风格不一样也就算了，连个自加操作都没法统一</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] tab;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</div><div class="line">        size = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</div><div class="line">            tab[i] = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，HashMap也是新加或者删除结点等对结构有改变的操作时modCount发生改变。</p>
<h1 id="四、解决方案"><a href="#四、解决方案" class="headerlink" title="四、解决方案"></a>四、解决方案</h1><p>怎样避免产生这个异常，要么就是直接涉及多线程的直接加锁串行执行，但是这样的话会严重影响效率，在Java并发编程实战这本书中，有一节叫做并发容器，介绍了专门为多线程并发访问设计的容器。</p>
<h2 id="1、CopyOnWriteArrayList"><a href="#1、CopyOnWriteArrayList" class="headerlink" title="1、CopyOnWriteArrayList"></a>1、CopyOnWriteArrayList</h2><p>ArrayList 的一个线程安全的变体，其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的。</p>
<p>它的线程安全性在于，只要正确的发布一个事实不可变的对象，那么在访问该对象的时候就不需要再进一步的同步。在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性。</p>
<p>CopyOnWriterArrayList不会产生ConcurrentModificationException异常，并且返回的元素与迭代器创建时的元素完全一致，而不必考虑之后修改操作带来的影响。</p>
<p>由于每次修改容器都会复制底层数组，需要很大的开销，特别是容器规模很大的时候。所以，只有当迭代操作远远多于修改操作的时候，才使用这个容器。</p>
<h2 id="2、concurrentHashMap"><a href="#2、concurrentHashMap" class="headerlink" title="2、concurrentHashMap"></a>2、concurrentHashMap</h2><p>就是下面要分析到的concurrentHashMap</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PriorityQueue源码分析]]></title>
      <url>http://yoursite.com/2016/11/12/Java/JDK/PriorityQueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>Priorityqueue是Java7后加入的优先级队列，继承自AbstractQueue，而AbstractQueue，实现了Queue接口，也就是说Priorityqueue是实现了Queue接口的，带有优先级的队列。</p>
<p>内部实现上采用的是最小堆，即每次取出优先级最小的元素。相对来说实现上比较简单，下面简单分析一下。</p>
<h1 id="一、基本属性与构造函数"><a href="#一、基本属性与构造函数" class="headerlink" title="一、基本属性与构造函数"></a>一、基本属性与构造函数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7720805057305804111L</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</div><div class="line">  </div><div class="line">    <span class="keyword">transient</span> Object[] queue; <span class="comment">// non-private to simplify nested class access</span></div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line">  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</div><div class="line">   </div><div class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>; <span class="comment">// non-private to simplify nested class access</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>&#123;<span class="comment">//1</span></div><div class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;<span class="comment">//2</span></div><div class="line">        <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;<span class="comment">//3</span></div><div class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></div><div class="line">                         Comparator&lt;? <span class="keyword">super</span> E&gt; comparator) &#123;<span class="comment">//4</span></div><div class="line">        <span class="comment">// Note: This restriction of at least one is not actually needed,</span></div><div class="line">        <span class="comment">// but continues for 1.5 compatibility</span></div><div class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</div><div class="line">        <span class="keyword">this</span>.comparator = comparator;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<span class="comment">//5</span></div><div class="line">        <span class="keyword">if</span> (c <span class="keyword">instanceof</span> SortedSet&lt;?&gt;) &#123;</div><div class="line">            SortedSet&lt;? extends E&gt; ss = (SortedSet&lt;? extends E&gt;) c;</div><div class="line">            <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) ss.comparator();</div><div class="line">            initElementsFromCollection(ss);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c <span class="keyword">instanceof</span> PriorityQueue&lt;?&gt;) &#123;</div><div class="line">            PriorityQueue&lt;? extends E&gt; pq = (PriorityQueue&lt;? extends E&gt;) c;</div><div class="line">            <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) pq.comparator();</div><div class="line">            initFromPriorityQueue(pq);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">this</span>.comparator = <span class="keyword">null</span>;</div><div class="line">            initFromCollection(c);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(PriorityQueue&lt;? extends E&gt; c)</span> </span>&#123;<span class="comment">//6</span></div><div class="line">        <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) c.comparator();</div><div class="line">        initFromPriorityQueue(c);</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(SortedSet&lt;? extends E&gt; c)</span> </span>&#123;<span class="comment">//7</span></div><div class="line">        <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) c.comparator();</div><div class="line">        initElementsFromCollection(c);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFromPriorityQueue</span><span class="params">(PriorityQueue&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (c.getClass() == PriorityQueue.class) &#123;</div><div class="line">            <span class="keyword">this</span>.queue = c.toArray();</div><div class="line">            <span class="keyword">this</span>.size = c.size();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            initFromCollection(c);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initElementsFromCollection</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">        Object[] a = c.toArray();</div><div class="line">        <span class="comment">// If c.toArray incorrectly doesn't return Object[], copy it.</span></div><div class="line">        <span class="keyword">if</span> (a.getClass() != Object[].class)</div><div class="line">            a = Arrays.copyOf(a, a.length, Object[].class);</div><div class="line">        <span class="keyword">int</span> len = a.length;</div><div class="line">        <span class="keyword">if</span> (len == <span class="number">1</span> || <span class="keyword">this</span>.comparator != <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</div><div class="line">                <span class="keyword">if</span> (a[i] == <span class="keyword">null</span>)</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        <span class="keyword">this</span>.queue = a;</div><div class="line">        <span class="keyword">this</span>.size = a.length;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFromCollection</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">        initElementsFromCollection(c);</div><div class="line">        heapify();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="1、私有属性"><a href="#1、私有属性" class="headerlink" title="1、私有属性"></a>1、私有属性</h2><ul>
<li>DEFAULT_INITIAL_CAPACITY：静态常量，也就是默认的初始化容量,11  </li>
<li>transient Object[] queue：存储元素的数组，Object类型的    </li>
<li>private int size：表示元素数量  </li>
<li>comparator：比较器，用于优先级的比较，默认情况下是最小堆   </li>
<li>transient int modCount：修改的次数，用于fast-fail</li>
</ul>
<h2 id="2、构造函数"><a href="#2、构造函数" class="headerlink" title="2、构造函数"></a>2、构造函数</h2><ol>
<li>前三个构造器实际上都是调用第四个构造器，即制定初始化容量与比较器，而构造器4也很简单，就是根据给定的初始容量和构造器初始化数组和绑定比较器</li>
<li>后面的三个构造器用于指定一个已有的集合初始化，根据输入类型的不同，分为以下几种：<ul>
<li>Collection：再继续判断：<ul>
<li>如果有序的如下面的PriorityQueue或者SortedSet，执行下面对应的方法</li>
<li>如果是无序的，则比较器为null，调用initFromCollection方法</li>
</ul>
</li>
<li>PriorityQueue： 绑定原有的比较器，然后调用initFromPriorityQueue方法</li>
<li>SortedSet：绑定原有的比较器，然后调用initElementsFromCollection方法</li>
</ul>
</li>
</ol>
<h2 id="3、三个init相关的方法"><a href="#3、三个init相关的方法" class="headerlink" title="3、三个init相关的方法"></a>3、三个init相关的方法</h2><p>上面根据指定集合类型的不同，调用了不同的初始化方法：    </p>
<ul>
<li><p>initElementsFromCollection：这个方法的作用就是将原有集合的数组复制过来，因此适用于SortedSet，因为SortedSet中的元素已经有序了</p>
</li>
<li><p>initFromCollection：这个方法适用于指定集合无序的情况，先调用上面的initElementsFromCollection复制数组，然后再调用heapify方法调整。</p>
</li>
<li><p>initFromPriorityQueue：确定指定集合是PriorityQueue，说明原数组已经有序，则直接指定Object数组与size到原PriorityQueue上。如果不是PriorityQueue，则调用下面的initFromCollection</p>
<p><strong>与上面两个不同的是，这个方法并没有复制数组而只是单纯的指针指向。</strong> </p>
</li>
</ul>
<h1 id="二、关键方法"><a href="#二、关键方法" class="headerlink" title="二、关键方法"></a>二、关键方法</h1><h2 id="1、扩容"><a href="#1、扩容" class="headerlink" title="1、扩容"></a>1、扩容</h2><p>当容量不够是时候，Object数组就需要扩容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> oldCapacity = queue.length;</div><div class="line">    <span class="comment">// Double size if small; else grow by 50%</span></div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?</div><div class="line">                                     (oldCapacity + <span class="number">2</span>) :</div><div class="line">                                     (oldCapacity &gt;&gt; <span class="number">1</span>));</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">        newCapacity = hugeCapacity(minCapacity);</div><div class="line">    queue = Arrays.copyOf(queue, newCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</div><div class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</div><div class="line">        Integer.MAX_VALUE :</div><div class="line">        MAX_ARRAY_SIZE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>扩容的原则注释写的很明白，如果数组小，就扩大一倍，不然就扩大一半</p>
<h2 id="2、add与offer方法"><a href="#2、add与offer方法" class="headerlink" title="2、add与offer方法"></a>2、add与offer方法</h2><p>向队列中增加一个元素，可以调用add或者offer方法，其实在实现上都是一样的，都是调用了offer方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> offer(e);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">int</span> i = size;</div><div class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</div><div class="line">        grow(i + <span class="number">1</span>);</div><div class="line">    size = i + <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</div><div class="line">        queue[<span class="number">0</span>] = e;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        siftUp(i, e);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取当前数组大小，如果不够了就扩容，然后再i位置放入元素，调用siftUp方法来维护堆的性质</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</div><div class="line">        siftUpUsingComparator(k, x);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        siftUpComparable(k, x);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</div><div class="line">    Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;) x;</div><div class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">        Object e = queue[parent];</div><div class="line">        <span class="keyword">if</span> (key.compareTo((E) e) &gt;= <span class="number">0</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        queue[k] = e;</div><div class="line">        k = parent;</div><div class="line">    &#125;</div><div class="line">    queue[k] = key;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>迭代的方式，不断上滤</p>
<h2 id="3、poll与heapify方法"><a href="#3、poll与heapify方法" class="headerlink" title="3、poll与heapify方法"></a>3、poll与heapify方法</h2><p>对offer对应的就是poll方法了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">int</span> s = --size;</div><div class="line">    modCount++;</div><div class="line">    E result = (E) queue[<span class="number">0</span>];</div><div class="line">    E x = (E) queue[s];</div><div class="line">    queue[s] = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</div><div class="line">        siftDown(<span class="number">0</span>, x);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>逻辑也很简单，返回数组第一个元素，然后把最后一个元素放到第一个上，然后调用siftDown方法下滤</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</div><div class="line">        siftDownUsingComparator(k, x);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        siftDownComparable(k, x);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</div><div class="line">    Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;)x;</div><div class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;        <span class="comment">// loop while a non-leaf</span></div><div class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</div><div class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></div><div class="line">        Object c = queue[child];</div><div class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</div><div class="line">            ((Comparable&lt;? <span class="keyword">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="number">0</span>)</div><div class="line">            c = queue[child = right];</div><div class="line">        <span class="keyword">if</span> (key.compareTo((E) c) &lt;= <span class="number">0</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        queue[k] = c;</div><div class="line">        k = child;</div><div class="line">    &#125;</div><div class="line">    queue[k] = key;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前面还有一个heapify，可以发现这就是一个完整的筛选法建堆的过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</div><div class="line">        siftDown(i, (E) queue[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4、remove方法"><a href="#4、remove方法" class="headerlink" title="4、remove方法"></a>4、remove方法</h2><p>删除是把最后一个元素放到指定位置，然后执行上滤或者下滤，两者只会执行其中的一个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = indexOf(o);</div><div class="line">    <span class="keyword">if</span> (i == -<span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        removeAt(i);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert i &gt;= 0 &amp;&amp; i &lt; size;</span></div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">int</span> s = --size;</div><div class="line">    <span class="keyword">if</span> (s == i) <span class="comment">// removed last element</span></div><div class="line">        queue[i] = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        E moved = (E) queue[s];</div><div class="line">        queue[s] = <span class="keyword">null</span>;</div><div class="line">        siftDown(i, moved);</div><div class="line">        <span class="keyword">if</span> (queue[i] == moved) &#123;</div><div class="line">            siftUp(i, moved);</div><div class="line">            <span class="keyword">if</span> (queue[i] != moved)</div><div class="line">                <span class="keyword">return</span> moved;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="5、其他方法"><a href="#5、其他方法" class="headerlink" title="5、其他方法"></a>5、其他方法</h2><p>其他的方法比如clear、size、contains等实现都与ArrayList相类似就不一一介绍，PriorityQueue的核心就是其内部实现的堆，以及堆性质的维护，包括下滤与筛选法建堆，迭代法上滤，还有删除的时候选择上滤或者下滤中的一种。另外就是比较器，默认情况下是一个最小堆，如果需要实现最大堆或者持有其他类型的元素，则需要在构造函数中输入一个自定义的Comparator。</p>
<h1 id="三、参考地址"><a href="#三、参考地址" class="headerlink" title="三、参考地址"></a>三、参考地址</h1><p><a href="http://blog.csdn.net/hxpjava1/article/details/21478323" target="_blank" rel="external">http://blog.csdn.net/hxpjava1/article/details/21478323</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ConcurrentHashMap源码分析]]></title>
      <url>http://yoursite.com/2016/11/12/Java/JDK/ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>本文的分析的源码是JDK8的版本，与JDK6的版本有很大的差异。实现线程安全的思想也已经完全变了，它摒弃了Segment（锁段）的概念，而是启用了一种全新的方式实现，利用CAS算法。它沿用了与它同时期的HashMap版本的思想，底层依然由“数组”+链表+红黑树的方式思想，但是为了做到并发，又增加了很多辅助的类，例如TreeBin，Traverser等对象内部类。</p>
<p>与同是线程安全的老大哥HashTable相比，它已经更胜一筹，因此它的锁更加细化，而不是像HashTable一样为几乎每个方法都添加了synchronized锁，这样的锁无疑会影响到性能。</p>
<h1 id="一、基本参数与构造函数"><a href="#一、基本参数与构造函数" class="headerlink" title="一、基本参数与构造函数"></a>一、基本参数与构造函数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></div><div class="line">    <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span> &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7249069246763182397L</span>;</div><div class="line">    <span class="comment">/* ---------------- Constants -------------- */</span></div><div class="line">  	</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最开始的Constants定义了一些类变量，意思基本与HashMap中的一样，就不具体看了。</p>
<h2 id="1、内部类"><a href="#1、内部类" class="headerlink" title="1、内部类"></a>1、内部类</h2><h3 id="1-1、Node类"><a href="#1-1、Node类" class="headerlink" title="1.1、Node类"></a>1.1、Node类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* ---------------- Nodes -------------- */</span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</div><div class="line">    <span class="keyword">final</span> K key;</div><div class="line">    <span class="keyword">volatile</span> V val;<span class="comment">//带有同步锁的value</span></div><div class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;<span class="comment">//带有同步锁的next指针  </span></div><div class="line"></div><div class="line">    Node(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</div><div class="line">        <span class="keyword">this</span>.hash = hash;</div><div class="line">        <span class="keyword">this</span>.key = key;</div><div class="line">        <span class="keyword">this</span>.val = val;</div><div class="line">        <span class="keyword">this</span>.next = next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>       </span>&#123; <span class="keyword">return</span> key; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> val; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> key.hashCode() ^ val.hashCode(); &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + val; &#125;</div><div class="line">  	<span class="comment">//不允许直接改变value的值  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        Object k, v, u; Map.Entry&lt;?,?&gt; e;</div><div class="line">        <span class="keyword">return</span> ((o <span class="keyword">instanceof</span> Map.Entry) &amp;&amp;</div><div class="line">                (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">                (v = e.getValue()) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">                (k == key || k.equals(key)) &amp;&amp;</div><div class="line">                (v == (u = val) || v.equals(u)));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Virtualized support for map.get(); overridden in subclasses.</div><div class="line">     */</div><div class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt; e = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                K ek;</div><div class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</div><div class="line">                    ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</div><div class="line">                    <span class="keyword">return</span> e;</div><div class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Node类是最核心的类，用于存储键值对，和HashMap中的定义也很相似，但是有几点不同：</p>
<ol>
<li>对value和next属性设置了volatile同步锁。</li>
<li>不允许setValue方法直接改变value属性。</li>
<li>增加find方法来辅助map.get方法。</li>
</ol>
<h3 id="1-2、TreeNode类"><a href="#1-2、TreeNode类" class="headerlink" title="1.2、TreeNode类"></a>1.2、TreeNode类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></div><div class="line">    TreeNode&lt;K,V&gt; left;</div><div class="line">    TreeNode&lt;K,V&gt; right;</div><div class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></div><div class="line">    <span class="keyword">boolean</span> red;</div><div class="line"></div><div class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next,</div><div class="line">             TreeNode&lt;K,V&gt; parent) &#123;</div><div class="line">        <span class="keyword">super</span>(hash, key, val, next);</div><div class="line">        <span class="keyword">this</span>.parent = parent;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> findTreeNode(h, k, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the TreeNode (or null if not found) for the given key</div><div class="line">     * starting at given root.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">findTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</div><div class="line">       </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>树节点类，另外一个核心的数据结构。当链表长度过长的时候，会转换为TreeNode。但是与HashMap不相同的是，它并不是直接转换为红黑树，而是把这些结点包装成TreeNode放在TreeBin对象中，由TreeBin完成对红黑树的包装。而且TreeNode在ConcurrentHashMap继承自Node类，而并非HashMap中的集成自LinkedHashMap.Entry<k,v>类，也就是说TreeNode带有next指针，这样做的目的是方便基于TreeBin的访问。</k,v></p>
<h3 id="1-3、TreeBin类"><a href="#1-3、TreeBin类" class="headerlink" title="1.3、TreeBin类"></a>1.3、TreeBin类</h3><p>这个类并不负责包装用户的key、value信息，而是包装的很多TreeNode节点。它代替了TreeNode的根节点，也就是说在实际的ConcurrentHashMap“数组”中，存放的是TreeBin对象，而不是TreeNode对象，这是与HashMap的区别。另外这个类还带有了读写锁。</p>
<p>这里仅贴出它的构造方法。可以看到在构造TreeBin节点时，仅仅指定了它的hash值为TREEBIN常量，这也就是个标识为。同时也看到我们熟悉的红黑树构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">TreeBin(TreeNode&lt;K,V&gt; b) &#123;</div><div class="line">          <span class="keyword">super</span>(TREEBIN, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">          <span class="keyword">this</span>.first = b;</div><div class="line">          TreeNode&lt;K,V&gt; r = <span class="keyword">null</span>;</div><div class="line">          <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = b, next; x != <span class="keyword">null</span>; x = next) &#123;</div><div class="line">              next = (TreeNode&lt;K,V&gt;)x.next;</div><div class="line">              x.left = x.right = <span class="keyword">null</span>;</div><div class="line">              <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</div><div class="line">                  x.parent = <span class="keyword">null</span>;</div><div class="line">                  x.red = <span class="keyword">false</span>;</div><div class="line">                  r = x;</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">else</span> &#123;</div><div class="line">                  K k = x.key;</div><div class="line">                  <span class="keyword">int</span> h = x.hash;</div><div class="line">                  Class&lt;?&gt; kc = <span class="keyword">null</span>;</div><div class="line">                  <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = r;;) &#123;</div><div class="line">                      <span class="keyword">int</span> dir, ph;</div><div class="line">                      K pk = p.key;</div><div class="line">                      <span class="keyword">if</span> ((ph = p.hash) &gt; h)</div><div class="line">                          dir = -<span class="number">1</span>;</div><div class="line">                      <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</div><div class="line">                          dir = <span class="number">1</span>;</div><div class="line">                      <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</div><div class="line">                                (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</div><div class="line">                               (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</div><div class="line">                          dir = tieBreakOrder(k, pk);</div><div class="line">                          TreeNode&lt;K,V&gt; xp = p;</div><div class="line">                      <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</div><div class="line">                          x.parent = xp;</div><div class="line">                          <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</div><div class="line">                              xp.left = x;</div><div class="line">                          <span class="keyword">else</span></div><div class="line">                              xp.right = x;</div><div class="line">                          r = balanceInsertion(r, x);</div><div class="line">                          <span class="keyword">break</span>;</div><div class="line">                      &#125;</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">this</span>.root = r;</div><div class="line">          <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<h3 id="1-4、ForwardingNode"><a href="#1-4、ForwardingNode" class="headerlink" title="1.4、ForwardingNode"></a>1.4、ForwardingNode</h3><p>一个用于连接两个table的节点类。它包含一个nextTable指针，用于指向下一张表。而且这个节点的key value next指针全部为null，它的hash值为-1. 这里面定义的find的方法是从nextTable里进行查询节点，而不是以自身为头节点进行查找</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</div><div class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</div><div class="line">        <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">        <span class="keyword">this</span>.nextTable = tab;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</div><div class="line">        <span class="comment">// loop to avoid arbitrarily deep recursion on forwarding nodes</span></div><div class="line">        outer: <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = nextTable;;) &#123;</div><div class="line">            Node&lt;K,V&gt; e; <span class="keyword">int</span> n;</div><div class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span> || tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</div><div class="line">                (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) == <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">int</span> eh; K ek;</div><div class="line">                <span class="keyword">if</span> ((eh = e.hash) == h &amp;&amp;</div><div class="line">                    ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</div><div class="line">                    <span class="keyword">return</span> e;</div><div class="line">                <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ForwardingNode) &#123;</div><div class="line">                        tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;</div><div class="line">                        <span class="keyword">continue</span> outer;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        <span class="keyword">return</span> e.find(h, k);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2、重要属性"><a href="#2、重要属性" class="headerlink" title="2、重要属性"></a>2、重要属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">/* ---------------- Fields -------------- */</span></div><div class="line"><span class="comment">//与HashMap中一样，只是加了volatile</span></div><div class="line">   <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</div><div class="line"></div><div class="line"><span class="comment">//一个过渡的table表  只有在扩容的时候才会使用 </span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</div><div class="line"></div><div class="line"><span class="comment">//base counter，经由CAS来update  </span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</div><div class="line"></div><div class="line"><span class="comment">//hash表初始化或扩容时的一个控制位标识量</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</div><div class="line"></div><div class="line">   <span class="comment">// views</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> KeySetView&lt;K,V&gt; keySet;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> ValuesView&lt;K,V&gt; values;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> EntrySetView&lt;K,V&gt; entrySet;</div></pre></td></tr></table></figure>
<p>可以看出，基本所有的变量都被设置成volatile属性，</p>
<h3 id="2-1、baseCount"><a href="#2-1、baseCount" class="headerlink" title="2.1、baseCount"></a>2.1、baseCount</h3><p>用来记录map中的元素个数，但是返回的时候不会直接返回它，而是一个估计值，下面会详细介绍。</p>
<h3 id="2-2、sizeCtl"><a href="#2-2、sizeCtl" class="headerlink" title="2.2、sizeCtl"></a>2.2、sizeCtl</h3><p>sizeCtl是ConcurrentHashMap中出镜率很高的一个属性，是一个控制标识符，在不同的地方有不同的用途，不同的取值代表了不同的含义：</p>
<ul>
<li>负数代表正在进行初始化或扩容操作</li>
<li>-1代表正在初始化</li>
<li>-N 表示有N-1个线程正在进行扩容操作</li>
<li>正数或0代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小，这一点类似于扩容阈值的概念。还后面可以看到，它的值始终是当前ConcurrentHashMap容量的0.75倍，这与loadfactor是对应的。</li>
</ul>
<h2 id="3、构造函数"><a href="#3、构造函数" class="headerlink" title="3、构造函数"></a>3、构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* ---------------- Public operations -------------- */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</div><div class="line">               MAXIMUM_CAPACITY :</div><div class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</div><div class="line">    <span class="keyword">this</span>.sizeCtl = cap;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</div><div class="line">    putAll(m);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></div><div class="line">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel) &#123;</div><div class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></div><div class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></div><div class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</div><div class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</div><div class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</div><div class="line">    <span class="keyword">this</span>.sizeCtl = cap;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与HashMap一样，前面几个都是指定了属性，并不会初始化数组。</p>
<h2 id="4、三个核心方法"><a href="#4、三个核心方法" class="headerlink" title="4、三个核心方法"></a>4、三个核心方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* ---------------- Table element access -------------- */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></div><div class="line">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;</div><div class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</div><div class="line">    U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ConcurrentHashMap定义了三个原子操作，用于对指定位置的节点进行操作。正是这些原子操作保证了ConcurrentHashMap的线程安全。</p>
<h3 id="4-1、tabAt"><a href="#4-1、tabAt" class="headerlink" title="4.1、tabAt"></a>4.1、tabAt</h3><p>获得在i位置上的Node节点  </p>
<h3 id="4-2、casTabAt"><a href="#4-2、casTabAt" class="headerlink" title="4.2、casTabAt"></a>4.2、casTabAt</h3><p>利用CAS算法设置i位置上的Node节点。之所以能实现并发是因为他指定了原来这个节点的值是多少  </p>
<p>在CAS算法中，会比较内存中的值与你指定的这个值是否相等，如果相等才接受你的修改，否则拒绝你的修改  </p>
<p>因此当前线程中的值并不是最新的值，这种修改可能会覆盖掉其他线程的修改结果，后面会详细分析</p>
<h3 id="4-3、setTabAt"><a href="#4-3、setTabAt" class="headerlink" title="4.3、setTabAt"></a>4.3、setTabAt</h3><p>利用volatile方法设置节点位置的值  </p>
<h1 id="二、Table数组的初始化与扩容"><a href="#二、Table数组的初始化与扩容" class="headerlink" title="二、Table数组的初始化与扩容"></a>二、Table数组的初始化与扩容</h1><p>关于table数组初始化与扩容的关键方法</p>
<h2 id="1、初始化方法initTable"><a href="#1、初始化方法initTable" class="headerlink" title="1、初始化方法initTable"></a>1、初始化方法initTable</h2><p>对于ConcurrentHashMap来说，调用它的构造方法仅仅是设置了一些参数而已。而整个table的初始化是在向ConcurrentHashMap中插入元素的时候发生的。如调用put、computeIfAbsent、compute、merge等方法的时候，调用时机是检查table==null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">   </div><div class="line"><span class="comment">/* ---------------- Table Initialization and Resizing -------------- */</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">    * Initializes table, using the size recorded in sizeCtl.</div><div class="line">    */</div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</div><div class="line">       Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</div><div class="line">       <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</div><div class="line">         	<span class="comment">//sizeCtl&lt;0表示有其他线程正在进行初始化，把线程挂起。对于table的初始化工作，只能有一个线程在进行。  </span></div><div class="line">           <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</div><div class="line">               Thread.yield(); <span class="comment">// lost initialization race; just spin</span></div><div class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;<span class="comment">//利用CAS方法把sizectl的值置为-1 表示本线程正在进行初始化</span></div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</div><div class="line">                       <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</div><div class="line">                       <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">                       Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</div><div class="line">                       table = tab = nt;</div><div class="line">                       sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);<span class="comment">//相当于0.75*n 设置一个扩容的阈值  </span></div><div class="line">                   &#125;</div><div class="line">               &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                   sizeCtl = sc;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> tab;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>初始化方法主要应用了关键属性sizeCtl 如果这个值〈0，表示其他线程正在进行初始化，就放弃这个操作。在这也可以看出ConcurrentHashMap的初始化只能由一个线程完成。如果获得了初始化权限，就用CAS方法将sizeCtl置为-1，防止其他线程进入。初始化数组后，将sizeCtl的值改为0.75*n</p>
<h2 id="2、扩容方法-transfer"><a href="#2、扩容方法-transfer" class="headerlink" title="2、扩容方法 transfer"></a>2、扩容方法 transfer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = tab.length, stride;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * step1 计算每核处理的量stride,如果小于16，则强制赋值16</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</div><div class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line">     * step2 如果nextTable为空</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            <span class="comment">//构造一个nextTable对象 它的容量是原来的两倍  </span></div><div class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</div><div class="line">            nextTab = nt;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></div><div class="line">            sizeCtl = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        nextTable = nextTab;</div><div class="line">        <span class="comment">//复制开始的位置</span></div><div class="line">        transferIndex = n;</div><div class="line">    &#125;        </div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">int</span> nextn = nextTab.length;</div><div class="line">    <span class="comment">//构造一个连节点指针 用于标志位，fwd结点的hash值为-1，fwd.nextTable=nextTab  </span></div><div class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</div><div class="line">    <span class="comment">//并发扩容的关键属性,等于true,说明此节点已经处理过</span></div><div class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</div><div class="line">    <span class="comment">//循环的关键变量，判断是否已经扩容完成，完成就return，退出循环</span></div><div class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line">     * step3 死循环遍历，直到finishing。</div><div class="line">     */</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;<span class="comment">// 死循环</span></div><div class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</div><div class="line">        </div><div class="line">        </div><div class="line">        <span class="comment">// 控制--i，遍历原hash表中的节点</span></div><div class="line">        <span class="keyword">while</span> (advance) &#123;</div><div class="line">            <span class="keyword">int</span> nextIndex, nextBound;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</div><div class="line">                advance = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</div><div class="line">                i = -<span class="number">1</span>;</div><div class="line">                advance = <span class="keyword">false</span>;</div><div class="line">            &#125;<span class="comment">//TRANSFERINDEX 即用CAS计算得到的transferIndex</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</div><div class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</div><div class="line">                      nextBound = (nextIndex &gt; stride ?</div><div class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</div><div class="line">                bound = nextBound;</div><div class="line">                i = nextIndex - <span class="number">1</span>;</div><div class="line">                advance = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        </div><div class="line">        </div><div class="line">        <span class="comment">/*</span></div><div class="line">         * i&lt;0说明已经遍历完旧的数组tab；</div><div class="line">         * i&gt;=n什么时候有可能呢？在下面看到i=n,所以目前i最大应该是n吧。</div><div class="line">         * i+n&gt;=nextn,nextn=nextTab.length，所以如果满足i+n&gt;=nextn说明已经扩容完成</div><div class="line">         */              </div><div class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</div><div class="line">            <span class="keyword">int</span> sc;</div><div class="line">            <span class="comment">//如果所有的节点都已经完成复制工作  就把nextTable赋值给table 清空临时对象nextTable  </span></div><div class="line">            <span class="keyword">if</span> (finishing) &#123;</div><div class="line">                nextTable = <span class="keyword">null</span>;</div><div class="line">                table = nextTab;</div><div class="line">                <span class="comment">//扩容阈值设置为原来容量的1.5倍  依然相当于现在容量的0.75倍  </span></div><div class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//利用CAS方法更新这个扩容阈值，在这里面sizectl值减一，说明新加入一个线程参与到扩容操作  </span></div><div class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</div><div class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                <span class="comment">//finishing和advance保证线程已经扩容完成了可以退出循环</span></div><div class="line">                finishing = advance = <span class="keyword">true</span>;</div><div class="line">                i = n; <span class="comment">// recheck before commit</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">/*</span></div><div class="line">         * f = tabAt(tab, i),对f进行判断</div><div class="line">         */            </div><div class="line">        </div><div class="line">        <span class="comment">//如果tab[i]为null，那么就把fwd插入到tab[i]，表明这个节点已经处理过了</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</div><div class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</div><div class="line">        </div><div class="line">        <span class="comment">//那么如果f.hash=-1的话说明该节点为ForwardingNode，说明该节点已经处理过了</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</div><div class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></div><div class="line">        </div><div class="line">        </div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">        	<span class="comment">//对f结点上锁，只有本线程处理该结点对于的链表，处理后插入插入ForwardingNode结点表明已经处理过了</span></div><div class="line">            <span class="keyword">synchronized</span> (f) &#123;</div><div class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</div><div class="line">                	<span class="comment">//两个关键变量，ln原位置节点，hn新位置节点</span></div><div class="line">                    Node&lt;K,V&gt; ln, hn;</div><div class="line">                    </div><div class="line">                    <span class="comment">//fh = f.hash，&gt;=0说明为链表结点</span></div><div class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</div><div class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</div><div class="line">                        Node&lt;K,V&gt; lastRun = f;</div><div class="line">                        <span class="comment">/*</span></div><div class="line">                         * 这边还对链表进行遍历,将其拆分为两个链表</div><div class="line">                         * 根据结点的hash&amp;n等于0和不等于0的进行拆分</div><div class="line">                         * 拆分分两个链表分别放在新表中的i和i+n中</div><div class="line">                         * </div><div class="line">                         * 因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此链表根据高位为0或者1分为两个子链表</div><div class="line">                         * 高位为0的节点桶位置没有发生变化，高位为1的节点桶位置增加了n</div><div class="line">                         */                            </div><div class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</div><div class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</div><div class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</div><div class="line">                                runBit = b;</div><div class="line">                                lastRun = p;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</div><div class="line">                            ln = lastRun;</div><div class="line">                            hn = <span class="keyword">null</span>;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">else</span> &#123;</div><div class="line">                            hn = lastRun;</div><div class="line">                            ln = <span class="keyword">null</span>;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</div><div class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</div><div class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</div><div class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</div><div class="line">                        &#125;</div><div class="line">                        </div><div class="line">                        <span class="comment">//复制完成后的4步操作</span></div><div class="line">                        setTabAt(nextTab, i, ln);<span class="comment">//在nextTable[i]插入原节点</span></div><div class="line">                        setTabAt(nextTab, i + n, hn);<span class="comment">//在nextTable[i+n]插入新节点</span></div><div class="line">                        setTabAt(tab, i, fwd);<span class="comment">//在table[i]插入forwardNode节点，表示已经处理过该节点 </span></div><div class="line">                        advance = <span class="keyword">true</span>;<span class="comment">//设置advance为true 返回到上面的while循环中 就可以执行--i操作</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//f为树结点，主体思想和链表差不多</span></div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</div><div class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</div><div class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</div><div class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">                            <span class="keyword">int</span> h = e.hash;</div><div class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</div><div class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</div><div class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</div><div class="line">                                    lo = p;</div><div class="line">                                <span class="keyword">else</span></div><div class="line">                                    loTail.next = p;</div><div class="line">                                loTail = p;</div><div class="line">                                ++lc;</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">else</span> &#123;</div><div class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</div><div class="line">                                    hi = p;</div><div class="line">                                <span class="keyword">else</span></div><div class="line">                                    hiTail.next = p;</div><div class="line">                                hiTail = p;</div><div class="line">                                ++hc;</div><div class="line">                            &#125;</div><div class="line">                        &#125;                            </div><div class="line">                        </div><div class="line">                        <span class="comment">//如果扩容后已经不再需要tree的结构 反向转换为链表结构  </span></div><div class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</div><div class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</div><div class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</div><div class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</div><div class="line">                            </div><div class="line">                        <span class="comment">//复制完成后的4步操作，与上面链表的相同</span></div><div class="line">                        setTabAt(nextTab, i, ln);</div><div class="line">                        setTabAt(nextTab, i + n, hn);</div><div class="line">                        setTabAt(tab, i, fwd);</div><div class="line">                        advance = <span class="keyword">true</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整个扩容操作分为两个大部分</p>
<ol>
<li>第一部分是构建一个nextTable,它的容量是原来的两倍，这个操作是单线程完成的。</li>
<li>二个部分就是将原来table中的元素复制到nextTable中，这里允许多线程进行操作。</li>
</ol>
<p>具体的流程为：</p>
<ol>
<li><p>为每个内核均分任务，并保证其不小于16</p>
</li>
<li><p>若nextTab为null，则初始化其为原table的2倍；</p>
</li>
<li><p>死循环遍历，直到finishing。</p>
<ul>
<li>计算i的值，从后向前遍历数组完成复制，头结点f = tabAt(tab, i)</li>
<li>节点为空，则插入ForwardingNode，表明该位置已经处理过了</li>
<li>结点为ForwardingNode，说明已经处理过了，直接跳过</li>
<li>否则说明该链表未被处理，则对f结点上锁，处理后插入插入ForwardingNode结点表明已经处理过了<ul>
<li>f是链表节点（fh&gt;=0），将原链表重新hash拆分为两部分，分别插入nextTable的i和i+n的位置</li>
<li>f是TreeBin节点（fh&lt;0），也拆分为两部分，最后要判断如果不再需要tree结构则反转会链表</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>finishing时，nextTab赋给table，更新sizeCtl为新容量的0.75倍 ，完成扩容。</li>
</ul>
<h2 id="3、协助扩容方法helpTransfer"><a href="#3、协助扩容方法helpTransfer" class="headerlink" title="3、协助扩容方法helpTransfer"></a>3、协助扩容方法helpTransfer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</div><div class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</div><div class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</div><div class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</div><div class="line">    	<span class="comment">//计算一个操作校验码  </span></div><div class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</div><div class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</div><div class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</div><div class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</div><div class="line">            	<span class="comment">//调用扩容方法，直接进入复制阶段</span></div><div class="line">                transfer(tab, nextTab);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> nextTab;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> table;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个协助扩容的方法。这个方法被调用的时候，当前ConcurrentHashMap一定已经有了nextTable对象，首先拿到这个nextTable对象，调用transfer方法。回看上面的transfer方法可以看到，当本线程进入扩容方法的时候会直接进入复制阶段。</p>
<h1 id="三、put"><a href="#三、put" class="headerlink" title="三、put"></a>三、put</h1><h2 id="1、put方法"><a href="#1、put方法" class="headerlink" title="1、put方法"></a>1、put方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</div><div class="line">     	<span class="comment">//与HashMap稍有不同</span></div><div class="line">       <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">/** Implementation for put and putIfAbsent */</span></div><div class="line">   <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</div><div class="line">     </div><div class="line">     	<span class="comment">//不允许key或value为null  </span></div><div class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">     	<span class="comment">//计算hash值  </span></div><div class="line">       <span class="keyword">int</span> hash = spread(key.hashCode());</div><div class="line">       <span class="keyword">int</span> binCount = <span class="number">0</span>;</div><div class="line">     	<span class="comment">//死循环，就是不断的尝试。何时插入成功，何时跳出。</span></div><div class="line">       <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</div><div class="line">           Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</div><div class="line">         	<span class="comment">//如果table为空的话，初始化table  </span></div><div class="line">           <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">               tab = initTable();</div><div class="line">         	<span class="comment">//根据hash值计算出在table里面的位置 i = (n - 1) &amp; hash   </span></div><div class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</div><div class="line">             	<span class="comment">//如果这个位置没有值 ，直接放进去，不需要加锁  </span></div><div class="line">               <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</div><div class="line">                            <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</div><div class="line">                   <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></div><div class="line">           &#125;</div><div class="line">         	<span class="comment">//当遇(fh = f.hash) == MOVED，说明是一个ForwardingNode结点，正在进行扩容，帮助一起扩容</span></div><div class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</div><div class="line">               tab = helpTransfer(tab, f);</div><div class="line">         	<span class="comment">//待插入位置非空且不是ForwardingNode节点，即碰撞了</span></div><div class="line">           <span class="keyword">else</span> &#123;</div><div class="line">               V oldVal = <span class="keyword">null</span>;</div><div class="line">             	<span class="comment">//</span></div><div class="line">             </div><div class="line">           	<span class="comment">/**</span></div><div class="line">             	 * 结点上锁，这里的结点可以理解为hash值相同组成的链表的头结点  </div><div class="line">             	 * 内置锁synchronized锁住了f,因为f是指定特定的tab[i]的，</div><div class="line">             	 * 所以就锁住了整行链表,这个设计跟分段锁有异曲同工之妙，只是其他读取操作需要用cas来保证</div><div class="line">             	 */</div><div class="line">               <span class="keyword">synchronized</span> (f) &#123;</div><div class="line">                   <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</div><div class="line">                     	<span class="comment">//fh〉0 说明这个节点是一个链表的节点 不是树的节点  </span></div><div class="line">                       <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</div><div class="line">                           binCount = <span class="number">1</span>;</div><div class="line">                           <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</div><div class="line">                               K ek;</div><div class="line">                               <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                                   ((ek = e.key) == key ||</div><div class="line">                                    (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</div><div class="line">                                   oldVal = e.val;</div><div class="line">                                   <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                                       e.val = value;</div><div class="line">                                   <span class="keyword">break</span>;</div><div class="line">                               &#125;</div><div class="line">                               Node&lt;K,V&gt; pred = e;</div><div class="line">                               <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                                   pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</div><div class="line">                                                             value, <span class="keyword">null</span>);</div><div class="line">                                   <span class="keyword">break</span>;</div><div class="line">                               &#125;</div><div class="line">                           &#125;</div><div class="line">                       &#125;</div><div class="line">                     	<span class="comment">//如果这个节点是树节点，就按照树的方式插入值  </span></div><div class="line">                       <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</div><div class="line">                           Node&lt;K,V&gt; p;</div><div class="line">                           binCount = <span class="number">2</span>;</div><div class="line">                           <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</div><div class="line">                                                          value)) != <span class="keyword">null</span>) &#123;</div><div class="line">                               oldVal = p.val;</div><div class="line">                               <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                                   p.val = value;</div><div class="line">                           &#125;</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</div><div class="line">                 	<span class="comment">//如果链表长度已经达到临界值8 就需要把链表转换为树结构 </span></div><div class="line">                   <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</div><div class="line">                       treeifyBin(tab, i);</div><div class="line">                   <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</div><div class="line">                       <span class="keyword">return</span> oldVal;</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">     	<span class="comment">//将当前ConcurrentHashMap的元素数量+1  </span></div><div class="line">       addCount(<span class="number">1L</span>, binCount);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>put操作的流程：</p>
<ol>
<li><p><strong>判空</strong>： ConcurrentHashMap与HashMap不同的一点就是不允许key或value为null，如果为null则直接抛出异常</p>
</li>
<li><p><strong>hash</strong>：计算hash值。h=key.hashcode，调用spread计算hash=(h ^(h &gt;&gt;&gt;16))&amp; HASH_BITS</p>
</li>
<li><p><strong>遍历table</strong>： </p>
<ul>
<li><p>若table为null，则调用initTable初始化table数组</p>
</li>
<li><p>根据hash值计算存放位置，即table的下标i=(n - 1) &amp; hash</p>
</li>
<li><p>对该位置的结点f = tabAt(tab, i = (n - 1) &amp; hash))进行判断：</p>
<ul>
<li><p>如果是null， 调用casTabAt方法无锁插入</p>
</li>
<li><p>如果是ForwardingNode结点，说明正在扩容，调用helpTransfer方法帮助一起复制</p>
</li>
<li><p>剩下的情况就是非空且不是ForwardingNode节点，即碰撞了，将头节点上锁（保证了线程安全）</p>
<p>区分链表节点和树节点，分别插入</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>addCount</strong></p>
<p>​</p>
</li>
</ol>
<p>扩容与协助扩容方法上面已经分析过，下面看一下addCount方法。</p>
<h2 id="2、addCount方法"><a href="#2、addCount方法" class="headerlink" title="2、addCount方法"></a>2、addCount方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * baseCount值加上x</div><div class="line"> * check&lt;0,则不需要检测是否需要扩容</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</div><div class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</div><div class="line">    <span class="comment">//U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x) 每次进来都baseCount都加1因为x=1</span></div><div class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</div><div class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</div><div class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</div><div class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</div><div class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</div><div class="line">            !(uncontended =</div><div class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</div><div class="line">        	<span class="comment">//多线程CAS发生失败的时候执行</span></div><div class="line">            fullAddCount(x, uncontended);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        s = sumCount();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果check值大于等于0 则需要检验是否需要进行扩容操作  </span></div><div class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</div><div class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</div><div class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</div><div class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</div><div class="line">            </div><div class="line">            <span class="comment">//如果小于0说明已经有线程在进行扩容操作了</span></div><div class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</div><div class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</div><div class="line">                    transferIndex &lt;= <span class="number">0</span>)</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                </div><div class="line">                </div><div class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</div><div class="line">                    transfer(tab, nt);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//当前线程是唯一的或是第一个发起扩容的线程  此时nextTable=null  </span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</div><div class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</div><div class="line">                transfer(tab, <span class="keyword">null</span>);</div><div class="line">            s = sumCount();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出该方法大体分两步：</p>
<ol>
<li>用CAS方法给baseCount加上指定的x，如果失败了，就执行fullAddCount方法。</li>
<li>如果指定的check小于0，你们在baseCount加上x后就要进行扩容检测，如果需要扩容，则调用transfer方法进行扩容。</li>
</ol>
<h1 id="四、其他方法"><a href="#四、其他方法" class="headerlink" title="四、其他方法"></a>四、其他方法</h1><h2 id="1、size与mappingCount方法"><a href="#1、size与mappingCount方法" class="headerlink" title="1、size与mappingCount方法"></a>1、size与mappingCount方法</h2><p>对于ConcurrentHashMap来说，这个table里到底装了多少东西其实是个不确定的数量，因为不可能在调用size()方法的时候像GC的“stop the world”一样让其他线程都停下来让你去统计，因此只能说这个数量是个估计值。对于这个估计值，ConcurrentHashMap也是大费周章才计算出来的。</p>
<h3 id="2-1、size方法"><a href="#2-1、size方法" class="headerlink" title="2.1、size方法"></a>2.1、size方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> map.size(); &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">long</span> n = sumCount();</div><div class="line">       <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</div><div class="line">               (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</div><div class="line">               (<span class="keyword">int</span>)n);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>旧版的方法。可以看出，size方法并没有直接返回，而是调用了sumCount方法。</p>
<h3 id="2-1、mappingCount"><a href="#2-1、mappingCount" class="headerlink" title="2.1、mappingCount"></a>2.1、mappingCount</h3><p>mappingCount与size方法的类似  从下面的注释可以看出，应该使用mappingCount代替size方法，并且返回值至少一个<strong>估计值</strong>。如果sumCount时有线程插入或删除，实际数量是和mappingCount不同的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns the number of mappings. This method should be used</div><div class="line"> * instead of &#123;<span class="doctag">@link</span> #size&#125; because a ConcurrentHashMap may</div><div class="line"> * contain more mappings than can be represented as an int. The</div><div class="line"> * value returned is an estimate; the actual count may differ if</div><div class="line"> * there are concurrent insertions or removals.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@return</span> the number of mappings</div><div class="line"> * <span class="doctag">@since</span> 1.8</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">mappingCount</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> n = sumCount();</div><div class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0L</span>) ? <span class="number">0L</span> : n; <span class="comment">// ignore transient negative values</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与size方法一样，都没有直接返回basecont值，而是调用了下面的sumCount方法</p>
<h3 id="2-3、sumCount方法"><a href="#2-3、sumCount方法" class="headerlink" title="2.3、sumCount方法"></a>2.3、sumCount方法</h3><p>接下来就看一下这个sumCount方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">   <span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterCell</span> </span>&#123;</div><div class="line">       <span class="keyword">volatile</span> <span class="keyword">long</span> value;</div><div class="line">       CounterCell(<span class="keyword">long</span> x) &#123; value = x; &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</div><div class="line">       CounterCell[] as = counterCells; CounterCell a;</div><div class="line">       <span class="keyword">long</span> sum = baseCount;</div><div class="line">       <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</div><div class="line">               <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</div><div class="line">                   sum += a.value;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> sum;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> sumCount() &lt;= <span class="number">0L</span>; <span class="comment">// ignore transient negative values</span></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="2、get与contains方法"><a href="#2、get与contains方法" class="headerlink" title="2、get与contains方法"></a>2、get与contains方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</div><div class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</div><div class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</div><div class="line">                <span class="keyword">return</span> e.val;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</div><div class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</div><div class="line">                <span class="keyword">return</span> e.val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> get(key) != <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    Node&lt;K,V&gt;[] t;</div><div class="line">    <span class="keyword">if</span> ((t = table) != <span class="keyword">null</span>) &#123;</div><div class="line">        Traverser&lt;K,V&gt; it = <span class="keyword">new</span> Traverser&lt;K,V&gt;(t, t.length, <span class="number">0</span>, t.length);</div><div class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; p; (p = it.advance()) != <span class="keyword">null</span>; ) &#123;</div><div class="line">            V v;</div><div class="line">            <span class="keyword">if</span> ((v = p.val) == value || (v != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="五、参考地址"><a href="#五、参考地址" class="headerlink" title="五、参考地址"></a>五、参考地址</h1><p><a href="http://blog.csdn.net/u010723709/article/details/48007881" target="_blank" rel="external">http://blog.csdn.net/u010723709/article/details/48007881</a></p>
<p><a href="https://yq.aliyun.com/articles/36781" target="_blank" rel="external">https://yq.aliyun.com/articles/36781</a></p>
<p><a href="http://www.cnblogs.com/huaizuo/archive/2016/04/20/5413069.html" target="_blank" rel="external">http://www.cnblogs.com/huaizuo/archive/2016/04/20/5413069.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LinkedList源码分析]]></title>
      <url>http://yoursite.com/2016/11/12/Java/JDK/LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>分析完Arraylist后来看一下List的另一种实现LinkedList。LinkedList底层使用的是双向链表结构，内部类定义了节点结构，一个头结点和尾节点表示队列的开始和结尾。与ArrayList不同的是，LinkedList除了实现了List接口外，还实现了Deque接口，而Deque接口继承自Queue接口，也就是说，LinkedList还可以用来实现双端队列。</p>
<p>关于具体类对象与接口的关系，我个人的理解就是，一个接口定义了它可以实现的全部功能，比如List接口，定义了add、set等等方法，而具体的类比如ArrayList或LinkedList如果实现了这个接口，就必须实现接口中定义的所有方法，所以ArrayList和LinkedList中肯定实现了List接口中定义的所有方法，但是一个类可以实现多个接口，比如LinkedList还实现了Deque接口，那么它内部肯定也实现了Deque接口定义的所有方法。在使用过程中，一般都是定义一个接口指向具体实例比如List list=new LinkedList(); 这样的意义在于只能调用该接口中定义的方法。虽然LinkedList中实现了其他的方法，但是List类型的引用只能调用该接口中定义的方法。</p>
<h1 id="一、基本属性与构造函数"><a href="#一、基本属性与构造函数" class="headerlink" title="一、基本属性与构造函数"></a>一、基本属性与构造函数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;  </span></div><div class="line">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;  </div><div class="line">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>  </div><div class="line">&#123;  </div><div class="line">      </div><div class="line">    <span class="comment">//内部类节点，实现双端队列  </span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;  </div><div class="line">        E item;<span class="comment">//数据域  </span></div><div class="line">        Node&lt;E&gt; next;<span class="comment">//指向的下一个节点  </span></div><div class="line">        Node&lt;E&gt; prev;<span class="comment">//指向的前一个节点  </span></div><div class="line">        <span class="comment">//构造函数  </span></div><div class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;  </div><div class="line">            <span class="keyword">this</span>.item = element;  </div><div class="line">            <span class="keyword">this</span>.next = next;  </div><div class="line">            <span class="keyword">this</span>.prev = prev;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;<span class="comment">//实际元素的个数  </span></div><div class="line">  </div><div class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;<span class="comment">//头节点  </span></div><div class="line">  </div><div class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;<span class="comment">//尾节点  </span></div><div class="line">  </div><div class="line">    <span class="comment">/* </span></div><div class="line">     * 构造函数 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;<span class="comment">//空List  </span></div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<span class="comment">//包含集合中所有元素  </span></div><div class="line">        <span class="keyword">this</span>();  </div><div class="line">        addAll(c);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>既然是双端队列，首先自己定义了结点，然后用first和last来指向头结点与尾结点。</p>
<p>构造函数中也没有具体实现，因为不需要像ArrayList一样初始化数组什么的。</p>
<h1 id="二、内部操作"><a href="#二、内部操作" class="headerlink" title="二、内部操作"></a>二、内部操作</h1><p>由于底层由双向链表实现，所以我们先来看一下它内部的操作，主要包括添加节点与删除节点，这些方法没有重写任何接口，而是内部定义，在重写接口的方法的时候，主要还是调用这些底层的操作来实现的。</p>
<h2 id="1、增加结点"><a href="#1、增加结点" class="headerlink" title="1、增加结点"></a>1、增加结点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * 新加一个节点 </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;<span class="comment">//添加一个节点到链表头部，考虑头部是否为null两种情况  </span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;<span class="comment">//先保存当前头节点，final类型不可更改  </span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);<span class="comment">//新建一个节点，后继节点指向原来的头节点  </span></div><div class="line">    first = newNode;<span class="comment">//将新的节点指定为头节点  </span></div><div class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)<span class="comment">//如果原来头节点为空，即原来链表为空  </span></div><div class="line">        last = newNode;<span class="comment">//那么新加入的节点即是头节点也是尾节点  </span></div><div class="line">    <span class="keyword">else</span><span class="comment">//如果原来链表不为空  </span></div><div class="line">        f.prev = newNode;<span class="comment">//将原来头节点的前驱指向新的头节点  </span></div><div class="line">    size++;<span class="comment">//元素个数+1  </span></div><div class="line">    modCount++;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;<span class="comment">//添加一个节点到链表尾部,原理和上面基本相同  </span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;  </div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);  </div><div class="line">    last = newNode;  </div><div class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)  </div><div class="line">        first = newNode;  </div><div class="line">    <span class="keyword">else</span>  </div><div class="line">        l.next = newNode;  </div><div class="line">    size++;  </div><div class="line">    modCount++;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;<span class="comment">//添加一个节点到一个指定的非null节点前面，考虑succ节点的前一个节点是否为null两种情况  </span></div><div class="line">    <span class="comment">// 必须保证succ节点是非null的  </span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;<span class="comment">//保存succ节点的前驱节点，final类型不可更改  </span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);<span class="comment">//新建一个节点，指定前驱和后继分别指定pred和succ  </span></div><div class="line">    succ.prev = newNode;<span class="comment">//succ的前驱节点指向新建的节点  </span></div><div class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)<span class="comment">//如果原来的succ的前驱节点为null，则说明succ为头节点  </span></div><div class="line">        first = newNode;<span class="comment">//那么将新节点指定为头节点  </span></div><div class="line">    <span class="keyword">else</span><span class="comment">//如果succ不是头节点  </span></div><div class="line">        pred.next = newNode;<span class="comment">//将pred的后继指向新建的节点  </span></div><div class="line">    size++;<span class="comment">//  </span></div><div class="line">    modCount++;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2、删除结点"><a href="#2、删除结点" class="headerlink" title="2、删除结点"></a>2、删除结点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * 去掉一个节点 </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;<span class="comment">//去掉头节点，并返回，考虑头节点的后继是否为null两种情况  </span></div><div class="line">    <span class="comment">//  必须保证f是头节点且非null  </span></div><div class="line">    <span class="keyword">final</span> E element = f.item;<span class="comment">//保存数据域最后将其返回  </span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;<span class="comment">//保存头结点的后继，final类型不可更改  </span></div><div class="line">    f.item = <span class="keyword">null</span>;<span class="comment">//头节点的item和next都置为null  </span></div><div class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// 垃圾回收  </span></div><div class="line">    first = next;<span class="comment">//指定新的头节点  </span></div><div class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)<span class="comment">//如果原来头结点的后继为null，则说明原来只有一个节点  </span></div><div class="line">        last = <span class="keyword">null</span>;<span class="comment">//那么删除该节点后尾节点也应该为null  </span></div><div class="line">    <span class="keyword">else</span><span class="comment">//如果原来链表中不止一个节点  </span></div><div class="line">        next.prev = <span class="keyword">null</span>;<span class="comment">//那么next节点作为头节点前驱应该为null  </span></div><div class="line">    size--;<span class="comment">//  </span></div><div class="line">    modCount++;  </div><div class="line">    <span class="keyword">return</span> element;<span class="comment">//  </span></div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;<span class="comment">//去掉尾节点，并返回，原理同上  </span></div><div class="line">    <span class="comment">// 必须保证l是尾节点且非null  </span></div><div class="line">    <span class="keyword">final</span> E element = l.item;  </div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;  </div><div class="line">    l.item = <span class="keyword">null</span>;  </div><div class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC  </span></div><div class="line">    last = prev;  </div><div class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)  </div><div class="line">        first = <span class="keyword">null</span>;  </div><div class="line">    <span class="keyword">else</span>  </div><div class="line">        prev.next = <span class="keyword">null</span>;  </div><div class="line">    size--;  </div><div class="line">    modCount++;  </div><div class="line">    <span class="keyword">return</span> element;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;<span class="comment">//去掉一个指定的节点，并返回，考虑该节点是头结点、或是尾节点的情况  </span></div><div class="line">    <span class="comment">// 必须保证x是非null  </span></div><div class="line">    <span class="keyword">final</span> E element = x.item;<span class="comment">//保存数据域最后将其返回  </span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;<span class="comment">//保存该节点的前驱节点  </span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;<span class="comment">//保存该节点的后继节点  </span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;<span class="comment">//前驱节点为null，即该节点为头结点  </span></div><div class="line">        first = next;<span class="comment">//将后继节点指定为新的头节点  </span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//前驱不为空的话  </span></div><div class="line">        prev.next = next;<span class="comment">//前驱指向后继  </span></div><div class="line">        x.prev = <span class="keyword">null</span>;<span class="comment">//前驱置null，垃圾回收  </span></div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;<span class="comment">//与判断头结点原理相同  </span></div><div class="line">        last = prev;<span class="comment">//  </span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//  </span></div><div class="line">        next.prev = prev;<span class="comment">//  </span></div><div class="line">        x.next = <span class="keyword">null</span>;<span class="comment">//  </span></div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    x.item = <span class="keyword">null</span>;<span class="comment">//置null，垃圾回收  </span></div><div class="line">    size--;<span class="comment">//  </span></div><div class="line">    modCount++;  </div><div class="line">    <span class="keyword">return</span> element;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注释中可以看到，删除一个节点的前提都是该节点肯定不为null，因为在其他方法调用这些底层方法之前，肯定会先进行判断，然后再调用该方法直接对底层结构进行修改。</p>
<h1 id="三、Deque接口"><a href="#三、Deque接口" class="headerlink" title="三、Deque接口"></a>三、Deque接口</h1><p>LinkedList实现了Deque接口，也就是双端队列，我们先来看一下该接口的定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span></span>;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span></span>;  </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span></span>;  </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span></span>;  </div><div class="line">    <span class="function">E <span class="title">removeFirst</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function">E <span class="title">removeLast</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function">E <span class="title">pollFirst</span><span class="params">()</span></span>;   </div><div class="line">    <span class="function">E <span class="title">pollLast</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function">E <span class="title">getFirst</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function">E <span class="title">getLast</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function">E <span class="title">peekFirst</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function">E <span class="title">peekLast</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeFirstOccurrence</span><span class="params">(Object o)</span></span>;  </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeLastOccurrence</span><span class="params">(Object o)</span></span>;  </div><div class="line">    <span class="comment">// *** Queue methods ***  </span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;  </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;  </div><div class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function">E <span class="title">element</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;  </div><div class="line">    <span class="comment">// *** Stack methods ***  </span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;  </div><div class="line">    <span class="function">E <span class="title">pop</span><span class="params">()</span></span>;  </div><div class="line">    <span class="comment">// *** Collection methods ***  </span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;  </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span></span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它继承自Queue接口，关于Queue接口的方法上面的注释中给出了介绍，在Queue的基础上，它还添加了很多Deque的方法和两个Stack的方法，但是该接口并没有继承Stack接口，此处并不是很明白。</p>
<p>在接口定义中明确指出了哪些方法处于哪些操作，但是在LinkedList的代码中这些方法的继承关系并不是很明确，比如在有些方法前面明确指出了// Deque operations和// Queue operations.但是这些注释下面的方法与Deque接口中定义的并不符合，而且也没有Stack的相关操作的说明。</p>
<p>下面列出了LinkedList类中关于Deque接口的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;<span class="comment">//  </span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;  </div><div class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();  </div><div class="line">    <span class="keyword">return</span> f.item;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;<span class="comment">//  </span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;  </div><div class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();  </div><div class="line">    <span class="keyword">return</span> l.item;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;<span class="comment">//  </span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;  </div><div class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();  </div><div class="line">    <span class="keyword">return</span> unlinkFirst(f);  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;<span class="comment">//  </span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;  </div><div class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();  </div><div class="line">    <span class="keyword">return</span> unlinkLast(l);  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;<span class="comment">//  </span></div><div class="line">    linkFirst(e);  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;<span class="comment">//  </span></div><div class="line">    linkLast(e);  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Queue operations.  </span></div><div class="line"><span class="comment">//单相队列，队尾进， 队首出  </span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;<span class="comment">//取出但不删除队首元素  </span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;  </div><div class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;<span class="comment">//获取但不删除队首元素  </span></div><div class="line">    <span class="keyword">return</span> getFirst();  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;<span class="comment">//取出并删除队首元素  </span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;  </div><div class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;<span class="comment">//取出并删除队首元素  </span></div><div class="line">    <span class="keyword">return</span> removeFirst();  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;<span class="comment">//添加元素到队尾  </span></div><div class="line">    <span class="keyword">return</span> add(e);  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Deque operations  </span></div><div class="line"><span class="comment">//双端队列  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;<span class="comment">//队首添加元素  </span></div><div class="line">    addFirst(e);  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;<span class="comment">//队尾添加元素  </span></div><div class="line">    addLast(e);  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;<span class="comment">//获取但不删除队首元素  </span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;  </div><div class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;  </div><div class="line"> &#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;<span class="comment">//获取但不删除队尾元素  </span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;  </div><div class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : l.item;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;<span class="comment">//取出并删除队首元素  </span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;  </div><div class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;<span class="comment">//取出并删除队尾元素  </span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;  </div><div class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkLast(l);  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeFirstOccurrence</span><span class="params">(Object o)</span> </span>&#123;<span class="comment">//  </span></div><div class="line">    <span class="keyword">return</span> remove(o);  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeLastOccurrence</span><span class="params">(Object o)</span> </span>&#123;<span class="comment">//  </span></div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;  </div><div class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;  </div><div class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;  </div><div class="line">                unlink(x);  </div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;  </div><div class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;  </div><div class="line">                unlink(x);  </div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">// *** Stack methods ***这个注释是我自己加的  </span></div><div class="line"><span class="comment">//栈，队首插入，队首取出  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;<span class="comment">//进栈操作  </span></div><div class="line">    addFirst(e);  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;<span class="comment">//出栈操作，删除并取出  </span></div><div class="line">    <span class="keyword">return</span> removeFirst();  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，这些方法基本都会调用上面第2节介绍的添加和删除操作，也就是说，这些方法仅仅的实现接口时对外的封装，内部的实现全部都依赖与第2节介绍的对底层数据结构的操作的那几个方法。</p>
<h1 id="四、List接口"><a href="#四、List接口" class="headerlink" title="四、List接口"></a>四、List接口</h1><p>接下来这几节是根据源码中的注释进行分类的。注释中把剩下的方法分类为Positional Access Operations、Search Operations下面来看一下分类中对应的方法和实现。</p>
<h2 id="1、Positional-Access-Operations"><a href="#1、Positional-Access-Operations" class="headerlink" title="1、Positional Access Operations"></a>1、Positional Access Operations</h2><p>对指定位置元素的操作。一般参数中都会指定一个index位置，对该位置的元素进行操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Positional Access Operations  </span></div><div class="line"></div><div class="line"><span class="comment">/* </span></div><div class="line"> * 对指定位置元素的操作 </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;<span class="comment">//返回指定位置的元素  </span></div><div class="line">    checkElementIndex(index);  </div><div class="line">    <span class="keyword">return</span> node(index).item;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;<span class="comment">//设置指定位置的元素  </span></div><div class="line">    checkElementIndex(index);  </div><div class="line">    Node&lt;E&gt; x = node(index);  </div><div class="line">    E oldVal = x.item;  </div><div class="line">    x.item = element;  </div><div class="line">    <span class="keyword">return</span> oldVal;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;<span class="comment">//在指定位置插入元素  </span></div><div class="line">    checkPositionIndex(index);  </div><div class="line"></div><div class="line">    <span class="keyword">if</span> (index == size)  </div><div class="line">        linkLast(element);  </div><div class="line">    <span class="keyword">else</span>  </div><div class="line">        linkBefore(element, node(index));  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;<span class="comment">//删除指定位置的元素  </span></div><div class="line">    checkElementIndex(index);  </div><div class="line">    <span class="keyword">return</span> unlink(node(index));  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">outOfBoundsMsg</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> <span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+size;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (!isElementIndex(index))  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (!isPositionIndex(index))  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">/* </span></div><div class="line"> * 返回指定位置的节点 </div><div class="line"> */  </div><div class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;<span class="comment">//返回第index个节点  </span></div><div class="line">    <span class="comment">// assert isElementIndex(index);  </span></div><div class="line">    <span class="comment">//判断在前半部分还是后半部分  </span></div><div class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;<span class="comment">//index在前半部分  </span></div><div class="line">        Node&lt;E&gt; x = first;  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)<span class="comment">//从前向后顺序查找  </span></div><div class="line">            x = x.next;  </div><div class="line">        <span class="keyword">return</span> x;  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//index在后半部分  </span></div><div class="line">        Node&lt;E&gt; x = last;  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)<span class="comment">//从后向前顺序查找  </span></div><div class="line">            x = x.prev;  </div><div class="line">        <span class="keyword">return</span> x;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>与Deque接口一样，对指定位置元素的操作，内部还是会调用第二节的内部操作，不同的是，这里封装的是对元素操作，而第二节的方法是对底层链表的节点操作，两者是不一样的。</p>
</li>
<li><p>所以部分方法中基本都会先调用checkElementIndex(index);方法来确认index参数是否合法，如果不合法就直接抛出异常。</p>
</li>
<li><p>如果index参数合法，就会调用最下面的node(index)方法，即在链表中找到指定位置的节点，查找的方法采用顺序查找，先判断index是在前半部分还是后半部分，然后决定是从前向后查找还是从后向前查找。</p>
<p>​</p>
</li>
</ul>
<h2 id="2、Search-Operations"><a href="#2、Search-Operations" class="headerlink" title="2、Search Operations"></a>2、Search Operations</h2><p>查找操作，有两个方法查找某个元素第一次出现的位置，一个是从前向后查找，一个是从后向前查找。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Search Operations  </span></div><div class="line"> </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;<span class="comment">//返回某个元素第一次出现的位置，如果没有则返回-1  </span></div><div class="line">       <span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">//考虑元素是否为null两种情况  </span></div><div class="line">       <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;<span class="comment">//  </span></div><div class="line">           <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;<span class="comment">//从前向后遍历  x.item == null  </span></div><div class="line">               <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)<span class="comment">//  </span></div><div class="line">                   <span class="keyword">return</span> index;<span class="comment">//  </span></div><div class="line">               index++;<span class="comment">//  </span></div><div class="line">           &#125;  </div><div class="line">       &#125; <span class="keyword">else</span> &#123;<span class="comment">//  </span></div><div class="line">           <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;<span class="comment">//    o.equals(x.item)  </span></div><div class="line">               <span class="keyword">if</span> (o.equals(x.item))<span class="comment">//  </span></div><div class="line">                   <span class="keyword">return</span> index;<span class="comment">//  </span></div><div class="line">               index++;<span class="comment">//  </span></div><div class="line">           &#125;  </div><div class="line">       &#125;  </div><div class="line">       <span class="keyword">return</span> -<span class="number">1</span>;  </div><div class="line">   &#125;  </div><div class="line"> </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;<span class="comment">//返回从后向前第一次出现的位置，原理同上，只是顺序不同  </span></div><div class="line">       <span class="keyword">int</span> index = size;  </div><div class="line">       <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;  </div><div class="line">           <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;  </div><div class="line">               index--;  </div><div class="line">               <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)  </div><div class="line">                   <span class="keyword">return</span> index;  </div><div class="line">           &#125;  </div><div class="line">       &#125; <span class="keyword">else</span> &#123;  </div><div class="line">           <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;  </div><div class="line">               index--;  </div><div class="line">               <span class="keyword">if</span> (o.equals(x.item))  </div><div class="line">                   <span class="keyword">return</span> index;  </div><div class="line">           &#125;  </div><div class="line">       &#125;  </div><div class="line">       <span class="keyword">return</span> -<span class="number">1</span>;  </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>有一点需要注意的就是List中允许出现null，所以在判断元素相等的时候，需要判断该元素是否为null，如果是是null则用==判断，否则使用equals判断相等。</p>
<h2 id="3、toArray"><a href="#3、toArray" class="headerlink" title="3、toArray"></a>3、toArray</h2><p>使用方法与ArrayList中一样。一个是返回Object数组，还有一个是返回指定类型的数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Object[] toArray() &#123;  </div><div class="line">    Object[] result = <span class="keyword">new</span> Object[size];  </div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)  </div><div class="line">        result[i++] = x.item;  </div><div class="line">    <span class="keyword">return</span> result;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)  </div><div class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;  </div><div class="line">    <span class="keyword">if</span> (a.length &lt; size)  </div><div class="line">        a = (T[])java.lang.reflect.Array.newInstance(  </div><div class="line">                            a.getClass().getComponentType(), size);  </div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;  </div><div class="line">    Object[] result = a;  </div><div class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)  </div><div class="line">        result[i++] = x.item;  </div><div class="line"></div><div class="line">    <span class="keyword">if</span> (a.length &gt; size)  </div><div class="line">        a[size] = <span class="keyword">null</span>;  </div><div class="line"></div><div class="line">    <span class="keyword">return</span> a;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4、其他"><a href="#4、其他" class="headerlink" title="4、其他"></a>4、其他</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> size;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;  </div><div class="line">    linkLast(e);  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;<span class="comment">//删除指定元素，同样要考虑是否为null两种情况  </span></div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;  </div><div class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;  </div><div class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;  </div><div class="line">                unlink(x);  </div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;  </div><div class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;  </div><div class="line">                unlink(x);  </div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> addAll(size, c);  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;<span class="comment">//将集合中所有元素加入链表的指定位置  </span></div><div class="line">    checkPositionIndex(index);<span class="comment">//检查插入的位置是否合法  </span></div><div class="line"></div><div class="line">    Object[] a = c.toArray();<span class="comment">//将集合中元素转换为Object数组  </span></div><div class="line">    <span class="keyword">int</span> numNew = a.length;<span class="comment">//numNew即集合中元素的个数  </span></div><div class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)<span class="comment">//  </span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//  </span></div><div class="line"></div><div class="line">    Node&lt;E&gt; pred, succ;<span class="comment">//定义两个节点保存前驱与后继节点，考虑是否在末尾插入两种情况  </span></div><div class="line">    <span class="keyword">if</span> (index == size) &#123;<span class="comment">//如果在末尾插入  </span></div><div class="line">        succ = <span class="keyword">null</span>;<span class="comment">//不用指定后继节点  </span></div><div class="line">        pred = last;<span class="comment">//前驱节点为尾节点  </span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果不在末尾插入，则需要通过index找到要插入的那个节点  </span></div><div class="line">        succ = node(index);<span class="comment">//后继为找到的那个节点  </span></div><div class="line">        pred = succ.prev;<span class="comment">//前驱为找到那个几点的前驱  </span></div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="keyword">for</span> (Object o : a) &#123;<span class="comment">//for each循环遍历a数组，逐个插入  </span></div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;<span class="comment">//强制转型为指定类型  </span></div><div class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);<span class="comment">//新建一个节点，数据域为转型后的数组元素，指定前驱  </span></div><div class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)<span class="comment">//如果前驱为null  </span></div><div class="line">            first = newNode;<span class="comment">//说明在头节点前插入，那么新节点为新的头节点  </span></div><div class="line">        <span class="keyword">else</span><span class="comment">//如果不为null，说明前面有节点  </span></div><div class="line">            pred.next = newNode;<span class="comment">//将前面节点的后继指向新节点  </span></div><div class="line">        pred = newNode;<span class="comment">//更新前驱节点  </span></div><div class="line">    &#125;  </div><div class="line">    <span class="comment">//所有节点插入完毕后更新尾节点  </span></div><div class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;<span class="comment">//如果后继节点为null，说名在末尾插入  </span></div><div class="line">        last = pred;<span class="comment">//那么刚才最后一个前驱就是尾节点  </span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果不在末尾插入，后面还有元素  </span></div><div class="line">        pred.next = succ;<span class="comment">//连接前驱与后继节点  </span></div><div class="line">        succ.prev = pred;<span class="comment">//  </span></div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    size += numNew;<span class="comment">//更新元素个数  </span></div><div class="line">    modCount++;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">&#125;    </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;<span class="comment">//清除所有元素  </span></div><div class="line">    <span class="comment">// Clearing all of the links between nodes is "unnecessary", but:  </span></div><div class="line">    <span class="comment">// - helps a generational GC if the discarded nodes inhabit  </span></div><div class="line">    <span class="comment">//   more than one generation  </span></div><div class="line">    <span class="comment">// - is sure to free memory even if there is a reachable Iterator  </span></div><div class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; ) &#123;  </div><div class="line">        Node&lt;E&gt; next = x.next;  </div><div class="line">        x.item = <span class="keyword">null</span>;  </div><div class="line">        x.next = <span class="keyword">null</span>;  </div><div class="line">        x.prev = <span class="keyword">null</span>;  </div><div class="line">        x = next;  </div><div class="line">    &#125;  </div><div class="line">    first = last = <span class="keyword">null</span>;  </div><div class="line">    size = <span class="number">0</span>;  </div><div class="line">    modCount++;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[虚拟机类加载机制]]></title>
      <url>http://yoursite.com/2016/11/02/JVM/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p><strong>虚拟机类加载机制</strong>：虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。</p>
<h1 id="一、加载的时机"><a href="#一、加载的时机" class="headerlink" title="一、加载的时机"></a>一、加载的时机</h1><h2 id="1、类的生命周期"><a href="#1、类的生命周期" class="headerlink" title="1、类的生命周期"></a>1、类的生命周期</h2><p>　类的生命周期有一下7个阶段：</p>
<ul>
<li>加载 loading</li>
<li>验证 verification</li>
<li>准备 preparation</li>
<li>解析 resolution</li>
<li>初始化 initialization</li>
<li>使用 using</li>
<li>卸载 unloading</li>
</ul>
<p>验证、准备、解析三个部分统称为连接。</p>
<p>其中，加载、验证、准备、初始化和卸载这5个阶段的顺序的确定的，但是解析阶段则不一定，有些情况下回在初始化之后进行。</p>
<h2 id="2、初始化"><a href="#2、初始化" class="headerlink" title="2、初始化"></a>2、初始化</h2><p>对于初始化阶段，严格规定<strong>有且只有</strong>一下5种情况必须立即进行初始化（加载、验证、准备需要在此之前进行）。</p>
<ol>
<li>遇到new、getstatic、putstatic、或invokestatic这4条字节码指令时。即使用new实例化一个对象、读取或设置一个类的静态字段(final修饰的常量除外)、及调用类的静态方法。</li>
<li>使用java.lang.reflect包的方法就类进行反射调用到时候</li>
<li>初始化一个类的时候，如果父类还没有初始化，要先初始化其父类</li>
<li>虚拟机启动时，会先初始化唯一的主类(包含main()那个类)</li>
<li>JDK1.7 中动态语言支持的一些情况</li>
</ol>
<p>只有这5中情况才会触发类的初始化，这5种场景中的行为被称为<strong>主动引用</strong>。除此之外，所有引用类的地方都不会触发初始化，被称为<strong>被动引用</strong>。下面是几个被动引用的例子：</p>
<ol>
<li>通过子类引用父类的静态字段，不会导致子类初始化(对于静态字段，只有直接定义这个字段的类才会被初始化)。</li>
<li>通过数组定义类应用类：ClassA [] array=new ClassA[10]。触发了一个名为“[ClassA”的类的初始化，它是一个由虚拟机自动生成的、直接继承于Object的类，创建动作由字节码指令newarray触发。</li>
<li>常量会在编译阶段存入调用类的常量池。</li>
</ol>
<h1 id="二、加载的过程"><a href="#二、加载的过程" class="headerlink" title="二、加载的过程"></a>二、加载的过程</h1><h2 id="1、加载"><a href="#1、加载" class="headerlink" title="1、加载"></a>1、加载</h2><p>加载阶段，虚拟机需要完成以下三件事：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.class.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<h3 id="关于二进制流"><a href="#关于二进制流" class="headerlink" title="关于二进制流"></a>关于二进制流</h3><p>可以来自很多地方，比如：</p>
<ul>
<li>ZIP包中，也是JAR、EAR、WAR格式的基础</li>
<li>从网络中获取，最典型的就是Applet</li>
<li>运行时计算生成，使用最多的就是动态代理</li>
<li>由其他文件生成，典型场景JSP</li>
<li>从数据库中读取</li>
</ul>
<h3 id="数组类的加载"><a href="#数组类的加载" class="headerlink" title="数组类的加载"></a>数组类的加载</h3><p>对于非数组类，可以使用系统提供的引导类加载器加载，也可以使用用户自定义的加载器加载。</p>
<p>但是对于数组类情况就不同，数组类本身不通过类加载器创建，而是由java虚拟机直接创建。</p>
<h2 id="2、验证"><a href="#2、验证" class="headerlink" title="2、验证"></a>2、验证</h2><p>验证是连接的第一步，目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求。包含以下4个阶段：</p>
<ol>
<li>文件格式校验：<ul>
<li>以魔数0xCAFEBABE开头</li>
<li>主次版本号是否可处理</li>
<li>常量池的常量是否有不被支持的类型</li>
<li>等等。。。。</li>
</ul>
</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ol>
<h2 id="3、准备"><a href="#3、准备" class="headerlink" title="3、准备"></a>3、准备</h2><p>准备阶段是为<strong>类变量</strong>分配<strong>内存</strong>并设置<strong>初始值</strong>的阶段。</p>
<p>这一句话中包含三个关键信息：</p>
<ol>
<li><p>仅仅是类变量(static修饰)而不包含实例变量</p>
</li>
<li><p>类变量的内存被分配在方法区中，而实例变量是在堆中</p>
</li>
<li><p>准备阶段变量的初始值都是零值，比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在准备阶段value的值是0，初始化阶段才会赋值为123</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> calue=<span class="number">123</span>;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>有一种特殊情况：如果类变量的字段属性表中存在ConstantValue属性，那么在准备阶段就会被直接初始化为ConstantValue属性指定的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//准备阶段value值就是123</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value=<span class="number">123</span>;</div></pre></td></tr></table></figure>
<h2 id="4、解析"><a href="#4、解析" class="headerlink" title="4、解析"></a>4、解析</h2><p>解析是将常量池内<strong>符号引用</strong>替换为<strong>直接引用</strong>的过程。</p>
<p>首先区别下符号引用于直接引用：</p>
<ul>
<li><strong>符号引用</strong>：以一组符号来描述所引用的目标，与虚拟机的内存布局无关，引用的目标不一定已经加载到内存中。</li>
<li><strong>直接引用</strong>：可以是直接指向目标的指针。相对偏移量或是一个能节间定位到目标的句柄。直接引用于虚拟机内存布局相关，如果有了直接引用，那么引用的目标必定在内存中存在。</li>
</ul>
<p>下面是4中引用的解析：</p>
<ol>
<li>类或接口的解析</li>
<li>字段解析</li>
<li>类方法解析</li>
<li>接口方法解析</li>
</ol>
<h2 id="5、初始化"><a href="#5、初始化" class="headerlink" title="5、初始化"></a>5、初始化</h2><p>初始化是类加载的最后一步，到了初始化阶段，才真正开始执行java代码中的程序。</p>
<p>在编译生成class文件时，会自动产生两个方法，一个是类的初始化方法<code>&lt;clinit&gt;()</code>, 另一个是实例的初始化方法<code>&lt;init&gt;()</code>。而初始化的过程就是执行类构造器<code>&lt;cinit&gt;()</code>方法的过程。</p>
<p>关于    <code>&lt;cinit&gt;()</code>：</p>
<ol>
<li><p><code>&lt;cinit&gt;()</code>是由编译器自动收集类中都有<strong>类变量的赋值动作</strong>和<strong>静态语句块</strong>中语句合并产生的。</p>
</li>
<li><p><code>&lt;cinit&gt;()</code>方法不是必需的，如果一个类中没有静态语句块或静态变量赋值，那么久可以不生成<code>&lt;cinit&gt;()</code>方法。</p>
</li>
<li><p><code>&lt;cinit&gt;()</code>不需要显示的调用，虚拟机会保证子类的<code>&lt;cinit&gt;()</code>之前，父类的<code>&lt;cinit&gt;()</code>已经执行完毕。所以虚拟机中第一个被执行的<code>&lt;cinit&gt;()</code>方法肯定是java.lang.Object。</p>
</li>
<li><p>编译器的收集顺序由代码顺序决定，静态语句块只能访问到之前的变量，对于之后的变量，只能赋值不能访问，比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">    	i=<span class="number">0</span>;						<span class="comment">//给后面的变量赋值可以编译通过</span></div><div class="line">    	System.out.println(i);		<span class="comment">//这句编译器会提示“非法向前引用”</span></div><div class="line">    &#125;</div><div class="line">  	<span class="keyword">static</span> i=<span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ol>
<h1 id="三、类加载器"><a href="#三、类加载器" class="headerlink" title="三、类加载器"></a>三、类加载器</h1><p>上面提到类的加载阶段需要完成三件事，这三件事就是通过类加载器完成的</p>
<h2 id="1、类与类加载器"><a href="#1、类与类加载器" class="headerlink" title="1、类与类加载器"></a>1、类与类加载器</h2><p>在Java中，任何一个类都需要由加载它的类加载器和这个类本身一同确定其在Java虚拟机中的唯一性，每个类加载器都有独立的类名称空间。也就是说，比较两个类是否<strong>相等</strong>，只有这两个类是由同一个类加载器加载的前提下才有意义，否则，即使两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的加载器不同，那么这两个类就不<strong>相等</strong>。这里的<strong>相等</strong>包括类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法和instanceof关键字的结果。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.InputStream;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;   	</div><div class="line">        ClassLoader myClassLoader = <span class="keyword">new</span> ClassLoader()&#123;  </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name)<span class="keyword">throws</span> ClassNotFoundException&#123;    </div><div class="line">                 <span class="keyword">try</span>&#123;</div><div class="line">                     String filename = name.substring(name.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>) +<span class="string">".class"</span>;    </div><div class="line">                     InputStream is = getClass().getResourceAsStream(filename);    </div><div class="line">                     <span class="keyword">if</span>(is==<span class="keyword">null</span>)&#123;</div><div class="line">                         <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</div><div class="line">                     &#125;</div><div class="line">                     <span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</div><div class="line">                     is.read(b);</div><div class="line">                     <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</div><div class="line">                 &#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">                     <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);   </div><div class="line">                 &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;		</div><div class="line">        Object obj=myClassLoader.loadClass(<span class="string">"interview.ClassLoaderTest"</span>).newInstance();    </div><div class="line">        System.out.println(obj.getClass());    </div><div class="line">        System.out.println(obj <span class="keyword">instanceof</span> interview.ClassLoaderTest);    </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出为：</p>
<p>class interview.ClassLoaderTest<br>false</p>
<p>因为interview.ClassLoaderTest默认使用Application ClassLoader加载，而obj是通过自定义类加载器加载的，类加载不相同，因此不相等。</p>
<p>类加载器是个很强大的概念，很多地方被运用。最经典的例子就是AppletClassLoader，它被用来加载Applet使用的类，而Applets大部分是在网上使用，而非本地的操作系统使用。使用不同的类加载器，你可以从不同的源地址加载同一个类，它们被视为不同的类。J2EE使用多个类加载器加载不同地方的类，例如WAR文件由Web-app类加载器加载，而EJB-JAR中的类由另外的类加载器加载。有些服务器也支持热部署，这也由类加载器实现。你也可以使用类加载器来加载数据库或者其他持久层的数据。</p>
<h2 id="2、双亲委派模型"><a href="#2、双亲委派模型" class="headerlink" title="2、双亲委派模型"></a>2、双亲委派模型</h2><h3 id="2-1类加载器种类"><a href="#2-1类加载器种类" class="headerlink" title="2.1类加载器种类"></a>2.1类加载器种类</h3><p>从Java虚拟机的角度，类加载器只有两种：一种是启动类加载器(Bootstrap ClassLoader)，这个加载器由C++语言实现是虚拟机自身的一部分。另一种是其他的类加载器，由Java语言实现，全部都继承自抽象类java.lang.ClassLoader。</p>
<p>从开发人员的角度，加载器分为三种：</p>
<ol>
<li>启动类加载器(Bootstrap ClassLoader)；负责加载存放在%JAVA_HOME%\lib目录中的，或者通被-Xbootclasspath参数所指定的路径中的，并且被java虚拟机识别的(仅按照文件名识别，如rt.jar，名字不符合的类库，即使放在指定路径中也不会被加载)类库到虚拟机的内存中，启动类加载器无法被java程序直接引用。</li>
<li>扩展类加载器(Extension ClassLoader)：由sun.misc.Launcher$ExtClassLoader实现，负责加载%JAVA_HOME%\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器(Application ClassLoader)：应用程序类加载器，由sun.misc.Launcher$AppClassLoader实现，负责加载用户类路径classpath上所指定的类库，是类加载器ClassLoader中的getSystemClassLoader()方法的返回值，开发者可以直接使用应用程序类加载器，如果程序中没有自定义过类加载器，该加载器就是程序中默认的类加载器。</li>
</ol>
<h3 id="2-2、双亲委派模型"><a href="#2-2、双亲委派模型" class="headerlink" title="2.2、双亲委派模型"></a>2.2、双亲委派模型</h3><p>  <img src="https://github.com/paine1690/HelloWorld/blob/master/pic/jvm/3.png?raw=true" alt="3"></p>
<p>从JDK1.2开始，java虚拟机规范推荐开发者使用双亲委派模式(ParentsDelegation Model)进行类加载，其加载过程如下：</p>
<ol>
<li>如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器去完成。</li>
<li>每一层的类加载器都把类加载请求委派给父类加载器，直到所有的类加载请求都应该传递给顶层的启动类加载器。</li>
<li>如果顶层的启动类加载器无法完成加载请求，子类加载器尝试去加载，如果连最初发起类加载请求的类加载器也无法完成加载请求时，将会抛出ClassNotFoundException，而不再调用其子类加载器去进行类加载。</li>
</ol>
<p><strong>注意几点</strong>：</p>
<ol>
<li>这里类加载器之间的父子关系不是以继承的关系来实现，而是通过组合关系来复用父加载器的代码。</li>
<li>在JDK1.2之前，类加载尚未引入双亲委派模式，因此实现自定义类加载器时常常重写loadClass方法，提供双亲委派逻辑。从JDK1.2之后，双亲委派模式已经被引入到类加载体系中，自定义类加载器时不需要在自己写双亲委派的逻辑，因此不鼓励重写loadClass方法，而推荐重写findClass方法。<strong>在loadClass方法的逻辑里如果父类加载失败，就会调用自己的findClass()方法来完成加载</strong>。</li>
</ol>
<h2 id="3、类加载器的工作原理"><a href="#3、类加载器的工作原理" class="headerlink" title="3、类加载器的工作原理"></a>3、类加载器的工作原理</h2><p>类加载器的工作原理基于三个机制：委托、可见性和单一性。</p>
<ul>
<li><strong>委托机制</strong>：委托机制是指将加载一个类的请求交给父类加载器，如果这个父类加载器不能够找到或者加载这个类，那么再加载它。</li>
<li><strong>可见性</strong>：可见性的原理是子类的加载器可以看见所有的父类加载器加载的类，而父类加载器看不到子类加载器加载的类。</li>
<li><strong>单一性</strong>：单一性原理是指仅加载一个类一次，这是由委托机制确保子类加载器不会再次加载父类加载器加载过的类。</li>
</ul>
<h2 id="4、如何显示加载一个类"><a href="#4、如何显示加载一个类" class="headerlink" title="4、如何显示加载一个类"></a>4、如何显示加载一个类</h2><p>Java提供了显式加载类的API：Class.forName(classname)和Class.forName(classname, initialized, classloader)。就像上面的例子中，你可以指定类加载器的名称以及要加载的类的名称。类的加载是通过调用java.lang.ClassLoader的loadClass()方法，而loadClass()方法则调用了findClass()方法来定位相应类的字节码。</p>
<h2 id="5、参考地址"><a href="#5、参考地址" class="headerlink" title="5、参考地址"></a>5、参考地址</h2><p><a href="http://www.importnew.com/6581.html" target="_blank" rel="external">http://www.importnew.com/6581.html</a></p>
<p><a href="http://blog.csdn.net/p10010/article/details/50448491" target="_blank" rel="external">http://blog.csdn.net/p10010/article/details/50448491</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JVM垃圾回收机制]]></title>
      <url>http://yoursite.com/2016/11/02/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>Java的垃圾回收（Garbage Collection, GC）机制一直面试最常见的问题，谈到垃圾回收，首先应该想到的就是三个大问题：</p>
<ul>
<li>那些内存需要回收</li>
<li>如何回收</li>
<li>什么时候回收</li>
</ul>
<p>了解了这三个问题，就对jvm的内存机制有了整体的了解。接下来分别讨论下这三个问题。</p>
<h1 id="一、哪些内存需要回收"><a href="#一、哪些内存需要回收" class="headerlink" title="一、哪些内存需要回收"></a>一、哪些内存需要回收</h1><p>Java中几乎所有对象实例都存放在堆中，垃圾收集器在垃圾回收之前，首先要确定，哪些对象需要被回收。</p>
<h2 id="1、引用计数法"><a href="#1、引用计数法" class="headerlink" title="1、引用计数法"></a>1、引用计数法</h2><p>记得以前在高级操作系统的课上就背过引用计数法：</p>
<blockquote>
<p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数值就加1；档引用失效时，计数值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p>
</blockquote>
<p>这种方法简单高效，但是Java虚拟机中普遍没有采用这种方法，因为他无法解决<strong>对象间相互循环引用的问题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ListNode a=<span class="keyword">new</span> ListNode();</div><div class="line">      ListNode b=<span class="keyword">new</span> ListNode();</div><div class="line">      a.next=b;</div><div class="line">      b.next=a;</div><div class="line">      a=<span class="keyword">null</span>;</div><div class="line">      b=<span class="keyword">null</span>;</div></pre></td></tr></table></figure>
<p>在上面的代码中，对象a、b的next相互指向对方，除此之外再没有任何引用，实际上这两个对象已经不可能再被访问，然而如果采用引用计数法，两个对象的计数都不为0，因为他们互相指向对方，导致垃圾回收器无法回收他们。 </p>
<p>但是实际Java虚拟机中并不会出现这个问题，因为他们普遍采用的都是下面的方法。</p>
<h2 id="2、可达性分析算法"><a href="#2、可达性分析算法" class="headerlink" title="2、可达性分析算法"></a>2、可达性分析算法</h2><p>在主流的商用程序语言的主流实现中，都是采用可达性分析算法来判定对象是否存活的。</p>
<blockquote>
<p>这个算法的基本思想就是通过一系列成为”GC Roots“的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径成为引用链，档一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</p>
</blockquote>
<p> <img src="https://github.com/paine1690/HelloWorld/blob/master/pic/jvm/4.png?raw=true" alt="4"></p>
<p>例如上图所示，对象object5、object6、object7虽然互相有关联，但是他们到GC Roots是不可达的，所以他们将会被判定为是可回收的对象。</p>
<p>Java中，可以作为GC Roots的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地表量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（Native方法）引用的对象</li>
</ul>
<h2 id="3、死前的挣扎"><a href="#3、死前的挣扎" class="headerlink" title="3、死前的挣扎"></a>3、死前的挣扎</h2><p>一个对象并不是被判定为不可达，就一定会被回收，因为它还会经历一个<strong>两次标记的过程</strong></p>
<ol>
<li><p>第一次：判断为不可达后，会进行第一次标记，并进行筛选以判断该对象是否执行finalize()方法，筛选的条件是：</p>
<ul>
<li>对象没有覆盖finalize()方法</li>
<li>该对象的finalize()方法已经被虚拟机调用过</li>
</ul>
<p>这两种情况下，都不会再执行finalize()方法。 </p>
<p>当然，即使判定为有必要执行，虚拟机也不一定保证这个方法就一定会被完全执行。这里是我自己的理解，因为书中写到虚拟机会把它放在一个优先级比较低的线程中，并不承诺会等待它运行结束。<br>反正不管怎样，finalize()方法都是对象逃脱死亡的最后机会。</p>
</li>
<li><p>第二次：书上介绍的没有看太懂，我个人理解就是在执行finalize()的对象中小规模的标记，如果还是没有指向它，那么就会被清除。</p>
</li>
</ol>
<p>有一点值得注意的是很多书上都不推荐使用finalize()方法，所以我也没有进行深入的学习。</p>
<h1 id="二、如何回收"><a href="#二、如何回收" class="headerlink" title="二、如何回收"></a>二、如何回收</h1><p>确定哪些内存需要回收以后，就要知道虚拟机如何回收他们。这里主要需要掌握堆里面的新生代老年代和对应的回收算法两大部分。</p>
<p>由于Java中堆可以具体细分为：新生代和老年代；再向下还可以分为Eden,和Survivor空间，收集器针对不同代，采用不同的回收算法，即分代收集算法。</p>
<h2 id="1、标记清除算法"><a href="#1、标记清除算法" class="headerlink" title="1、标记清除算法"></a>1、标记清除算法</h2><p>分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。 </p>
<p> <img src="https://github.com/paine1690/HelloWorld/blob/master/pic/jvm/5.png?raw=true" alt="5"></p>
<p>该算法的缺点是效率不高并且会产生不连续的内存碎片。所以基本没有采用这种算法的。</p>
<h2 id="2、复制算法与新生代"><a href="#2、复制算法与新生代" class="headerlink" title="2、复制算法与新生代"></a>2、复制算法与新生代</h2><h3 id="2-1、复制算法"><a href="#2-1、复制算法" class="headerlink" title="2.1、复制算法"></a>2.1、复制算法</h3><p>把内存空间划为两个区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。次算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。 </p>
<ul>
<li>有点：实现简单，运行高效</li>
<li><p>缺点：会浪费一定内存</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/jvm/6.png?raw=true" alt="6"></p>
</li>
</ul>
<h3 id="2-2、新生代"><a href="#2-2、新生代" class="headerlink" title="2.2、新生代"></a>2.2、新生代</h3><p>现在虚拟机普遍采用复制算法来回收新生代。因为新生代的对象中，大部分都是“朝生夕死”的。所以，并不需要按照1：1的比例来分配。 </p>
<p> <img src="https://github.com/paine1690/HelloWorld/blob/master/pic/jvm/7.png?raw=true" alt="7"></p>
<p>新生代分为一块较大的Eden空间和两块较小的Survivor空间，两个Survivor分别叫做Survivor1，Survivor2，也叫做from和to。</p>
<p>当Eden区满执行GC的时候，将 Eden 区和 Survivor区中还存活着的对象一次性地复制到另一块Survivor(to)空间上，最后清理掉Eden和过程用过的Survivor(from)的空间。然后from和to对调，下次继续这样执行。</p>
<p>HotSpot虚拟机默认Eden和Survivor的大小比例是8:1:1，页就是每次新生代中可用的内存空间是整个新生代的90%(Eden和一个Survivor， 80%+10%)，只用10%的内存被“浪费”。</p>
<h2 id="3、标记-整理算法和老年代"><a href="#3、标记-整理算法和老年代" class="headerlink" title="3、标记-整理算法和老年代"></a>3、标记-整理算法和老年代</h2><p>复制算法在对象存活率较高时就要进行较多的复制操作，效率会变低。所以在老年代一般不采用这个算法。</p>
<p>根据老年代的特点，人们提出了“标记-整理”算法。过程与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。</p>
<p>  <img src="https://github.com/paine1690/HelloWorld/blob/master/pic/jvm/8.png?raw=true" alt="8"></p>
<h2 id="5、各个收集器"><a href="#5、各个收集器" class="headerlink" title="5、各个收集器"></a>5、各个收集器</h2><p>收集算法是内存回收的方法论，你们垃圾收集器就是内存回收的具体实现。书中详细介绍了各个收集器的特点和工作方式，这里参考其他博客简单整理记录一下。</p>
<ul>
<li>Serial收集器：新生代收集器，使用复制算法，使用一个线程进行GC，串行，其它工作线程暂停。</li>
<li>ParNew收集器：新生代收集器，使用复制算法，Serial收集器的多线程版，用多个线程进行GC，并行，其它工作线程暂停。使用-XX:+UseParNewGC开关来控制使用ParNew+Serial Old收集器组合收集内存；使用-XX:ParallelGCThreads来设置执行内存回收的线程数。</li>
<li>Parallel Scavenge 收集器：吞吐量优先的垃圾回收器，作用在新生代，使用复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间。使用-XX:+UseParallelGC开关控制使用Parallel Scavenge+Serial Old收集器组合回收垃圾。</li>
<li>Serial Old收集器：老年代收集器，单线程收集器，串行，使用标记整理算法，使用单线程进行GC，其它工作线程暂停。</li>
<li>Parallel Old收集器：吞吐量优先的垃圾回收器，作用在老年代，多线程，并行，多线程机制与Parallel Scavenge差不错，使用标记整理算法，在Parallel Old执行时，仍然需要暂停其它线程。</li>
<li>CMS（Concurrent Mark Sweep）收集器：老年代收集器，致力于获取最短回收停顿时间（即缩短垃圾回收的时间），使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。使用-XX:+UseConcMarkSweepGC进行ParNew+CMS+Serial Old进行内存回收，优先使用ParNew+CMS（原因见Full GC和并发垃圾回收一节），当用户线程内存不足时，采用备用方案Serial Old收集。</li>
<li>G1(Garbage-First)收集器，太多了，不想写了。</li>
</ul>
<h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p>上面介绍了分代回收算法，简单总结下自己的理解。</p>
<ul>
<li>堆内存分为新生代和老年代</li>
<li>GC的时候新生代采用复制算法，老年代采用标记-整理算法</li>
<li>不同的回收算法主要是针对两个代各自的特点，新生代的对象死亡率比较高，二老年代的对象死亡率相对比较低</li>
<li>关于如何判断对象进入新生代还是老年代，在下面详细介绍</li>
</ul>
<h1 id="三、什么时候回收"><a href="#三、什么时候回收" class="headerlink" title="三、什么时候回收"></a>三、什么时候回收</h1><p>比较常见的说法就是虚拟机会在系统空闲的时候进行垃圾回收，但这不够准确。其实上面时候进行回收确实是系统自身决定的，代码不可控制，System.gc()方法也仅仅是建议，但不一定会保证一定发生。</p>
<h2 id="1、新生代GC与老年代GC"><a href="#1、新生代GC与老年代GC" class="headerlink" title="1、新生代GC与老年代GC"></a>1、新生代GC与老年代GC</h2><p>Java的GC分为两种：新生代GC和老年代GC：</p>
<ul>
<li><strong>新生代GC(Minor GC)</strong>：指发生在新生代的垃圾收集动作，因为这里面对象都是“朝生夕死”的，所以Minor GC非常频繁，一般回收速度也比较快。</li>
<li><strong>老年代GC(Major GC/Full GC)</strong>：指发生在老年代的GC，出现Major GC经常会伴随至少一次的Minor GC(但不是绝对的)。</li>
</ul>
<h2 id="2、内存分配与回收策略"><a href="#2、内存分配与回收策略" class="headerlink" title="2、内存分配与回收策略"></a>2、内存分配与回收策略</h2><h3 id="2-1、Eden区与Minor-GC"><a href="#2-1、Eden区与Minor-GC" class="headerlink" title="2.1、Eden区与Minor GC"></a>2.1、Eden区与Minor GC</h3><p>大多数情况下，对象会在新生代的Eden区分配，当Eden没有足够的空间进行分配时，虚拟机将发起一次Minor GC。</p>
<p>值得注意的是，由于新生代采用的是复制算法，且两部分的内存是9:1，所以当较大的对象无法装入剩余的Survivor区时，该对象会通过分配担保机制提前被直接放入到老年代去。</p>
<h3 id="2-2、大对象直接进入老年代"><a href="#2-2、大对象直接进入老年代" class="headerlink" title="2.2、大对象直接进入老年代"></a>2.2、大对象直接进入老年代</h3><p>这里的大对象指的是大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。如果把它放在新生代，就会发生大量的内存复制。</p>
<p>所以可以设置参数 <strong>PretenureSizeThreshold</strong>，大于这个值的对象会直接分配到老年代中。</p>
<h3 id="2-3、长期存活对象进入老年代"><a href="#2-3、长期存活对象进入老年代" class="headerlink" title="2.3、长期存活对象进入老年代"></a>2.3、长期存活对象进入老年代</h3><p>这里终于要讲到为什么要叫新生代和老年代了。</p>
<p>Java虚拟机给每个对象定义了一个年龄计数器。如果对象在Eden出生并经过一次Minor GC之后仍然存活，对象年龄设为1，此后每经过一次Minor GC，也就是被复制一次，年龄就加一。</p>
<p>当年龄超过设定的参数值<strong>MaxTenuringThreshold</strong>，默认值为15，就会被晋升到老年代中。</p>
<h3 id="2-4、动态对象年龄判断"><a href="#2-4、动态对象年龄判断" class="headerlink" title="2.4、动态对象年龄判断"></a>2.4、动态对象年龄判断</h3><p>如果在Survivor空间中相同年龄的所有对象的大小综合超过了Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到MaxTenuringThreshold。</p>
<h3 id="2-5、空间担保分配"><a href="#2-5、空间担保分配" class="headerlink" title="2.5、空间担保分配"></a>2.5、空间担保分配</h3><p>上面讨论的一直都是Minor GC，那么什么时候才会执行Full GC呢，执行Full GC由于消耗的资源比较大，所以会比较谨慎，进行两次判断。</p>
<ul>
<li><p><strong>第一次判断</strong>：在发生Minor GC之前，虚拟机会检查老年代最大可用连续空间是否大于新生代所有对象的总空间，如果大于，那么Minor GC可以安全执行，没有必要执行Full GC。</p>
<p>但是，如果不成立，那么就可能有必要执行一次Full GC以清除老年代的垃圾。</p>
<p>那么，是不是一定就会执行Full GC呢，还是不一定的，因为虽然现在老年代无法容纳所有新生代的内存，但是大部分情况下新生代的内存都会被清理很多的，所以万一新生代需要进入老年代的内存只占其中一小部分呢，那么就不用执行Full GC了啊，当然，这在运行时无法确定，需要冒险。 </p>
</li>
<li><p><strong>第二次判断</strong>：有一个参数<strong>HandlePromotionFailure</strong>的作用就是设置是不是要冒险，如果设置为可以冒险，那么会那么会继续检查老年代最大可用的连续空间，判断它是否大于历次晋升到老年代对象的平均大小，也就是大致评估一下这次冒险的成功率，如果如果大于，说明冒险的成功率比较高，那么就不会执行Full GC。</p>
<p>如果设置为不可以冒险，或者冒险的成功率比较低，那么久会老老实实的执行Full GC。</p>
<p>最后，如果冒险失败，那么最后还是会进行Full GC。</p>
</li>
</ul>
<p>可以看出，虚拟机执行Full GC是非常谨慎的，不到万不得已绝不执行，就是因为这个过程非常浪费资源，Full GC的速度一般会比Minor GC慢10倍以上。</p>
<h1 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h1><p><a href="http://yemengying.com/2016/05/13/jvm-GC/" target="_blank" rel="external">http://yemengying.com/2016/05/13/jvm-GC/</a></p>
<p><a href="http://icyfenix.iteye.com/blog/715301" target="_blank" rel="external">http://icyfenix.iteye.com/blog/715301</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[浅析HTTPS协议]]></title>
      <url>http://yoursite.com/2016/10/31/ComputerNetworking/HTTPS/</url>
      <content type="html"><![CDATA[<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="1、HTTPS"><a href="#1、HTTPS" class="headerlink" title="1、HTTPS"></a>1、HTTPS</h2><p>HTTPS，也称作HTTP over TLS。TLS的前身是SSL。<strong>端口为443</strong>。</p>
<p>下图描述了在TCP/IP协议栈中TLS(各子协议）和HTTP的关系</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/ComputerNetworking/10.png?raw=true" alt=""></p>
<p>其中Handshake protocol，Change Ciper Spec protocol和Alert protocol组成了SSL Handshaking Protocols。</p>
<p>HTTPS和HTTP协议相比提供了</p>
<ol>
<li>数据完整性：内容传输经过完整性校验</li>
<li>数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥</li>
<li>身份认证：第三方无法伪造服务端（客户端）身份</li>
</ol>
<p>其中，数据完整性和隐私性由TLS Record Protocol保证，身份认证由TLS Handshaking Protocols实现。</p>
<h2 id="2、对称加密"><a href="#2、对称加密" class="headerlink" title="2、对称加密"></a>2、对称加密</h2><p>对称密钥（Symmetric-key algorithm）又称为共享密钥加密，对称密钥在加密和解密的过程中使用的密钥是相同的。对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。</p>
<h3 id="2-1、常见算法"><a href="#2-1、常见算法" class="headerlink" title="2.1、常见算法"></a>2.1、常见算法</h3><ul>
<li>DES</li>
<li>3DES</li>
<li>AES</li>
<li>RC5</li>
<li>RC6</li>
</ul>
<h3 id="2-2、优点与缺点"><a href="#2-2、优点与缺点" class="headerlink" title="2.2、优点与缺点"></a>2.2、优点与缺点</h3><p>优点: </p>
<ul>
<li>加/解密速度快</li>
<li>密钥管理简单</li>
<li>适宜一对一的信息加密传输 </li>
</ul>
<p>缺点：</p>
<ul>
<li>加密算法简单，密钥长度有限（56比特/128比特）加密强度不高</li>
<li>密钥分发困难，不适宜一对多的加密信息传输。</li>
</ul>
<h2 id="3、非对称加密"><a href="#3、非对称加密" class="headerlink" title="3、非对称加密"></a>3、非对称加密</h2><p>非对称密钥（public-key cryptography），又称为公开密钥加密，服务端会生成一对密钥，一个私钥保存在服务端，仅自己知道，另一个是公钥，公钥可以自由发布供任何人使用。</p>
<h3 id="3-1、常见算法"><a href="#3-1、常见算法" class="headerlink" title="3.1、常见算法"></a>3.1、常见算法</h3><ul>
<li>RSA：算法实现简单，诞生于 1977 年，历史悠久，经过了长时间的破解测试，安全性高。缺点就是需要比较大的素数（目前常用的是 2048 位）来保证安全强度，很消耗 CPU 运算资源。RSA 是目前唯一一个既能用于密钥交换又能用于证书签名的算法。</li>
<li>D-H：diffie-hellman 密钥交换算法（迪菲－赫尔曼密钥交换），诞生时间比较早（1977 年），但是 1999 年才公开。缺点是比较消耗 CPU 性能。</li>
<li>Elgamal、背包算法、Rabin、ECC等</li>
</ul>
<p>其中最著名的应该是RSA和迪菲－赫尔曼算法了。</p>
<h3 id="3-2、优点与缺点"><a href="#3-2、优点与缺点" class="headerlink" title="3.2、优点与缺点"></a>3.2、优点与缺点</h3><p>优点: </p>
<ul>
<li>更加安全</li>
</ul>
<p>缺点：</p>
<ul>
<li>加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</li>
</ul>
<h3 id="3-3、加密过程举例"><a href="#3-3、加密过程举例" class="headerlink" title="3.3、加密过程举例"></a>3.3、加密过程举例</h3><ol>
<li>服务端生成配对的公钥和私钥</li>
<li>私钥保存在服务端，公钥发送给客户端</li>
<li>客户端使用公钥加密明文传输给服务端</li>
<li>服务端使用私钥解密密文得到明文</li>
</ol>
<ul>
<li>登陆用户：小明</li>
<li>授权网站：某知名社交网站（以下简称XX）</li>
</ul>
<p>小明都是某知名社交网站XX的用户，XX出于安全考虑在登陆的地方用了非对称加密。小明在登陆界面敲入账号、密码，点击“登陆”。于是，浏览器利用公钥对小明的账号密码进行了加密，并向XX发送登陆请求。XX的登陆授权程序通过私钥，将账号、密码解密，并验证通过。之后，将小明的个人信息（含隐私），通过私钥加密后，传输回浏览器。浏览器通过公钥解密数据，并展示给小明。</p>
<ul>
<li>步骤一： 小明输入账号密码 –&gt; 浏览器用公钥加密 –&gt; 请求发送给XX</li>
<li>步骤二： XX用私钥解密，验证通过 –&gt; 获取小明社交数据，用私钥加密 –&gt; 浏览器用公钥解密数据，并展示。</li>
</ul>
<p>用非对称加密，就能解决数据传输安全的问题了吗？前面特意强调了一下，私钥加密的数据，公钥是可以解开的，而公钥又是加密的。也就是说，非对称加密只能保证单向数据传输的安全性。</p>
<h3 id="3-4、公开密钥加密的两个问题"><a href="#3-4、公开密钥加密的两个问题" class="headerlink" title="3.4、公开密钥加密的两个问题"></a>3.4、公开密钥加密的两个问题</h3><ol>
<li><p>公钥如何获取：</p>
<p>浏览器是怎么获得XX的公钥的？当然，小明可以自己去网上查，XX也可以将公钥贴在自己的主页。然而，对于一个动不动就成败上千万的社交网站来说，会给用户造成极大的不便利，毕竟大部分用户都不知道“公钥”是什么东西。</p>
</li>
<li><p>数据传输仅单向安全：前面提到，公钥加密的数据，只有私钥能解开，于是小明的账号、密码是安全了，半路不怕被拦截。</p>
<p>然后有个很大的问题：<strong>私钥加密的数据，公钥也能解开</strong>。加上公钥是公开的，小明的隐私数据相当于在网上换了种方式裸奔。（中间代理服务器拿到了公钥后，毫不犹豫的就可以解密小明的数据）</p>
</li>
</ol>
<p>针对这两个问题，需要介绍下面的两个概念</p>
<h2 id="4、数字签名"><a href="#4、数字签名" class="headerlink" title="4、数字签名"></a>4、数字签名</h2><p>除了上面提到的加密解密报文之外，还可以用加密系统对报文进行<strong>签名</strong>，以说明是谁编写的报文，同时证明报文未被篡改过。这种技术被称为<strong>数字签名</strong>。</p>
<h3 id="4-1、定义"><a href="#4-1、定义" class="headerlink" title="4.1、定义"></a>4.1、定义</h3><p>将报文按双方约定的HASH算法计算得到一个固定位数的报文摘要。在数学上保证：只要改动报文中任何一位，重新计算出的报文摘要值就会与原先的值不相符。这样就保证了报文的不可更改性。</p>
<p>将该报文摘要值用发送者的私人密钥加密，然后连同原报文一起发送给接收者，而产生的报文即称数字签名</p>
<h3 id="4-2、好处"><a href="#4-2、好处" class="headerlink" title="4.2、好处"></a>4.2、好处</h3><p>数字签名有两点好处：</p>
<ul>
<li><p>签名可以证明是作者编写了这条报文。</p>
<p>只有作者才会有最机密的私有密钥，因此，只有作者才能计算出这些校验和。校验和就像来自作者的个人“签名”一样。</p>
</li>
<li><p>签名可以防止报文被篡改。</p>
<p>如果有恶意攻击者在报文传输过程中对其进行了修改，校验和就不再匹配了，由于校验和只有作者保密的私有密钥才能产生，所以攻击者无法为篡改了的报文伪造出正确的校验和。</p>
<p>工作过程如下：</p>
</li>
</ul>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/ComputerNetworking/9.jpg?raw=true" alt="105572559931273736"></p>
<h2 id="5、数字证书"><a href="#5、数字证书" class="headerlink" title="5、数字证书"></a>5、数字证书</h2><p>数字证书就是互联网通讯中标志通讯各方身份信息的一系列数据，提供了一种在Internet上验证您身份的方式，其作用类似于司机的驾驶执照或日常生活中的身份证。它是由一个由权威机构—–CA机构，又称为证书授权（Certificate Authority）中心发行的，人们可以在网上用它来识别对方的身份。数字证书是一个经证书授权中心数字签名的包含公开密钥拥有者信息以及公开密钥的文件。最简单的证书包含一个公开密钥、名称以及证书授权中心的数字签名。</p>
<p>证书的内容</p>
<ol>
<li>颁发证书的机构的名字 – CA</li>
<li>证书内容本身的数字签名（用CA私钥加密）</li>
<li>证书签名用到的hash算法</li>
<li>证书持有者的公钥</li>
</ol>
<p>个人理解，前三项是用于证书身份的验证，而最后一个则是证书中包含的内容，因为证书的意义就是服务器返回的一个公钥，而前三项则用于验证这个公钥确实是由服务器返回的并且没有被篡改。</p>
<p>保证这个证书是服务器返回的并且没有被篡改的关键在于浏览器之中内置的CA的根证书，其中包含了CA的公钥，这样通过前三项就能保证证书的正确性。</p>
<h2 id="6、数字签名与数字证书"><a href="#6、数字签名与数字证书" class="headerlink" title="6、数字签名与数字证书"></a>6、数字签名与数字证书</h2><p>再理解以下数字签名与数字证书的意义。</p>
<p>首先数字签名的意义就是两点，证明作者身份并且保证数据没有被篡改，它通过hash摘要与非对称加密来实现，但是它的实现由个前提就是接受者必须有正确的公钥，理论上说，如果接受者有所有发送者的公钥并且保证这些公钥的正确性，就不需要数字证书了，但是接受者不可能保存所有的发送者的公钥，它只能保存有限的公钥，并且在通信的时候利用这些有限的公钥来获取发送者的公钥。</p>
<p>所以数字证书就出现了，个人理解它本质上也是一个数字签名，利用上面说的发送者能保存的有限个公钥，来保存CA根证书的公钥，这样就能保证CA根证书机构发送的数据一定是正确且身份明确的，然后再通过这些CA的证书来发送临时的公钥，相当于递归的确认。</p>
<p>通过对数字签名与证书的介绍，就可以解决上面提出的两个问题了</p>
<ul>
<li><p>公钥如何获取：</p>
<p>通过根证书和数字签名技术，来获取公钥。</p>
</li>
<li><p>数据传输的单向安全：</p>
<p>使用对称加密。而非对称加密主要用于上面公钥的获取。</p>
</li>
</ul>
<p>这样再看一下整个加密通信的流程：</p>
<ol>
<li>小明访问服务器，服务器将自己的证书给到小明（其实是给到浏览器，小明不会有感知）</li>
<li>浏览器首先验证证书的合法性。通过浏览器内置的CA根证书的公钥来验证证书的数字签名，确定改证书是由CA办法并且没有被篡改的。</li>
<li>浏览器从证书中拿到服务器的公钥A</li>
<li>浏览器生成一个只有自己自己的对称密钥B，用公钥A加密，并传给服务器（其实是有协商的过程，这里为了便于理解先简化）</li>
<li>服务器通过私钥解密，拿到对称密钥B</li>
<li>浏览器与服务器之后的数据通信，都用密钥B进行加密</li>
</ol>
<p>注意：对于每个访问服务器的用户，生成的对称密钥B理论上来说都是不一样的。比如小明、小王、小光，可能生成的就是B1、B2、B3.</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/ComputerNetworking/11.png?raw=true" alt=""></p>
<p>可以看出，整个过程中结合了公钥加密与私钥加密各自的特点，通过二者的配合来保证数据的完整性、隐私性以及身份验证三个特性。</p>
<h1 id="二、工作过程"><a href="#二、工作过程" class="headerlink" title="二、工作过程"></a>二、工作过程</h1><p>下面来看一下HTTPS的工作过程</p>
<h2 id="1、基本过程"><a href="#1、基本过程" class="headerlink" title="1、基本过程"></a>1、基本过程</h2><p>SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p>
<p>但是，这里有两个问题。</p>
<ol>
<li><p>如何保证公钥不被篡改？</p>
<p>解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p>
</li>
<li><p>公钥加密计算量太大，如何减少耗用的时间？</p>
<p>解决方法：每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。</p>
</li>
</ol>
<p>基本过程是这样的：</p>
<ol>
<li>客户端向服务器端索要并验证公钥。</li>
<li>双方协商生成”对话密钥”。</li>
<li>双方采用”对话密钥”进行加密通信。</li>
</ol>
<p>上面过程的前两步，又称为”握手阶段”（handshake）。</p>
<h2 id="2、握手阶段"><a href="#2、握手阶段" class="headerlink" title="2、握手阶段"></a>2、握手阶段</h2><p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/ComputerNetworking/12.png?raw=true" alt=""></p>
<p>握手阶段涉及四次通信，这个阶段的通信都是明文的。</p>
<h3 id="2-1、客户端-ClientHello"><a href="#2-1、客户端-ClientHello" class="headerlink" title="2.1、客户端 ClientHello"></a>2.1、客户端 ClientHello</h3><p>首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。</p>
<p>在这一步，客户端主要向服务器提供以下信息:</p>
<ol>
<li>支持的协议版本，比如TLS 1.0版。</li>
<li>一个客户端生成的随机数，稍后用于生成”对话密钥”。(标记为随机数1)</li>
<li>支持的加密方法，比如RSA公钥加密。</li>
<li>支持的压缩方法。</li>
</ol>
<h3 id="2-2、服务器回应-ServerHello"><a href="#2-2、服务器回应-ServerHello" class="headerlink" title="2.2、服务器回应 ServerHello"></a>2.2、服务器回应 ServerHello</h3><p>服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。</p>
<p>服务器的回应包含以下内容：</p>
<ol>
<li>确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。</li>
<li>一个服务器生成的随机数，稍后用于生成”对话密钥”。(标记为随机数2)</li>
<li>确认使用的加密方法，比如RSA公钥加密。</li>
<li>服务器证书。</li>
</ol>
<p>除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。</p>
<h3 id="2-3、客户端回应"><a href="#2-3、客户端回应" class="headerlink" title="2.3、客户端回应"></a>2.3、客户端回应</h3><p>客户端收到服务器回应以后，首先验证服务器证书。</p>
<ul>
<li>如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</li>
<li>如果证书没有问题，客户端就会从证书中取出服务器的公钥。</li>
</ul>
<p>然后，向服务器发送下面三项信息：</p>
<ol>
<li>一个随机数。该随机数用服务器公钥加密，防止被窃听。(标记为pre-master key，前主密钥)</li>
<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</li>
<li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</li>
</ol>
<p>此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。</p>
<p>上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称”pre-master key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”会话密钥”。</p>
<p>为什么一定要用三个随机数，来生成”会话密钥”？</p>
<blockquote>
<p>“不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。</p>
<p>对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。</p>
<p>pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么使用用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。”</p>
</blockquote>
<h3 id="2-4、服务器最后的回应"><a href="#2-4、服务器最后的回应" class="headerlink" title="2.4、服务器最后的回应"></a>2.4、服务器最后的回应</h3><p>服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。</p>
<p>然后，向客户端最后发送下面信息。</p>
<ol>
<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</li>
<li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</li>
</ol>
<p>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。</p>
<h1 id="三、参考地址"><a href="#三、参考地址" class="headerlink" title="三、参考地址"></a>三、参考地址</h1><p><a href="http://www.codeceo.com/article/https-worker.html" target="_blank" rel="external">http://www.codeceo.com/article/https-worker.html</a></p>
<p><a href="http://blog.jobbole.com/107930/" target="_blank" rel="external">http://blog.jobbole.com/107930/</a></p>
<p><a href="http://www.cnblogs.com/chyingp/p/https-introduction.html" target="_blank" rel="external">http://www.cnblogs.com/chyingp/p/https-introduction.html</a></p>
<p><a href="http://blog.csdn.net/oscar999/article/details/9364101" target="_blank" rel="external">http://blog.csdn.net/oscar999/article/details/9364101</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[浅析TCP协议]]></title>
      <url>http://yoursite.com/2016/10/31/ComputerNetworking/tcp/</url>
      <content type="html"><![CDATA[<h1 id="一、TCP简介"><a href="#一、TCP简介" class="headerlink" title="一、TCP简介"></a>一、TCP简介</h1><h2 id="1、TCP与UDP"><a href="#1、TCP与UDP" class="headerlink" title="1、TCP与UDP"></a>1、TCP与UDP</h2><p>TCP与UDP作为运输层的协议，经常被用来比较，它们有着各自的特点。</p>
<p><strong>UDP</strong>是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。</p>
<ul>
<li>UDP是无连接的，因此在两个进程通信前没有握手过程。</li>
<li>UDP提供不可靠的数据传送服务。</li>
<li>UDP也不保证输出顺序。</li>
</ul>
<p><strong>TCP</strong>是因特网运输层的面向连接的可靠的运输协议，主要有一下几个特点</p>
<ol>
<li>面向连接的服务：在应用层的数据报开始流动之前，TCP让客户和服务器之间相互交换运输层控制信息。在握手阶段后，一个TCP连接就在两个进程的套接字之间建立了。而且这条接连是全双工的。</li>
<li>可靠的数据传送服务：通信进程能够依靠TCP<strong>无差错、按适当顺序</strong>交付所有发送的数据。</li>
<li>TCP还具有拥塞控制机制，这种机制虽然不一定能为通信进程带来直接好处，但能为因特网带来整体好处。</li>
</ol>
<h2 id="2、TCP报文"><a href="#2、TCP报文" class="headerlink" title="2、TCP报文"></a>2、TCP报文</h2><p> <img src="https://github.com/paine1690/HelloWorld/blob/master/pic/ComputerNetworking/3.png?raw=true" alt="pic3"></p>
<p>上图为TCP报文段结构，一般TCP的首部是20个字节，而UDP只有8个字节。</p>
<p>具体的含义不用每个都知道，了解几个比较常用的就可以了。</p>
<h3 id="源端口与目的端口"><a href="#源端口与目的端口" class="headerlink" title="源端口与目的端口"></a>源端口与目的端口</h3><p>主要用于多路复用与分解</p>
<h3 id="序号和确认号"><a href="#序号和确认号" class="headerlink" title="序号和确认号"></a>序号和确认号</h3><p>序号和确认号TCP报文段首部中两个最重要的字段，它们是TCP可靠传输的关键部分。</p>
<p>序列号用来标识TCP发端向TCP收端发送的数据字节流。</p>
<p>确认号只有在ACK标志位为1的时候才有效。同时，它也表示从期望接收端接收的下一个字节的序列号</p>
<h3 id="标志字段"><a href="#标志字段" class="headerlink" title="标志字段"></a>标志字段</h3><p>ACK用于指示确认号是有效的，即该报文包括一个对已被接收报文段的确认。</p>
<p>RST、SYN、FIN用于连接建立和拆除，也就是三次握手和四次挥手。</p>
<h1 id="二、连接管理"><a href="#二、连接管理" class="headerlink" title="二、连接管理"></a>二、连接管理</h1><h2 id="1、三次握手"><a href="#1、三次握手" class="headerlink" title="1、三次握手"></a>1、三次握手</h2><p>接下来就是最著名的TCP三次握手</p>
<p> <img src="https://github.com/paine1690/HelloWorld/blob/master/pic/ComputerNetworking/4.png?raw=true" alt="pic4"></p>
<ul>
<li><p><strong>第一步：</strong> 客户端TCP向服务器发送一个特殊的TCP报文。该报文不含应用层数据，但有两个关键信息。将首部中一个标志位SYN置为1，因此称此报文段为SYN报文段。另外，客户端会随机选取（为了避免安全性攻击）一个初始序列号client_isn，一起发送给服务器端。</p>
</li>
<li><p><strong>第二步：</strong> 服务器端接收到该SYN报文段后，就会分配TCP缓存和变量（没错，在三次握手完成之前就会分配缓存和变量，这也使得TCP容易遭受SYN洪泛攻击），然后返回一个也是不含应用层信息的报文段。</p>
<p>这个报文段包含三个重要信息：首先，SYN比特位被置为1。其次，报文段的确认号字段被置为client_isn+1。最后，服务器选择自己的初始序列号server_isn。这个报文段被称为SYNACK报文段。</p>
</li>
<li><p><strong>第三步：</strong> 在收到SYNACK报文段后，客户端也开始分配缓存和变量，然后再向服务器发送最后一个确认报文段。因为连接已经建立，所以SYN会置为0，然后将server_isn+1作为确认号字段。</p>
</li>
</ul>
<h2 id="2、SYN洪泛攻击"><a href="#2、SYN洪泛攻击" class="headerlink" title="2、SYN洪泛攻击"></a>2、SYN洪泛攻击</h2><p><strong>攻击原理：</strong></p>
<p>SYN Flood是当前最流行的DoS（拒绝服务攻击）与DDoS（分布式拒绝服务攻击）的方式之一，这是一种利用TCP协议缺陷，发送大量伪造的TCP连接请求，常用假冒的IP或IP号段发来海量的请求连接的第一个握手包（SYN包），被攻击服务器回应第二个握手包（SYN+ACK包），因为对方是假冒IP，对方永远收不到包且不会回应第三个握手包。导致被攻击服务器保持大量SYN_RECV状态的“半连接”，并且会重试默认5次回应第二个握手包，塞满TCP等待连接队列，资源耗尽（CPU满负荷或内存不足），让正常的业务请求连接不进来。</p>
<p><strong>防御手段：</strong></p>
<p>一种比较有效的防御手段就是SYN cookie。</p>
<ul>
<li><p>当服务器收到一个SYN请求时，它并不知道这个请求是合法的还是攻击的，所以它不会直接分配缓存和变量。而是生成一个初始的TCP序列号，该序列号由SYN请求报文段的源和目的IP与端口号以及仅有服务器知道的秘密数经过一个复杂的哈希函数计算而成。这个被精心计算出来的序列号就被称为“cookie”，服务器将含有这个cookie的SYNACK分组返回给客户端。</p>
</li>
<li><p>如果客户是合法的，那么它将会返回一个ACK报文段。服务器收到ACK后需要验证它与前面的某个SYN是对应的，这时就要用到上面的cookie了。</p>
<p>一个合法的ACK的确认字段，肯定是服务器返回的SYNACK中序号字段（就是上面计算出来的cookie）的值+1。所以服务器只需要再次根据源和目的IP与端口号按照上面的方法计算出cookie，因为源和目的IP与端口号没有改变，所以计算出来的cookie肯定与上面的相同，如果这个cookie值+1与ACK报文段中的确认字段相等，你们服务器就认为该ACK对应于前面的SYN，因此它是合法的。然后生成一个具有套接字的全开连接。</p>
<p>如果客户是非法的也就是没有返回ACK报文段，那么服务器也并没有为它分配任何资源。</p>
<p>​</p>
</li>
</ul>
<h2 id="3、四次挥手"><a href="#3、四次挥手" class="headerlink" title="3、四次挥手"></a>3、四次挥手</h2><p>接下来看一下TCP断开连接的过程，需要注意的一点是下图中的客户端与服务器不是绝对的，实际情况中任何一端都可以请求中断，我们习惯把先请求中断的叫做客户端。</p>
<p> <img src="https://github.com/paine1690/HelloWorld/blob/master/pic/ComputerNetworking/5.png?raw=true" alt="pic5"></p>
<ul>
<li>首先，客户端发送一个特殊的报文段，将首部中的FIN标志位置为1，说明客户端已经没有数据要发送了。该报文段也叫FIN报文段。</li>
<li>服务器接受到FIN报文段后，回复一个确认报文段。但是服务器仍然可以向客户端发送数据。</li>
<li>当服务器也没有数据要发送了，就会同样向客户端发送一个FIN报文段。</li>
<li>最后，客户端对这个FIN报文段进行确认，在上图中可以看到，客户端发送ACK后没有直接关闭，而是计时等待一段时间后再关闭。最后，两台主机上的所有资源都被释放了。</li>
</ul>
<h2 id="3、状态序列"><a href="#3、状态序列" class="headerlink" title="3、状态序列"></a>3、状态序列</h2><p>整个过程Client端所经历的状态如下：</p>
<p> <img src="https://github.com/paine1690/HelloWorld/blob/master/pic/ComputerNetworking/7.png?raw=true" alt="pic7"></p>
<p>而Server端所经历的过程如下：</p>
<p> <img src="https://github.com/paine1690/HelloWorld/blob/master/pic/ComputerNetworking/6.png?raw=true" alt="pic6"></p>
<h2 id="4、常见问题"><a href="#4、常见问题" class="headerlink" title="4、常见问题"></a>4、常见问题</h2><h3 id="4-1、为什么是三次握手而不是两次？"><a href="#4-1、为什么是三次握手而不是两次？" class="headerlink" title="4.1、为什么是三次握手而不是两次？"></a>4.1、为什么是三次握手而不是两次？</h3><p>直接引用谢希仁版《计算机网络》中的例子:</p>
<blockquote>
<p>“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送ack包。</p>
</blockquote>
<h3 id="4-2、为什么是四次挥手三次握手"><a href="#4-2、为什么是四次挥手三次握手" class="headerlink" title="4.2、为什么是四次挥手三次握手"></a>4.2、为什么是四次挥手三次握手</h3><p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
<h3 id="4-3、计时等待"><a href="#4-3、计时等待" class="headerlink" title="4.3、计时等待"></a>4.3、计时等待</h3><p>在第四步中，客户端发送ACK报文段后会进入TIME_WAIT状态，这是因为如果客户端的ACK如果丢失了，它将重新发送，TIME_WAIT状态中所需要的时间是依赖于实现方法的。典型的值为30秒、1分钟和2分钟。等待之后连接正式关闭，并且所有的资源(包括端口号)都被释放。</p>
<h3 id="4-4、CLOSE-WAIT状态"><a href="#4-4、CLOSE-WAIT状态" class="headerlink" title="4.4、CLOSE_WAIT状态"></a>4.4、CLOSE_WAIT状态</h3><p>在小米一面的时候面试官问知不知道CLOSE_WAIT状态，我回答说是四次挥手中的状态，然后解释了四次挥手的全过程。不知道面试官想问的到底是什么，后来上网查了一下发现关于这个状态是有一个比较常见的问题的，在这个<a href="http://blog.csdn.net/ximenying/article/details/1489810" target="_blank" rel="external">http://blog.csdn.net/ximenying/article/details/1489810</a>链接中。</p>
<p>问题描述：</p>
<blockquote>
<p>不久前，我的Socket Client程序遇到了一个非常尴尬的错误。它本来应该在一个socket长连接上持续不断地向服务器发送数据，如果socket连接断开，那么程序会自动不断地重试建立连接。</p>
<p>有一天发现程序在不断尝试建立连接，但是总是失败。用netstat查看，这个程序竟然有上千个socket连接处于CLOSE_WAIT状态，以至于达到了上限，所以无法建立新的socket连接了。</p>
</blockquote>
<p>CLOSE_WAIT产生的原因：</p>
<blockquote>
<p>当发起主动关闭的左边这方发送一个FIN过去后，右边被动关闭的这方要回应一个ACK，这个ACK是TCP回应的，而不是应用程序发送的，此时，被动关闭的一方就处于CLOSE_WAIT状态了。如果此时被动关闭的这一方不再继续调用closesocket,那么他就不会发送接下来的FIN，导致自己老是处于CLOSE_WAIT。只有被动关闭的这一方调用了closesocket,才会发送一个FIN给主动关闭的这一方，同时也使得自己的状态变迁为LAST_ACK。</p>
</blockquote>
<p>我觉得产生这个的原因应该就是：<strong>一端的Socket调用close后，另一端的Socket没有调用close</strong></p>
<h3 id="4-5、长连接与短连接"><a href="#4-5、长连接与短连接" class="headerlink" title="4.5、长连接与短连接"></a>4.5、长连接与短连接</h3><p>面试官在问完上面那个问题后又问我知不知道长连接与短连接，所以我觉得这两者之间应该是有关联的面试官在提示我，上面那个问题描述中也说到socket长连接上不断发送数据，二者的定义如下：</p>
<ul>
<li>长连接：client方与server方先建立连接，连接建立后不断开，然后再进行报文发送和接收。这种方式下由于通讯连接一直存在。此种方式常用于P2P通信。</li>
<li>短连接：Client方与server每进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此方式常用于一点对多点通讯。</li>
</ul>
<p>操作过程：</p>
<ul>
<li>短连接：建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接</li>
<li>长连接：建立连接——数据传输…（保持连接）…数据传输——关闭连接</li>
</ul>
<p>使用时机：</p>
<ul>
<li>长连接：短连接多用于操作频繁，点对点的通讯，而且连接数不能太多的情况。每个TCP连接的建立都需要三次握手，每个TCP连接的断开要四次握手。如果每次操作都要建立连接然后再操作的话处理速度会降低，所以每次操作下次操作时直接发送数据就可以了，不用再建立TCP连接。</li>
<li>短连接：web网站的http服务一般都用短连接。因为长连接对于服务器来说要耗费一定的资源。像web网站这么频繁的成千上万甚至上亿客户端的连接用短连接更省一些资源。<br>试想如果都用长连接，而且同时用成千上万的用户，每个用户都占有一个连接的话，可想而知服务器的压力有多大。所以并发量大，但是每个用户又不需频繁操作的情况下需要短连接。总之：长连接和短连接的选择要视需求而定。</li>
</ul>
<h1 id="三、流量控制"><a href="#三、流量控制" class="headerlink" title="三、流量控制"></a>三、流量控制</h1><p>前面提到TCP在主机会建立缓存来接收数据，然后应用程序从缓存中将接收到的数据读出，所以如果应用程序由于某种原因无法立刻读取数据，而发送方又一直发送数据，就会使缓存溢出。在UDP中，这种现象确实会发生，但是TCP就不会，因为为了防止这种情况，TCP为应用程序提供了流量控制服务。</p>
<h2 id="1、作用"><a href="#1、作用" class="headerlink" title="1、作用"></a>1、作用</h2><p>流量控制很容易与下面的拥塞控制混淆，虽然它们都是用于决定向对方发送数据的速率，但是它们是针对完全不同的原因而采取的措施。</p>
<p><strong>流量控制</strong>是为了防止接收方缓存溢出而对发送方进行遏制。</p>
<p><strong>拥塞控制</strong>是防止IP网络拥塞而对发送方进行遏制。</p>
<h2 id="2、原理"><a href="#2、原理" class="headerlink" title="2、原理"></a>2、原理</h2><p>TCP通过让发送方维护一个称为<strong>接收窗口(rwnd)</strong>的变量来提供流量控制。它表示接收方还有多少可用的缓存空间。</p>
<p>以主机A与B的TCP连接为例</p>
<ul>
<li>主机B把当前的rwnd值放入发送给A的报文段接收串口字段中，通知A它在该连接中还有多少缓存可用。</li>
<li>A维护两个变量，表示A发送到连接中但是没有被确认的数据量，通过将未确认的数据量控制在rwnd以内，就可以保证A不会使B的接收缓存溢出。</li>
<li>有一个小问题就是当B的接收缓存已满使得rwnd为0，那么A就不会再向B发送数据。这时如果B没有其他数据发送到A，那么即使它缓存出现空闲可以继续接收它也无法通知A，就会导致A一直无法发送数据。为例防止这种情况，TCP规范中要求：当B的接收窗口为0时，A继续发送只有一个字节数据的报文段。这些报文段会被接收方确认，如果缓存出现空闲，那么确认报文段中将含有一个非0的rwnd值，连接就可以继续了。</li>
</ul>
<h1 id="四、拥塞控制"><a href="#四、拥塞控制" class="headerlink" title="四、拥塞控制"></a>四、拥塞控制</h1><p>TCP还拥有拥塞控制机制，通过让发送方根据所感知到的网络拥塞程度来限制其能向连接方发送流量的速率。要实现该机制，只要考虑一下三个问题</p>
<h2 id="1、发送方如何限制发送速率"><a href="#1、发送方如何限制发送速率" class="headerlink" title="1、发送方如何限制发送速率"></a>1、发送方如何限制发送速率</h2><p>TCP的发送方还会维持一个变量叫<strong>拥塞窗口(cwnd)</strong>，它与上面的rwnd很相似，都是对TCP发送方能向网络中发送的流量进行限制。在一个发送方中未被确认的数据量不会超过cwnd与rwnd的最小值。</p>
<h2 id="2、如何感知网络拥堵"><a href="#2、如何感知网络拥堵" class="headerlink" title="2、如何感知网络拥堵"></a>2、如何感知网络拥堵</h2><p>首先定义发送方<strong>丢包事件</strong>：要么出现超时，要么收到来自接收方的3个冗余ACK。</p>
<p>当出现过度拥塞时，沿着这条路径上的一台或多台路由器会出现缓存溢出，导致数据报被丢弃。丢弃的数据报会引发发送方的丢包事件，发送方就认为路径上出现了拥塞。</p>
<h2 id="3、控制速率算法"><a href="#3、控制速率算法" class="headerlink" title="3、控制速率算法"></a>3、控制速率算法</h2><p>TCP的拥塞控制算法很复杂，恕我表达能力有限，不想写了。记住几个关键词就行了，慢启动、拥塞避免和快速恢复。</p>
<p><strong>慢启动</strong>：当TCP连接开始时，cwnd的值通常被初始化为一个非常小的值，如果没有拥塞就直接翻倍，也就是说虽然发送速率起始很慢，但是在慢启动阶段以指数增长。直到发生丢包事件，记录下慢启动阈值ssthresh，设置为cwnd的一半，然后再次将cwnd设置为那个很小的值。</p>
<p><strong>拥塞避免</strong>：在记录了ssthresh后，在指数增长阶段如果cwnd的值等于ssthresh了，那么如果再次翻倍，可能还会导致拥塞，所以就不会再指数增长了，而是线性增长，就是拥塞避免状态。</p>
<p>正常来说，肯定是再次丢包后就重新开始慢启动了，但是它偏不。因为上面说到丢包有两个原因：超时或者受到三个冗余ACK。而对着两种情况的处理方法是不同的。对于超时，那么和慢启动一样，ssthresh更新为cwnd的一半，cwnd被设置为很小的值。但是如果是由冗余ACK造成的丢包，那么会将cwnd减一半，将ssthresh设置为cwnd的一半，然后进入快速恢复状态。</p>
<p><strong>快速恢复</strong>：没太看明白。</p>
<h1 id="五、TCP安全与SSL"><a href="#五、TCP安全与SSL" class="headerlink" title="五、TCP安全与SSL"></a>五、TCP安全与SSL</h1><p>见HTTPS</p>
<h1 id="六、参考地址"><a href="#六、参考地址" class="headerlink" title="六、参考地址"></a>六、参考地址</h1><p><a href="http://blog.csdn.net/whuslei/article/details/6667471/" target="_blank" rel="external">http://blog.csdn.net/whuslei/article/details/6667471/</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_6d39b5be0101k6v4.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_6d39b5be0101k6v4.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络]]></title>
      <url>http://yoursite.com/2016/10/31/ComputerNetworking/networking/</url>
      <content type="html"><![CDATA[<h1 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h1>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[浅析HTTP协议]]></title>
      <url>http://yoursite.com/2016/10/31/ComputerNetworking/http/</url>
      <content type="html"><![CDATA[<p>HTTP即 HyperText Transfer Protocol，web应用的基础，应该是最常用的应用层协议。有如下几个特点：</p>
<ol>
<li>客户/服务器模式</li>
<li>基于TCP传输</li>
<li>无连接：每次连接只处理一个请求，响应后断开。（keepalive）</li>
<li>无状态：服务器不会保存客户的任何信息。（cookie与session）</li>
</ol>
<h1 id="一、HTTP的报文格式"><a href="#一、HTTP的报文格式" class="headerlink" title="一、HTTP的报文格式"></a>一、HTTP的报文格式</h1><p>HTTP报文分为请求报文和响应报文，二者的格式非常相似。都由三部分组成：起始行、包含属性的首部与以及可选的主体部分。</p>
<h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><p>从客户端发到服务器的是请求报文</p>
<p>从客户端发到服务器的是请求报文</p>
<blockquote>
<p>&lt;方法&gt;&lt; URL &gt;&lt;版本&gt;<br>&lt;首部&gt;</p>
<p>&lt;主体&gt;</p>
</blockquote>
<p>请求报文的起始行包含方法，请求URL以及版本号。<br>接下一行的是首部，首部可以有一后者多行。<br>并不是所有报文都包含主体部分，主体和前面的首部之间有一个空行。如下：</p>
<blockquote>
<p>GEt /special/te.html HTTP/1.0<br>HOST:  www.som.com<br>Connection: close<br>User-agent: Mozilla/5.0<br>Accept-language: fr</p>
</blockquote>
<h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><p>服务器发回给客户端的叫响应报文</p>
<blockquote>
<p>&lt;版本&gt;&lt; 状态码 &gt;&lt;状态信息&gt;<br>&lt;首部&gt;</p>
<p>&lt;主体&gt;</p>
</blockquote>
<p>格式和求情报文差不多，只是首行不同。</p>
<blockquote>
<p>HTTP/1.0 200 OK<br>Connection: close<br>Date: Tue, 09 Aug 2011 15:44:04 GMT<br>Sever: Apache/2.3.3<br>Content-Length: 6821<br>Content-Type: text/html</p>
<p>(date date date …….)</p>
</blockquote>
<h2 id="各字段的意义"><a href="#各字段的意义" class="headerlink" title="各字段的意义"></a>各字段的意义</h2><h3 id="1、方法"><a href="#1、方法" class="headerlink" title="1、方法"></a>1、方法</h3><ul>
<li>GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器</li>
<li>POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。</li>
<li>PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。</li>
<li>HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。</li>
<li>DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。</li>
<li>OPTIONS：查询相应URI支持的HTTP方法。</li>
</ul>
<h4 id="get与head的区别"><a href="#get与head的区别" class="headerlink" title="get与head的区别"></a>get与head的区别</h4><p>head方法与get方法类似，但是服务器响应中没有主体部分，一般用于：</p>
<ul>
<li>在不获取资源的情况下了解资源情况</li>
<li>通过查看响应中的状态码，判断某个对象是否存在</li>
<li>通过查看首部，测试资源是否被修改</li>
</ul>
<h4 id="get与post的区别"><a href="#get与post的区别" class="headerlink" title="get与post的区别"></a>get与post的区别</h4><ol>
<li>get用于从服务器获取资源，post重点在于向服务器发送数据</li>
<li>get传输数据是通过URL请求，以field（字段）= value的形式，置于URL后，并用”?”连接，多个请求数据间用”&amp;”连接，如<a href="http://127.0.0.1/Test/login.action?name=admin&amp;password=admin，这个过程用户是可见的；" target="_blank" rel="external">http://127.0.0.1/Test/login.action?name=admin&amp;password=admin，这个过程用户是可见的；</a><pre><code>post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的；
</code></pre></li>
<li>Get传输的数据量小，因为受URL长度限制，但效率较高；<pre><code>Post可以传输大量数据，所以上传文件时只能用Post方式；
</code></pre></li>
<li>get是不安全的，因为URL是可见的，可能会泄露私密信息，如密码等；<pre><code>post较get安全性较高；
</code></pre></li>
<li>get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码。<pre><code>post支持标准字符集，可以正确传递中文字符。
</code></pre></li>
</ol>
<h3 id="2、版本"><a href="#2、版本" class="headerlink" title="2、版本"></a>2、版本</h3><p>版本主要就是HTTP/1.0和HTTP/1.1。1.1版本中，默认使用的是长链接，而在11.0中，如果要使用长连接，必须要在首部中指定Connection： keep-alive</p>
<h3 id="3、状态码"><a href="#3、状态码" class="headerlink" title="3、状态码"></a>3、状态码</h3><p>HTTP中的状态码分为五大类</p>
<h4 id="100-199-信息性状态码-指示信息–表示请求已接收，继续处理"><a href="#100-199-信息性状态码-指示信息–表示请求已接收，继续处理" class="headerlink" title="100-199 信息性状态码   (指示信息–表示请求已接收，继续处理)"></a>100-199 信息性状态码   (指示信息–表示请求已接收，继续处理)</h4><ul>
<li>100 Continue：收到了请求的初始部分，请客户端继续</li>
</ul>
<h4 id="200-299-成功状态码"><a href="#200-299-成功状态码" class="headerlink" title="200-299 成功状态码"></a>200-299 成功状态码</h4><ul>
<li>200 OK：请求被正常处理</li>
<li>204：请求被受理但没有资源可以返回</li>
<li>206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。</li>
</ul>
<h4 id="300-399-重定向状态码"><a href="#300-399-重定向状态码" class="headerlink" title="300-399 重定向状态码"></a>300-399 重定向状态码</h4><ul>
<li>301 Moved Permanently：永久性重定向</li>
<li>302：临时重定向</li>
<li>303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上</li>
<li>304：客户端已经执行了GET，但文件未变化。</li>
<li>307：临时重定向，与302类似，只是强制要求使用POST方法</li>
</ul>
<h4 id="400-499-客户端错误状态码"><a href="#400-499-客户端错误状态码" class="headerlink" title="400-499 客户端错误状态码"></a>400-499 客户端错误状态码</h4><ul>
<li>400 Bad Request：请求报文语法有误，服务器无法识别</li>
<li>401 Unauthorized：请求需要认证</li>
<li>403 Forbidden：请求的对应资源禁止被访问</li>
<li>404 Not Found：服务器无法找到对应资源</li>
</ul>
<h4 id="500-599-服务器错误状态码"><a href="#500-599-服务器错误状态码" class="headerlink" title="500-599 服务器错误状态码"></a>500-599 服务器错误状态码</h4><ul>
<li>500 Internal Server Error：服务器内部错误</li>
<li>503 Server Unavailable：服务器正忙</li>
<li>505：服务器不支持请求报文的HTTP版本</li>
</ul>
<h3 id="4、首部"><a href="#4、首部" class="headerlink" title="4、首部"></a>4、首部</h3><p>首部和方法配合工作，共同决定了客户端和服务器能做什么。首部主要分为以下几类：</p>
<h4 id="通用首部"><a href="#通用首部" class="headerlink" title="通用首部"></a>通用首部</h4><p>客户端和服务器都可以使用</p>
<ul>
<li>Date：创建报文时间</li>
<li>Connection：连接的管理</li>
<li>Cache-Control：缓存的控制</li>
<li>Transfer-Encoding：报文主体的传输编码方式</li>
</ul>
<h4 id="请求首部"><a href="#请求首部" class="headerlink" title="请求首部"></a>请求首部</h4><p>只在请求报文中有意义的首部</p>
<ul>
<li>Host：请求资源所在服务器</li>
<li>Accept：可处理的媒体类型</li>
<li>Accept-Charset：可接收的字符集</li>
<li>Accept-Encoding：可接受的内容编码</li>
<li>Accept-Language：可接受的自然语言</li>
</ul>
<h4 id="响应首部"><a href="#响应首部" class="headerlink" title="响应首部"></a>响应首部</h4><p>只在响应报文中有意义的首部</p>
<ul>
<li>Accept-Ranges：可接受的字节范围</li>
<li>Location：令客户端重新定向到的URI</li>
<li>Server：HTTP服务器的安装信息</li>
</ul>
<h4 id="实体首部"><a href="#实体首部" class="headerlink" title="实体首部"></a>实体首部</h4><p>请求报文与响应报文实体部分的首部，提供有关实体及内容的信息</p>
<ul>
<li>Allow：资源可支持的HTTP方法</li>
<li>Content-Type：实体主类的类型</li>
<li>Content-Encoding：实体主体适用的编码方式</li>
<li>Content-Language：实体主体的自然语言</li>
<li>Content-Length：实体主体的的字节数</li>
<li>Content-Range：实体主体的位置范围，一般用于发出部分请求时使用</li>
</ul>
<p>以上就是HTTP报文的相关知识点。</p>
<h2 id="缓存控制"><a href="#缓存控制" class="headerlink" title="缓存控制"></a>缓存控制</h2><p>HTTP的缓存可以有效减少数据的传输，提高效率。有一种实现方式就是通过请求头If-None-Match、响应头ETag配合。</p>
<p><strong>响应头ETag</strong></p>
<p>ETag全称Entity Tag，用来标识一个资源。在具体的实现中，ETag可以是资源的hash值，也可以是一个内部维护的版本号。但不管怎样，ETag应该能反映出资源内容的变化，这是Http缓存可以正常工作的基础。</p>
<p><a href="http://www.importnew.com/24907.html/httpcacheetag" target="_blank" rel="external"><img src="http://incdn1.b0.upaiyun.com/2017/06/26c00ce7be17e6d0e5418459312b234b.png" alt="HttpCacheEtag"></a></p>
<p>如上例中所展示的，服务器在返回响应时，通常会在Http头中包含一些关于响应的元数据信息，其中，ETag就是其中一个，本例中返回了值为x1323ddx的ETag。当资源/file的内容发生变化时，服务器应当返回不同的ETag。</p>
<p><strong>请求头If-None-Match</strong></p>
<p>对于同一个资源，比如上一例中的/file，在进行了一次请求之后，浏览器就已经有了/file的一个版本的内容，和这个版本的ETag，当下次用户再需要这个资源，浏览器再次向服务器请求的时候，可以利用请求头If-None-Match来告诉服务器自己已经有个ETag为x1323ddx的/file，这样，如果服务器上的/file没有变化，也就是说服务器上的/file的ETag也是x1323ddx的话，服务器就不会再返回/file的内容，而是返回一个304的响应，告诉浏览器该资源没有变化，缓存有效。</p>
<p><a href="http://www.importnew.com/24907.html/httpcacheifnonematch-1" target="_blank" rel="external"><img src="http://incdn1.b0.upaiyun.com/2017/06/76f787c1d137fbabc1debe6852d93db1.png" alt="HttpCacheIfNoneMatch (1)"></a></p>
<p>如上例中所示，在使用了If-None-Match之后，服务器只需要很小的响应就可以达到相同的结果，从而优化了性能。</p>
<h1 id="二、持续连接与非持续连接"><a href="#二、持续连接与非持续连接" class="headerlink" title="二、持续连接与非持续连接"></a>二、持续连接与非持续连接</h1><p>由于HTTP协议是基于TCP的，所以客户端与服务器响应的时候必须要考虑连接问题。</p>
<h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><p><strong>非持续连接</strong>：每个请求/响应对都是经一个单独的TCP连接发送<br><strong>持续连接</strong>：所有的请求及响应经相同的TCP连接发送</p>
<h2 id="2、区别"><a href="#2、区别" class="headerlink" title="2、区别"></a>2、区别</h2><p>如果使用非持续连接，如果打开一个包含一个HTML文件和10个内联图象对象的网页时，HTTP就要建立11次TCP连接才能把文件从服务机传送到客户机。而如果采用持续连接，HTTP建立一次TCP连接就可把文件从服务机传送到客户机。</p>
<ul>
<li>每次TCP连接必需要建立和断开。客户机和服务机建立一次连接需要执行三向沟通连接法(three-way handshake)，服务机在对象递送之后要断开TCP连接。在建立和断开连接时要占用CPU的资源。如果使用一次连接代替11次连接的话，占用客户机和服务机的CPU时间可大大减少。</li>
<li>对每次连接，客户机和服务机都必须分配发送和接收缓存。这就意味着要影响客户机和服务机的存储器资源，这同样要占用CPU的时间。</li>
<li>对由大数量对象组成的文件，TCP的低速启动算法(slow start-up algorithm)会限制服务机向客户机传送对象的速度。使用HTTP/1.1之后，大多数对象都可以尽最大的速率传送。</li>
</ul>
<h2 id="3、HTTP-1-0-keep-alive"><a href="#3、HTTP-1-0-keep-alive" class="headerlink" title="3、HTTP/1.0+keep-alive"></a>3、HTTP/1.0+keep-alive</h2><p>HTTP/1.1中默认了保持持久连接。但是在1.0的时候并没有。<br>如果HTTP1.1版本的HTTP请求报文不希望使用长连接，则要在HTTP请求报文首部加上Connection: close。</p>
<p>所以，在1.0中客户端如果想保持长连接，必须在首部中添加：Connection：keep-alive<br>如果客户端请求中没有这条消息，那么服务器在响应之后就会关闭连接</p>
<p>《HTTP权威指南》提到，HTTP首部的Connection: Keep-alive是HTTP1.0浏览器和服务器的实验性扩展，当前的HTTP1.1 RFC2616文档没有对它做说明，因为它所需要的功能已经默认开启，无须带着它，但是实践中可以发现，浏览器的报文请求都会带上它。<br>应该忽略所有来自HTTP/1.0设备的Connection首部字段，因为他们可能由比较老的代理服务器转发。</p>
<h2 id="4、什么时候开启keep-alive"><a href="#4、什么时候开启keep-alive" class="headerlink" title="4、什么时候开启keep-alive"></a>4、什么时候开启keep-alive</h2><p>首先要知道什么是动态请求和静态请求，我个人的理解：</p>
<ul>
<li><p>静态请求：就是一些静态的html文件，请求这些资源后直接就可以返回，不用服务器连接其他资源</p>
</li>
<li><p>动态资源：动态页面是ASP、PHP、JSP、ASP.net、Perl、或CGI等编程语言制作的，一般请求的url中会带有？来制定出参数。返回这些资源的时候需要访问数据库或后台来填充某些数据。</p>
<p>​</p>
</li>
</ul>
<p>什么时候开启keep-alive：</p>
<ol>
<li>当你的Server内存充足时，KeepAlive =On还是Off对系统性能影响不大。</li>
<li>当你的Server上静态网页(Html、图片、Css、Js)居多时，建议打开KeepAlive 。</li>
<li>当你的Server多为动态请求(因为连接数据库，对文件系统访问较多)，KeepAlive 关掉，会节省一定的内存，节省的内存正好可以作为文件系统的Cache(vmstat命令中cache一列)，降低I/O压力。</li>
</ol>
<h1 id="三、cookie与session"><a href="#三、cookie与session" class="headerlink" title="三、cookie与session"></a>三、cookie与session</h1><p>由于HTTP协议是无状态的，而web站点通常希望能够识别用户，于是就有了cookie。</p>
<h2 id="1、cookie"><a href="#1、cookie" class="headerlink" title="1、cookie"></a>1、cookie</h2><p>Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器。IETF RFC 2965 HTTP State Management Mechanism 是通用cookie规范。网络服务器用HTTP头向客户端发送cookies，在客户终端，浏览器解析这些cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些cookies 。</p>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/ComputerNetworking/1.png?raw=true" alt="logo"></p>
<h3 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h3><p><strong>会话cookie</strong>：若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。</p>
<p><strong>持久cookie</strong>：若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。</p>
<h2 id="2、session"><a href="#2、session" class="headerlink" title="2、session"></a>2、session</h2><p>session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。</p>
<p>当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已包含了一个session标识 - 称为session id，如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/ComputerNetworking/2.png?raw=true" alt="logo"></p>
<h3 id="sessionid的存储"><a href="#sessionid的存储" class="headerlink" title="sessionid的存储"></a>sessionid的存储</h3><ol>
<li><p>保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识返回给服务器。一般这个cookie的名字都是类似于SEEESIONID，而。比如weblogic对于web应用程序生成的cookie，JSESSIONID=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764，它的名字就是JSESSIONID。 </p>
</li>
<li><p>由于cookie可以被人为的禁止，必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面，附加方式也有两种，一种是作为URL路径的附加信息，表现形式为<a href="http://...../xxx;jsessionid=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764" target="_blank" rel="external">http://...../xxx;jsessionid=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764</a><br>另一种是作为查询字符串附加在URL后面，表现形式为<a href="http://...../xxx?jsessionid=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764" target="_blank" rel="external">http://...../xxx?jsessionid=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764</a><br>这两种方式对于用户来说是没有区别的，只是服务器在解析的时候处理的方式不同，采用第一种方式也有利于把session id的信息和正常程序参数区分开来。 </p>
</li>
<li><p>另一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。比如下面的表单： </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">"testform"</span> <span class="attr">action</span>=<span class="string">"/xxx"</span>&gt;</span> </div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span> </div><div class="line"></div><div class="line">在被传递给客户端之前将被改写成： </div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">"testform"</span> <span class="attr">action</span>=<span class="string">"/xxx"</span>&gt;</span> </div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"jsessionid"</span> <span class="attr">value</span>=<span class="string">"ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764"</span>&gt;</span> </div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="3、cookie与session的区别"><a href="#3、cookie与session的区别" class="headerlink" title="3、cookie与session的区别"></a>3、cookie与session的区别</h2><h3 id="存取方式不同"><a href="#存取方式不同" class="headerlink" title="存取方式不同"></a>存取方式不同</h3><p>Cookie中只能保管ASCII字符串，假如需求存取Unicode字符或者二进制数据，需求先进行编码。Cookie中也不能直接存取Java对象。若要存储略微复杂的信息，运用Cookie是比拟艰难的。<br>而Session中能够存取任何类型的数据，包括而不限于String、Integer、List、Map等。Session中也能够直接保管Java Bean乃至任何Java类，对象等，运用起来十分便当。能够把Session看做是一个Java容器类。</p>
<h3 id="隐私策略不同"><a href="#隐私策略不同" class="headerlink" title="隐私策略不同"></a>隐私策略不同</h3><p>Cookie存储在客户端阅读器中，对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正Cookie中的内容。而Session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。<br>假如选用Cookie，比较好的方法是，敏感的信息如账号密码等尽量不要写到Cookie中。最好是像Google、Baidu那样将Cookie信息加密，提交到服务器后再进行解密，保证Cookie中的信息只要本人能读得懂。而假如选择Session就省事多了，反正是放在服务器上，Session里任何隐私都能够有效的保护。</p>
<h3 id="有效时间不同"><a href="#有效时间不同" class="headerlink" title="有效时间不同"></a>有效时间不同</h3><p>由于Session依赖于名为JSESSIONID的Cookie，而Cookie JSESSIONID的过期时间默许为–1，只需关闭了阅读器该Session就会失效，因而Session不能完成信息永世有效的效果。运用URL地址重写也不能完成。而且假如设置Session的超时时间过长，服务器累计的Session就会越多，越容易招致内存溢出。</p>
<h3 id="服务器压力不同"><a href="#服务器压力不同" class="headerlink" title="服务器压力不同"></a>服务器压力不同</h3><p>Session是保管在服务器端的，每个用户都会产生一个Session。假如并发访问的用户十分多，会产生十分多的Session，耗费大量的内存。</p>
<h3 id="浏览器支持不同"><a href="#浏览器支持不同" class="headerlink" title="浏览器支持不同"></a>浏览器支持不同</h3><p>Cookie是需要客户端浏览器支持的。假如客户端禁用了Cookie，或者不支持Cookie，则会话跟踪会失效。关于WAP上的应用，常规的Cookie就派不上用场了。</p>
<p>假如客户端浏览器不支持Cookie，需要运用Session以及URL地址重写。需要注意的是一切的用到Session程序的URL都要进行URL地址重写，否则Session会话跟踪还会失效。关于WAP应用来说，Session+URL地址重写或许是它唯一的选择。</p>
<h3 id="跨域支持不同"><a href="#跨域支持不同" class="headerlink" title="跨域支持不同"></a>跨域支持不同</h3><p>Cookie支持跨域名访问，例如将domain属性设置为“.biaodianfu.com”，则以“.biaodianfu.com”为后缀的一切域名均能够访问该Cookie。跨域名Cookie如今被普遍用在网络中，例如Google、Baidu、Sina等。而Session则不会支持跨域名访问。Session仅在他所在的域名内有效。<br>仅运用Cookie或者仅运用Session可能完成不了理想的效果。这时应该尝试一下同时运用Cookie与Session。Cookie与Session的搭配运用在实践项目中会完成很多意想不到的效果。</p>
<h1 id="四、参考地址"><a href="#四、参考地址" class="headerlink" title="四、参考地址"></a>四、参考地址</h1><p><a href="http://justsee.iteye.com/blog/1570652" target="_blank" rel="external">http://justsee.iteye.com/blog/1570652</a></p>
<p><a href="http://www.lai18.com/content/407204.html" target="_blank" rel="external">http://www.lai18.com/content/407204.html</a></p>
<p><a href="http://m.blog.csdn.net/article/details?id=51336564" target="_blank" rel="external">http://m.blog.csdn.net/article/details?id=51336564</a></p>
<p><a href="http://www.importnew.com/24907.html" target="_blank" rel="external">http://www.importnew.com/24907.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[浅析DNS协议]]></title>
      <url>http://yoursite.com/2016/10/31/ComputerNetworking/dns/</url>
      <content type="html"><![CDATA[<p>DNS即Domain Name System，用于域名解析是最常用的应用层协议之一。虽然我们没有直接使用过它，但它却经常由其他的应用层协议如HTTP、SMTP、FTP等所使用。以下简单记录一些比较常见的问题。</p>
<h1 id="一、DNS解析过程"><a href="#一、DNS解析过程" class="headerlink" title="一、DNS解析过程"></a>一、DNS解析过程</h1><p>面试中比较常见的问题就是你在浏览器中输入了www.baidu.com之后发生了什么。虽然我不知道正确答案，但是根据我的理解，Web访问肯定是应用层的，本质就是两个应用进程进行通信，那么如果要定位到服务器中的一个进程，就必须要知道它的ip地址和端口号，而www.baidu.com并不是ip地址，路由器也并不认识它，所以，第一步就是把这个网址转换成ip地址，也就要用到DNS服务。下面来说一下DNS解析的步骤：</p>
<h2 id="1、浏览器缓存"><a href="#1、浏览器缓存" class="headerlink" title="1、浏览器缓存"></a>1、浏览器缓存</h2><p>浏览器首先会检查缓存中有没有这个域名对应的解析过的ip地址，如果缓存中有，这个解析过程就到此结束。</p>
<h2 id="2、本机缓存"><a href="#2、本机缓存" class="headerlink" title="2、本机缓存"></a>2、本机缓存</h2><p>如果浏览器中没有缓存，你们浏览器是不会自己解析域名的，而是调用系统的DNS服务。</p>
<p>系统首先也会查找自己的本机缓存，Windows系统中有一个host文件，你可以将任何域名解析到任何能够访问的ip地址，如果你在这里指定了域名对应的ip地址，你们浏览器会首先使用这个ip地址。</p>
<p>host文件还是比较常用的，比如你如果想访问Google，因为它在墙外，所以上级的DNS一般会告诉你你网址写错了没有对应的ip或者告诉你一个错误的ip导致你根本访问不了，这时候有一个办法就是你手动修改host文件，添加ip地址(网上有很多教程)，当然如果你觉得ip对了就能访问到Google那只能说明你还是图样。有些恶意软件也经常修改host文件来劫持DNS。</p>
<h2 id="3、本地DNS服务器"><a href="#3、本地DNS服务器" class="headerlink" title="3、本地DNS服务器"></a>3、本地DNS服务器</h2><p>我们在网络配置都会配置DNS服务器这个选项。如果浏览器和本机都没有缓存，那么系统就会访问这个设置的DNS服务器。既然是本地DNS服务器，你们它肯定是离你不远，一般学校和小区都会有自己的本地DNS。它会缓存大量的解析结果，一般80%的域名解析到这里就已经完成了。</p>
<h2 id="4、根DNS服务器、顶级域服务器、权威DNS服务器"><a href="#4、根DNS服务器、顶级域服务器、权威DNS服务器" class="headerlink" title="4、根DNS服务器、顶级域服务器、权威DNS服务器"></a>4、根DNS服务器、顶级域服务器、权威DNS服务器</h2><p>如果本地DNS没有解析，那么就会直接到根DNS服务器请求解析，根服务器在到下面的几级服务器分级查询，这个过程比较复杂我没有详细了解，这里需要注意的就是查询的方式，即递归查询和迭代查询。</p>
<h3 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h3><p>递归查询是一种DNS 服务器的查询模式，在该模式下DNS 服务器接收到客户机请求，必须使用一个准确的查询结果回复客户机。如果DNS 服务器本地没有存储查询DNS 信息，那么该服务器会询问其他服务器，并将返回的查询结果提交给客户机。</p>
<h3 id="迭代查询"><a href="#迭代查询" class="headerlink" title="迭代查询"></a>迭代查询</h3><p>DNS 服务器另外一种查询方式为迭代查询，DNS 服务器会向客户机提供其他能够解析查询请求的DNS 服务器地址，当客户机发送查询请求时，DNS 服务器并不直接回复查询结果，而是告诉客户机另一台DNS 服务器地址，客户机再向这台DNS 服务器提交请求，依次循环直到返回查询的结果为止。</p>
<p>实际情况中，主机到本地DNS采用递归查询，DNS服务器之间采用迭代查询，如图：</p>
<p><img src="https://github.com/paine1690/HelloWorld/blob/master/pic/ComputerNetworking/8.jpg?raw=true" alt="8"></p>
<h1 id="二、其他常见问题"><a href="#二、其他常见问题" class="headerlink" title="二、其他常见问题"></a>二、其他常见问题</h1><h2 id="1、传输层协议"><a href="#1、传输层协议" class="headerlink" title="1、传输层协议"></a>1、传输层协议</h2><p>书上很常见的一句话就是</p>
<blockquote>
<p>所有的DNS请求和回答报文使用UDP数据报经端口53发送。</p>
</blockquote>
<p>首先，DNS的默认端口号是53，这个必须记住。</p>
<p><em>但是关于传输协议，有一点需要注意，大部分采用UDP，但是会有一些情况采用TCP协议。</em></p>
<p>在此回忆一下TCp与UDP的区别</p>
<blockquote>
<p>TCP是一种面向连接的协议，提供可靠的数据传输，一般服务质量要求比较高的情况会使用这个协议。</p>
<p>UPD是一种无连接的传输层协议，提供面向事务的简单不可靠的信息传送服务。</p>
</blockquote>
<h3 id="为什么DNS默认使用UDP协议？"><a href="#为什么DNS默认使用UDP协议？" class="headerlink" title="为什么DNS默认使用UDP协议？"></a>为什么DNS默认使用UDP协议？</h3><p>UDP虽然不可靠，但是相比TCP速度要快的多，不需要TCP的三次握手，所以响应要快的多。</p>
<h3 id="什么情况下使用TCP协议？"><a href="#什么情况下使用TCP协议？" class="headerlink" title="什么情况下使用TCP协议？"></a>什么情况下使用TCP协议？</h3><p>主要有两种情况：</p>
<p>第一种就是当解析器发出一个查询报文后，返回的回答报文中的tc删节标志比特位被置1时，说明反馈报文因为超长而有删节。这是因为UDP的报文最大长度为512字节。解析器发现后，将使用TCP重发回答报文，TCP允许报文长度超过512字节。既然TCP能将data stream分成多个segment，它就能用更多的segment来传送任意长度的数据。</p>
<p>第二种情况是当一个域的辅助域名服务器启动时，将从该域的主域名服务器primary DNS server执行区域传送。除此之外，辅域名服务器也会定时(一般时3小时)向PDS进行查询以便了解SOA的数据是否有变动。如有变动，也会执行一次区域传送。区域传送将使用TCP而不是UDP，因为传送的数据量比一个request或response多得多。</p>
<h2 id="2、DNS污染与DNS劫持"><a href="#2、DNS污染与DNS劫持" class="headerlink" title="2、DNS污染与DNS劫持"></a>2、DNS污染与DNS劫持</h2><ul>
<li>DNS劫持，指用户访问一个被标记的地址时，DNS服务器故意将此地址指向一个错误的IP地址的行为。范例就是收到各种推送广告等网站。</li>
<li>DNS污染，指的是用户访问一个地址，国内的服务器(非DNS)监控到用户访问的已经被标记地址时，服务器伪装成DNS服务器向用户发回错误的地址的行为。比如不能访问Google、YouTube等。</li>
</ul>
<h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><p>DNS劫持就是指用户访问一个被标记的地址时，DNS服务器故意将此地址指向一个错误的IP地址的行为。范例，网通、电信、铁通的某些用户有时候会发现自己打算访问一个地址，却被转向了各种推送广告等网站，这就是DNS劫持。<br>DNS污染，指的是用户访问一个地址，国内的服务器(非DNS)监控到用户访问的已经被标记地址时，服务器伪装成DNS服务器向用户发回错误的地址的行为。范例，访问Youtube、Facebook之类网站等出现的状况。</p>
<p>一句话来说，<strong>DNS劫持是DNS服务器返回了错误的地址，而DNS污染是其他服务器(非DNS)服务器伪装成DNS服务器返回错误的地址。</strong></p>
<h2 id="3、DNS攻击"><a href="#3、DNS攻击" class="headerlink" title="3、DNS攻击"></a>3、DNS攻击</h2><p>下面列举一下DNS常见的攻击方法：</p>
<h3 id="缓存投毒"><a href="#缓存投毒" class="headerlink" title="缓存投毒"></a>缓存投毒</h3><p>利用控制DNS缓存服务器，把原本准备访问某网站的用户在不知不觉中带到黑客指向的其他网站上。其实现方式有多种，比如可以通过利用网民ISP端的DNS缓存服务器的漏洞进行攻击或控制，从而改变该ISP内的用户访问域名的响应结果;或者，黑客通过利用用户权威域名服务器上的漏洞，如当用户权威域名服务器同时可以被当作缓存服务器使用，黑客可以实现缓存投毒，将错误的域名纪录存入缓存中，从而使所有使用该缓存服务器的用户得到错误的DNS解析结果</p>
<h3 id="DDoS攻击"><a href="#DDoS攻击" class="headerlink" title="DDoS攻击"></a>DDoS攻击</h3><blockquote>
<p>分布式拒绝服务(DDoS:Distributed Denial of Service)攻击指借助于客户/服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动DDoS攻击，从而成倍地提高拒绝服务攻击的威力。通常，攻击者使用一个偷窃帐号将DDoS主控程序安装在一个计算机上，在一个设定的时间主控程序将与大量代理程序通讯，代理程序已经被安装在网络上的许多计算机上。代理程序收到指令时就发动攻击。利用客户/服务器技术，主控程序能在几秒钟内激活成百上千次代理程序的运行。</p>
</blockquote>
<p>以上来自百度百科，DDoS是一类攻击方法，可以用在很多地方，其中DNS只是其中一种。</p>
<p>攻击者能够试图向每个DNS根服务器发送大量请求，使得大多数合法的DNS请求得不到回答。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>还有其他的攻击就不一一介绍了。</p>
<h1 id="三、参考链接"><a href="#三、参考链接" class="headerlink" title="三、参考链接"></a>三、参考链接</h1><p><a href="http://www.360doc.com/content/13/0527/17/11253639_288596772.shtml" target="_blank" rel="external">http://www.360doc.com/content/13/0527/17/11253639_288596772.shtml</a></p>
<p><a href="http://www.cnblogs.com/coderchuanyu/p/4132348.html" target="_blank" rel="external">http://www.cnblogs.com/coderchuanyu/p/4132348.html</a></p>
<p><a href="http://www.williamlong.info/archives/3813.html" target="_blank" rel="external">http://www.williamlong.info/archives/3813.html</a><br><a href="http://www.williamlong.info/archives/3356.html" target="_blank" rel="external">http://www.williamlong.info/archives/3356.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[浅析ARP协议]]></title>
      <url>http://yoursite.com/2016/10/31/ComputerNetworking/ARP/</url>
      <content type="html"><![CDATA[<h1 id="一、ARP协议"><a href="#一、ARP协议" class="headerlink" title="一、ARP协议"></a>一、ARP协议</h1><p> ARP (Address Resolution Protocol) 是个地址解析协议。ARP协议的基本功能就是通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。</p>
<h1 id="二、工作过程"><a href="#二、工作过程" class="headerlink" title="二、工作过程"></a>二、工作过程</h1><h2 id="1、同一网段"><a href="#1、同一网段" class="headerlink" title="1、同一网段"></a>1、同一网段</h2><p>假设主机A和B在同一个网段，主机A要向主机B发送信息。具体的地址解析过程如下</p>
<ol>
<li>主机A首先查看自己的ARP表，确定其中是否包含有主机B对应的ARP表项。如果找到了对应的MAC地址，则主机A直接利用ARP表中的MAC地址，对IP数据包进行帧封装，并将数据包发送给主机B。</li>
<li>如果主机A在ARP表中找不到对应的MAC地址，则将缓存该数据报文，然后以<strong>广播方式</strong>发送一个ARP请求报文。ARP请求报文中的发送端IP地址和发送端MAC地址为主机A的IP地址和MAC地址，目标IP地址和目标MAC地址为主机B的IP地址和全0的MAC地址。由于ARP请求报文以广播方式发送，该网段上的所有主机都可以接收到该请求，但只有被请求的主机（即主机B）会对该请求进行处理。</li>
<li>机B比较自己的IP地址和ARP请求报文中的目标IP地址，当两者相同时进行如下处理：将ARP请求报文中的发送端（即主机A）的IP地址和MAC地址存入自己的ARP表中。之后以<strong>单播方式</strong>发送ARP响应报文给主机A，其中包含了自己的MAC地址。</li>
<li>主机A收到ARP响应报文后，将主机B的MAC地址加入到自己的ARP表中以用于后续报文的转发，同时将IP数据包进行封装后发送出去。</li>
</ol>
<h2 id="2、不同网段"><a href="#2、不同网段" class="headerlink" title="2、不同网段"></a>2、不同网段</h2><p>当主机A和主机B不在同一网段时，主机A就会先向网关发出ARP请求，ARP请求报文中的目标IP地址为网关的IP地址。当主机A从收到的响应报文中获得网关的MAC地址后，将报文封装并发给网关。如果网关没有主机B的ARP表项，网关会广播ARP请求，目标IP地址为主机B的IP地址，当网关从收到的响应报文中获得主机B的MAC地址后，就可以将报文发给主机B；如果网关已经有主机B的ARP表项，网关直接把报文发给主机B。</p>
<h1 id="三、ARP攻击与防范"><a href="#三、ARP攻击与防范" class="headerlink" title="三、ARP攻击与防范"></a>三、ARP攻击与防范</h1><h2 id="1、ARP攻击"><a href="#1、ARP攻击" class="headerlink" title="1、ARP攻击"></a>1、ARP攻击</h2><p>ARP协议有简单、易用的优点，但是也因为其没有任何安全机制而容易被攻击发起者利用。</p>
<ol>
<li><p>攻击者可以仿冒用户、仿冒网关发送伪造的ARP报文，使网关或主机的ARP表项不正确，从而对网络进行攻击。</p>
</li>
<li><p>攻击者通过向设备发送大量目标IP地址不能解析的IP报文，使得设备试图反复地对目标IP地址进行解析，导致CPU负荷过重及网络流量过大。</p>
</li>
<li><p>攻击者向设备发送大量ARP报文，对设备的CPU形成冲击。</p>
<p>​</p>
</li>
</ol>
<h2 id="2、攻击防范"><a href="#2、攻击防范" class="headerlink" title="2、攻击防范"></a>2、攻击防范</h2><h3 id="2-1-源MAC地址固定的ARP攻击检测"><a href="#2-1-源MAC地址固定的ARP攻击检测" class="headerlink" title="2.1  源MAC地址固定的ARP攻击检测"></a>2.1  源MAC地址固定的ARP攻击检测</h3><p>本特性根据ARP报文的源MAC地址进行统计，在5秒内，如果收到同一源MAC地址的ARP报文超过一定的阈值，则认为存在攻击，系统会将此MAC地址添加到攻击检测表项中。在该攻击检测表项老化之前，如果设置的检查模式为过滤模式，则会打印告警信息并且将该源MAC地址发送的ARP报文过滤掉；如果设置的模式为监控模式，则只打印告警信息，不会将该源MAC地址发送的ARP报文过滤掉。</p>
<h3 id="2-2绑定静态网关IP和MAC地址"><a href="#2-2绑定静态网关IP和MAC地址" class="headerlink" title="2.2绑定静态网关IP和MAC地址"></a>2.2绑定静态网关IP和MAC地址</h3><p>主机与网管，双向绑定</p>
<h1 id="四、参考地址"><a href="#四、参考地址" class="headerlink" title="四、参考地址"></a>四、参考地址</h1><p><a href="http://blog.163.com/hlz_2599/blog/static/142378474201341395651453/" target="_blank" rel="external">http://blog.163.com/hlz_2599/blog/static/142378474201341395651453/</a></p>
]]></content>
    </entry>
    
  
  
</search>
